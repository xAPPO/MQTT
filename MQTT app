/*

  Copyright Kevin Hawkins 2019     apps@ukusa.co.uk

  RESTRICTED LICENCE:
  See associated licence file.
  By usage of this application you accept the terms of the licence.
  Currently no part of this code may be copied, redistributed, altered or used in any way without my express written/email permission.
  If you are on my 'invitation only alpha testing thread' this code may be installed for the express purpose of testing and reporting issues. You may also
  alter and adapt this code for your own personal useage, but it may not be onwardly distributed to anyone in any form,  or portions used in any other available application.
  My current intention is to relax the terms of this licence upon general release.

  Logging code was adapted from Eric Vitale's ST LIFX application, with thanks.  Copyright 2016 ericvitale@gmail.com
  Lock code contributed by Casey

  Support via Hubitat community alpha4 thread   

	- please do not hassle Hubitat with any support Q's as their client is an unsupported alpha release

*/



definition(
	name: "MQTT",
	namespace: "ukusa",
	author: "Kevin Hawkins",
	importUrl: "https://raw.githubusercontent.com/xAPPO/MQTT/alpha4a/MQTT%20app",
	description: "Links MQTT with HE devices",
	category: "Intranet Connectivity",
	iconUrl: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches.png",
	iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png",
	iconX3Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png"
)

preferences {  // can't use atomicState vars in this section
			page(name: "Configuration", title: "<b><h2>MQTT</b></h2>", nextPage: "discovery", uninstall: false, hideable: true,hideWhenEmpty: true){  // bad tags but renders OK
			section ("<b>Configuration</b>", hideable: true, hidden: true) {
				input "mqtt", "device.MQTTClient", required: true, title: "<b>MQTT Broker</b>", submitOnChange: false
				input name: "hubName",  type: "text", title: "<b>Hub Name</b>", description: "  choose a unique name for this Hubitat Hub", required: true, displayDuringSetup: true, submitOnChange: false
				input "mqttRemoveDevices", "bool", title: "<b>Purge Discovered Devices</b><br> WARNING: Setting this will delete all your MQTT 'discovered devices' when you click 'Done'. However your selected devices in HA and homie discovery will be re-added automatically when app is run again but you will need to re-add them manually in your Dashboards. Your selected 'published' devices and any manually created devices will not be affected", required: true, defaultValue: false, submitOnChange: true
				input "WipeDevices", "bool", title: "Forget enabled devices", submitOnChange: false
				//input "onoffMap" , "enum", title: "<b>/onoff/ topic is .. (not yet implemented)</b>", required: false, defaultValue: "onoff", options: ["onoff", "switch", "binary", "boolean", "state", "socket"]
				//input "dimMap" , "enum", title: "<b>/dim/ topic is .. (not yet implemented)</b>", required: false, defaultValue: "dim", options: ["dim", "level", "brightness", "light", "bulb"]
				//input "stateMap" , "enum", title: "<b>on : off default value is .. (not yet implemented)</b>", required: false, defaultValue: "true:false", options: ["true:false", "True:False", "TRUE:FALSE", "on:off", "On:Off", "ON:OFF", "yes:no", "Yes:No","YES:NO","1:0"]
				//input "cmdMap" , "enum", title: "<b>command default topic is .. (not yet implemented)</b>", required: false, defaultValue: "set", options: ["set", "cmd", "control"] //, "state"]
				input "logging", "enum", title: "<b>Log Level</b>", required: false, defaultValue: "INFO", options: ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "DISABLED"]
				input "tempUnits", "enum", title: "<b>Temperature units</b>", required: false, defaultValue: "Celsius x.xx째C", options: ["Celsius x.xx째C", "Celsius x.x째C", "Fahrenheit 째F"]
				input "lengthUnits", "enum", title: "<b>Length units (not yet functional)</b>", required: false, defaultValue: "Metric (mm,m,km)", options: ["Metric (mm,m,km)", "Imperial (inches/feet/miles)"]
                input "allowMqttUnlock", "bool", title: "<b>Allow Unlock via MQTT</b><br>WARNING: Setting this will allow unlocking locks via MQTT.  It is recommended that your MQTT instance requires username/password & is protected by SSL", required: false, defaultValue: false, submitOnChange: false
            }
			section ("<B>Import these devices from MQTT<b>",hideable: true, hidden: true){
				input "adhoc", "capability.telnet", multiple: true, required: false, title: "<b>MQTT virtual devices</b>", submitOnChange: false
			}
			section ("<b>Publish these device capabilities to MQTT</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                input "modes", "bool", title: "Mode changes", required: false
                input "everything", "capability.*",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Everything (all capabilities/attributes)</b>", submitOnChange: false
                input "alarms", "capability.alarm",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Alarms</b>", submitOnChange: false  
                input "batterysensors", "capability.battery",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Battery sensors</b>", submitOnChange: false
                input "bulbs", "capability.bulb",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Bulbs</b>", submitOnChange: false  
             input "buttons", "capability.button",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons</b>", submitOnChange: false  
             input "buttonshold", "capability.holdableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons holdable</b>", submitOnChange: false
                input "buttonspush", "capability.pushableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons pushable</b>", submitOnChange: false 
             input "buttonsrelease", "capability.releasableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons releasable</b>", submitOnChange: false
             input "buttonsdtap", "capability.doubleTapableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons double tapable</b>", submitOnChange: false
                input "carbonmonoxidesensors", "capability.carbonMonoxideDetector",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Carbon monoxide detectors</b>", submitOnChange: false
                input "chimes", "capability.chime",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Chimes</b>", submitOnChange: false               
                input "colour", "capability.colorControl",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour control light devices</b>", submitOnChange: false
				input "colourT", "capability.colorTemperature",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour temperature light devices</b>", submitOnChange: false
                input "contactsensors", "capability.contactSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Contact sensors</b>", submitOnChange: false
                input "dimmers", "capability.switchLevel",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Dimmers</b>", submitOnChange: false
				input "garagedoors", "capability.garageDoorControl",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Garage Door</b>", submitOnChange: false  
                input "humiditysensors", "capability.relativeHumidityMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Humidity sensors</b>", submitOnChange: false
				input "keypads", "capability.securityKeypad",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Keypads</b>", submitOnChange: false
                input "locks", "capability.lock",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Locks</b>", submitOnChange: false  //Casey
				input "motionsensors", "capability.motionSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Motion sensors</b>", submitOnChange: false
                input "outlets", "capability.outlet",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Outlets</b>", submitOnChange: false
                input "powersensors", "capability.powerMeter",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Power sensors</b>", submitOnChange: false
				input "presencesensors", "capability.presenceSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Presence sensors</b>", submitOnChange: false
                input "relayswitches", "capability.relaySwitch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Relay Switches</b>", submitOnChange: false
                input "shocksensors", "capability.shockSensor",hideWhenEmpty: true, title: "<b>Shock sensors</b>", multiple: true, required: false
                input "smokesensors", "capability.smokeDetector",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Smoke detectors</b>", submitOnChange: false
                input "switches", "capability.switch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Switches</b>", submitOnChange: false
                input "tempsensors", "capability.temperatureMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Temperature sensors</b>", submitOnChange: false
				input "thermostats", "capability.thermostat",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Thermostats</b>", submitOnChange: false
                input "valves", "capability.valve",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Valves</b>", submitOnChange: false 
                input "globVars", "device.VirtualOmniSensor", required: false, title: "<b>Global Variables</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                input "gVars", "device.RMConnectorVariable", required: false, title: "<b>New Global Vars</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                //input "variables", "device.VirtualOmniSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Variables</b>", submitOnChange: false 
                input "voltagesensors", "capability.voltageMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Voltage sensors</b>", submitOnChange: false
                input "watersensors", "capability.waterSensors",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Water Sensors</b>", submitOnChange: false
                input "windowshades", "capability.windowShades",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Window Shades</b>", submitOnChange: false
                input "sensors", "capability.*",hideWhenEmpty: true, title: "<b>List devices Capabilities and Attributes to Hubitat Topic</b>", multiple: true, required: false
                //TODO add remaining sensors type (as and if requested)
               
			}	

			section ("<b>MQTT Publish Formats</b>", hideable: true, hidden: true){
				input "HEBasic", "bool", title: "<b>Hubitat basic MQTT</b>", required: true, defaultValue: false, submitOnChange: false 
				input "homiePublish", "bool", title: "<b>homie 3 protocol</b>", required: true, defaultValue: false, submitOnChange: false
                input "minHomie", "bool", title: "<b>Complete & compliant homie topics</b>", required: true, defaultValue: true, submitOnChange: false
				input "homieStatesPersist","bool",title: "<b>&nbsp&nbsp&nbsp&nbsp... retain homie states</b>", required: false, defaultValue: true, submitOnChange: false
				input "HADiscovery", "bool", title: "<b>Home Assistant MQTT discovery protocol (requires homie3 publish enabled)</b>", required: true, defaultValue: false, submitOnChange: false 	
				input name: "HADiscoveryTopic",  type: "text", title: "<b>Home Assistant Discovery Topic</b>", description: "  as configured in HA", required: false, displayDuringSetup: true, submitOnChange: false
				input "HARemember", "enum", title: "<b>Home Assistant MQTT discovered devices</b>", required: false, defaultValue: "Forget",options: ["Forget", "Remember"], submitOnChange: false
			    
            }
		}
	}
	page(name: "discovery", title: "Select MQTT discovered devices", install: true, uninstall: true)

def discovery() {  // can use atomicState vars in this section
    dynamicPage(name: "discovery", title: "", install: true, nextPage:"hrefPage", uninstall: false) { 
	section ("<h2><b>MQTT Discovery Protocols > HE </b></h2>(optional)"){
		if (settings?.homieDiscovery && settings?.homieDevice!=null) homieEnabled='<font color="green">' else homieEnabled='<font color="darkred">'
		if (settings?.HAStatestream && settings?.HAStatestreamTopic!=null)  HAEnabled='<font color="green">' else HAEnabled='<font color="darkred">'
        if (settings?.SonoffDiscovery)  SonoffEnabled='<font color="green">' else SonoffEnabled='<font color="darkred">'
        if (settings?.ShellyDiscovery)  ShellyEnabled='<font color="green">' else ShellyEnabled='<font color="darkred">'
	}

	// check variables for initialization & initialize if needed
	atomicState.onoffDevices = (atomicState.onoffDevices != null)?atomicState.onoffDevices:[]
	atomicState.dimDevices = (atomicState.dimDevices != null)?atomicState.dimDevices:[]
	atomicState.sensorDevices = (atomicState.sensorDevices != null)?atomicState.sensorDevices:[]
    atomicState.buttonDevices = (atomicState.buttonDevices != null)?atomicState.buttonDevices:[]
    atomicState.varDevices = (atomicState.varDevices != null)?atomicState.varDevices:[] 
    atomicState.lockDevices = (atomicState.lockDevices != null)?atomicState.lockDevices:[] //Casey
    atomicState.ShellyDevices = (atomicState.ShellyDevices != null)?atomicState.ShellyDevices:[]
    atomicState.SonoffDevices = (atomicState.SonoffDevices != null)?atomicState.SonoffDevices:[]
    atomicState.HAPresenceDevices = (atomicState.HAPresenceDevices != null)?atomicState.HAPresenceDevices:[]
	atomicState.HASwitchDevices = (atomicState.HASwitchDevices != null)?atomicState.HASwitchDevices:[]
	atomicState.HALightDevices = (atomicState.HALightDevices != null)?atomicState.HALightDevices:[]
	atomicState.HASensorDevices = (atomicState.HASensorDevices != null)?atomicState.HASensorDevices:[]
	atomicState.HABinarySensorDevices = (atomicState.HABinarySensorDevices != null)?atomicState.HABinarySensorDevices:[]
	atomicState.HAGroupDevices = (atomicState.HAGroupDevices != null)?atomicState.HAGroupDevices:[]
	atomicState.HAInputBooleanDevices = (atomicState.HAInputBooleanDevices != null)?atomicState.HAInputBooleanDevices:[]
        atomicState.HACoverDevices = (atomicState.HACoverDevices != null)?atomicState.HACoverDevices:[]
        atomicState.HALockDevices =  (atomicState.HALockDevices != null)?atomicState.HALockDevices:[]
        atomicState.HADeviceTrackerDevices = (atomicState.HADeviceTrackerDevices != null)?atomicState.HADeviceTrackerDevices:[]
        atomicState.HAClimateDevices =  (atomicState.HAClimateDevices != null)?atomicState.HAClimateDevices:[]
		numText=''
		def numDevs=0
		if (atomicState.onoffDevices != null) numDevs+= atomicState.onoffDevices.size()
		if (atomicState.dimDevices != null) numDevs+= atomicState.dimDevices.size()
		if (atomicState.sensorDevices != null) numDevs+= atomicState.sensorDevices.size()
        if (atomicState.lockDevices != null) numDevs+= atomicState.lockDevices.size()  //Casey
        if (atomicState.buttonDevices != null) numDevs+= atomicState.buttonDevices.size()
        if (atomicState.varDevices != null) numDevs+= atomicState.varDevices.size()
        
        
        
        
        
        
        // TODO add more ? .. test for null redundant
		def numEnabled=0
		if (Homie_onoff!=null) numEnabled += settings?.Homie_onoff.size()
		if (Homie_dim!=null) numEnabled += settings?.Homie_dim.size()
		if (Homie_sensors!=null) numEnabled += settings?.Homie_sensors.size()
		if (settings?.homieDiscovery){
			if (atomicState.started) numText = "${numEnabled} of ${numDevs} discovered devices enabled"
			else numText="checking"
		}
		else {
			numText="disabled"
		}		
		section (homieEnabled+"<b>homie</b>    [${numText}]</font>", hideable: true, hidden: true){
		input "homieDiscovery", "bool", title: "<b>homie 3 protocol<b>", required: true, defaultValue: false, submitOnChange: false
		input name: "homieDevice", type: "text", title: "<b>homie device topic name</b>", description: "... to import devices from", required: false, displayDuringSetup: false
		input "Homie_onoff", "enum", multiple: true, title: "<b>Discovered ${atomicState.onoffDevices.size()} homie switches</b>", options: atomicState.onoffDevices.sort()
		input "Homie_dim", "enum", multiple: true, title: "<b>Discovered ${atomicState.dimDevices.size()} homie dimmers</b>", options: atomicState.dimDevices.sort()
		input "Homie_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.sensorDevices.size()} homie sensors with ${0} enabled</b>", options: atomicState.sensorDevices.sort()
		input "Homie_button", "enum", multiple: true, title: "<b>Discovered ${atomicState.buttonDevices.size()} homie buttons</b>", options: atomicState.buttonDevices.sort()
        input "Homie_variable", "enum", multiple: true, title: "<b>Discovered ${atomicState.varDevices.size()} homie variables</b>", options: atomicState.varDevices.sort()


        }
		
	section {}
		
		numText=''
		numEnabled=0
		// TODO - below line can still error initially ....alpha
        
		numDevs = atomicState.HASwitchDevices.size() + atomicState.HALightDevices.size()+atomicState.HASensorDevices.size()+atomicState.HABinarySensorDevices.size()+atomicState.HAGroupDevices.size()+atomicState.HAInputBooleanDevices.size()+atomicState.HACoverDevices.size()+atomicState.HALockDevices.size()+atomicState.HADeviceTrackerDevices.size()+atomicState.HAClimateDevices.size()
		if (HA_Switches!=null) numEnabled = settings?.HA_Switches.size()
		if (HA_Lights!=null) numEnabled += settings?.HA_Lights.size()
		if (HA_Sensors!=null) numEnabled += settings?.HA_Sensors.size()
		if (HA_BinarySensors!=null) numEnabled += settings?.HA_BinarySensors.size()
		if (HA_Groups!=null) numEnabled += settings?.HA_Groups.size()
        if (HA_Presence!=null) numEnabled += settings?.HA_Presence.size()
		if (HA_InputBooleans!=null) numEnabled += settings?.HA_InputBooleans.size()
		if (numEnabled>=0) numText = "${numEnabled} of ${numDevs} enabled"
		if (settings?.HAStatestream){
		if (atomicState.started) numText = "${numEnabled} of ${numDevs} discovered devices enabled"
			else numText="checking"
		}
		else {
			numText="disabled"
		}
		section (HAEnabled+"<b>Home Assistant</b>    [${numText}]</font>", hideable: true, hidden: true) {
			if (settings?.HA_Switches != null) HAsw = settings?.HA_Switches.size() else HAsw=0  // Elvis isnt in the house TODO
			if (settings?.HA_Lights != null) HAli = settings?.HA_Lights.size() else HAli=0
			if (settings?.HA_Sensors != null) HAse = settings?.HA_Sensors.size() else HAse=0
			if (settings?.HA_BinarySensors != null) HAbs = settings?.HA_BinarySensors.size() else HAbs=0
			if (settings?.HA_Groups != null) HAg = settings?.HA_Groups.size() else HAg=0
            if (settings?.HA_Presence != null) HAp = settings?.HA_Presence.size() else HAp=0
			if (settings?.HA_InputBooleans != null) HAib = settings?.HA_InputBooleans.size() else HAib=0
            if (settings?.HA_Covers != null) HAco = settings?.HA_Covers.size() else HAco=0
            if (settings?.HA_Locks != null) HAlo = settings?.HA_Locks.size() else HAlo=0
            if (settings?.HA_DeviceTrackers != null) HAd = settings?.HA_DeviceTrackers.size() else HAd=0
            if (settings?.HA_Climates != null) HAcl = settings?.HA_Climates.size() else HAcl=0
		input "HAStatestream", "bool", title: "Home Assistant statestream", required: true, defaultValue: false, submitOnChange: true 
		input name: "HAStatestreamTopic", type: "text", title: "Home Assistant Statestream topic", description: "", required: false, displayDuringSetup: false
		input "HA_Switches", "enum", multiple: true, title: "Discovered  ${atomicState.HASwitchDevices.size()} Home Assistant switches &nbsp &nbsp &nbsp [^${HAsw}]", options: atomicState.HASwitchDevices.sort()
		input "HA_Lights", "enum", multiple: true, title: "Discovered ${atomicState.HALightDevices.size()} Home Assistant lights &nbsp &nbsp &nbsp [^${HAli}]" , options: atomicState.HALightDevices.sort()
		input "HA_Sensors", "enum", multiple: true, title: "Discovered ${atomicState.HASensorDevices.size()} Home Assistant sensors &nbsp &nbsp &nbsp [^${HAse}]" , options: atomicState.HASensorDevices.sort()
		input "HA_BinarySensors", "enum", multiple: true, title: "Discovered ${atomicState.HABinarySensorDevices.size()} Home Assistant binary sensors &nbsp &nbsp &nbsp [^${HAbs}]" , options:  atomicState.HABinarySensorDevices.sort()
		input "HA_Groups", "enum", multiple: true, title: "Discovered ${atomicState.HAGroupDevices.size()} Home Assistant groups &nbsp &nbsp &nbsp [^${HAg}]" , options: atomicState.HAGroupDevices.sort()
        input "HA_Presence", "enum", multiple: true, title: "Discovered ${atomicState.HAPresenceDevices.size()} Home Assistant persons &nbsp &nbsp &nbsp [^${HAp}]" , options: atomicState.HAPresenceDevices.sort()
		input "HA_InputBooleans", "enum", multiple: true, title: "Discovered ${atomicState.HAInputBooleanDevices.size()} Home Assistant input booleans &nbsp &nbsp &nbsp [^${HAib}]" , options:  atomicState.HAInputBooleanDevices.sort()
		input "HA_Covers", "enum", multiple: true, title: "Discovered ${atomicState.HACoverDevices.size()} Home Assistant Covers &nbsp &nbsp &nbsp [^${HAco}]" , options:  atomicState.HACoverDevices.sort()
		input "HA_Locks", "enum", multiple: true, title: "Discovered ${atomicState.HALockDevices.size()} Home Assistant Locks &nbsp &nbsp &nbsp [^${HAlo}]" , options:  atomicState.HALockDevices.sort()
		input "HA_DeviceTrackers", "enum", multiple: true, title: "Discovered ${atomicState.HADeviceTrackerDevices.size()} Home Assistant Device Trackers &nbsp &nbsp &nbsp [^${HAd}]" , options:  atomicState.HADeviceTrackerDevices.sort()
        input "HA_Climates", "enum", multiple: true, title: "Discovered ${atomicState.HAClimateDevices.size()} Home Assistant Climate Devices &nbsp &nbsp &nbsp [^${HAcl}]" , options:  atomicState.HAClimateDevices.sort()

    // Currently not yet supporting these & more : 
            /*
            automation
            media_player
            persistent_notification
            sun
            updater
            */
    
        }
        
        section {}
        
        numText= "not implemented yet"
        section (ShellyEnabled+"<b>Shelly Devices</b>    [${numText}]</font>", hideable: true, hidden: true) {
        if (settings?.Shelly_Devices != null) SHsw = settings?.Shelly_Devices.size() else SHsw=0 
		input "ShellyDiscovery", "bool", title: "Shelly discovery", required: true, defaultValue: false, submitOnChange: true 
        input "Shelly_Devices", "enum", multiple: true, title: "Discovered  ${atomicState.ShellyDevices.size()} Shelly Devices &nbsp &nbsp &nbsp [^${SHsw}]", options: atomicState.ShellyDevices.sort()
        /*
		input "HA_Switches", "enum", multiple: true, title: "Discovered  ${atomicState.HASwitchDevices.size()} Home Assistant switches &nbsp &nbsp &nbsp [^${HAsw}]", options: atomicState.HASwitchDevices.sort()
		input "HA_Lights", "enum", multiple: true, title: "Discovered ${atomicState.HALightDevices.size()} Home Assistant lights &nbsp &nbsp &nbsp [^${HAli}]" , options: atomicState.HALightDevices.sort()
		input "HA_Sensors", "enum", multiple: true, title: "Discovered ${atomicState.HASensorDevices.size()} Home Assistant sensors &nbsp &nbsp &nbsp [^${HAse}]" , options: atomicState.HASensorDevices.sort()
		input "HA_BinarySensors", "enum", multiple: true, title: "Discovered ${atomicState.HABinarySensorDevices.size()} Home Assistant binary sensors &nbsp &nbsp &nbsp [^${HAbs}]" , options:  atomicState.HABinarySensorDevices.sort()
		input "HA_Groups", "enum", multiple: true, title: "Discovered ${atomicState.HAGroupDevices.size()} Home Assistant groups &nbsp &nbsp &nbsp [^${HAg}]" , options: atomicState.HAGroupDevices.sort()
		input "HA_InputBooleans", "enum", multiple: true, title: "Discovered ${atomicState.HAInputBooleanDevices.size()} Home Assistant input booleans &nbsp &nbsp &nbsp [^${HAib}]" , options:  atomicState.HAInputBooleanDevices.sort()
		*/
        }
/*        
        section {}
        
        section (SonoffEnabled+"<b>Sonoff / Tasmota Devices</b>    [${numText}]</font>", hideable: true, hidden: true) {
        if (settings?.Sonoff_Devices != null) SOsw = settings?.Sonoff_Devices.size() else SOsw=0
		input "SonoffDiscovery", "bool", title: "Sonoff - Tasmota discovery", required: true, defaultValue: false, submitOnChange: true 
        input "Sonoff_Devices", "enum", multiple: true, title: "Discovered  ${atomicState.ShellyDevices.size()} Sonoff Devices &nbsp &nbsp &nbsp [^${SOsw}]", options: atomicState.SonoffDevices.sort()

        }
*/

	}
}

def installed() {
	log ( "${app.name} Installed","INFO")
	atomicState.topicMap=[:]
	atomicState.nameMap=[:]
	wipe() // also initialises 
	initialize()
    atomicState.appCount=0
}

def updated() {
	log ("${app.name} Updated", "INFO")
	unsubscribe()
    atomicState.count=0
	unschedule()
	initialize()
}

def uninstalled() {
    log ("Deleting all child devices", "WARN")
    wipe()
	removeAllChildDevices()
}

def sysStart(evt) {
    log  ("===================== Reboot =====================", "INFO")
	// TODO now that I understand ReBoot I need to consider whether I need to run the whole initialize() or can streamline
    unschedule()
    unsubscribe()
    atomicState.appCount=0
	initialize()
}

def reStart(evt) {
    log ("===================== ReStart =====================", "INFO")
    // TODO now that I understand ReStart and concurrency better I need to consider whether I need to run the whole initialize() or can streamline
    // I probably do have to dis/reconnect the broker in order to remove and reinstate existing subscriptions
    unschedule()
    unsubscribe()
	initialize()
}

def initialize() {
    if (atomicState.appcount==null) atomicState.appCount=0
    log ("initialising with App count ${atomicState.appCount}","WARN")
    def date1= new Date()
    atomicState.properties=[:]
    countTry=10
    aborting=false
    if (atomicState.abortable) atomicState.abort=true  // JUST TO TEST - will abort if still possible
    while (atomicState.abort) {
        log("Awaiting earlier App to abort [$countTry]","WARN")
        aborting=true
        countTry--
            if (countTry < 0) { 
                log ("Continuing.. Given up waiting for earlier app to abort", "WARN")
                atomicState.abort=false
            }
       else pauseExecution(6000)
    }
    if (aborting) log ( "Earler app sucessfully aborted","WARN")
    aborting=false
    atomicState.abort=false
    mqttSubscribes()
    mqtt.setStateVar ("connectionAttempts",0)
    atomicState.MQTTconnected=false
	atomicState.normHubName = normalize(settings?.hubName)
	log ("Hubitat hub name is : " + settings?.hubName,"INFO")
    mqtt.setStateVar ("normHubName",atomicState.normHubName)
    xtra=0
    /*
    for (int i = 0; i < 86 && (atomicState.MQTTconnected==false); i++) {  // tries to reconnect every 10 seconds
        if (i==0)  log ("Waiting for MQTT connection: $atomicState.MQTTconnected","INFO")
        else log ("Waiting another try [$i] until MQTT connected: $atomicState.MQTTconnected","WARN")
        mqtt.reset()
        pauseExecution(10000+xtra)  // initially 10 seconds
        if (i>5) xtra = 20000  // increase to 30 seconds after a minute
        else if (i>24) xtra = 50000  // 1 minute after 10
        else if (i>74) xtra = 590000  // 10 minutes after an hour
        // will currently run for 2 hours    
    }
    if (i>85) {
        log ("MQTT has failed to connect. Restart the app to try again","ERROR")
        return
             }
    */
    mqtt.reset()  // Only want to do this once as the driver will continue to attempt reconnects
    countTry=0
    while (!atomicState.MQTTconnected) {
        log("MQTT .. awaiting connection .. [$countTry]","WARN")
        countTry++
            if (countTry > 10) { 
                log   ("Aborting Restart - too many attempts","ERROR")
                return
            }
        pauseExecution(10000)
    }
    log ("MQTT has now connected","INFO")

    atomicState.appCount = atomicState.appCount + 1
    log ("There are now ${atomicState.appCount} instances running","INFO")
        if (atomicState.appCount > 1) {
        log ("####### WE HAVE ${atomicState.appCount} instances running ? #######", "WARN")
            log ("Started is ${atomicState.started} and abort is ${atomicState.abort}","WARN") 
            atomicState.appCount = atomicState.appCount - 1
            if (!atomicState.abortable) {
                log ("Cant abort earlier version now so will continue","WARN")
                if (atomicState.started) log ("Earlier version started up completely so will continue","WARN")
            }
            else {
                atomicState.abort=true  // try and kill previous version
            //return // kill this one

                while (atomicState.abort) {
                aborting=true
                log("Awaiting previous App to abort [$countTry]","WARN")
                countTry++
                if (countTry > 10) { 
                    log ("Continuing.. Given up waiting for previous app to abort","WARN")
                    atomicState.abort=false
                }
               else pauseExecution(6000)
            }
            if (aborting) log ( "Previous app sucessfully aborted","WARN")
           }
        }

    unschedule ("reStart")  // stop any others from starting that are already scheduled
    if (settings?.HAStatestream) {
        mqtt.setStateVar ("HAStatestreamTopic",settings?.HAStatestreamTopic)
        atomicState.HA=settings?.HAStatestreamTopic
    }
	if (settings?.HADiscovery) {  // Outgoing HE > HA
		// TODO ensure homie publish or other adequate topic structure is enabled
		if (!settings?.homiePublish) log ("You must enable homie3 publish too for HA Discovery to work correctly","ERROR")
        
		settings?.homiePublish=true    // TODO doesn't work !  settings are r/o - need to use an atomicState var
        atomicState.HA=settings?.HAStatestreamTopic
		mqtt.subscribeTopic(atomicState.HA+'/status') 
	}
    if (!settings?.minHomie) {
        if (settings?.homiePublish) log("The published homie topic tree has been reduced in content and is no longer homie3 compliant","WARN")
    }
	log("Initializing...", "DEBUG")
	atomicState.restartPending=false   // TODO check MQTT connected
	//prepare for supporting personal preferences
	// maybe via command() rather than in UI ? use atomicState rather than settings?
	// this will proliferate MQTT variances :-(
	/*
	atomicState.cmd = "set" // cmd command control custom
	atomicState.onoff = "onoff" // light switch binary boolean state
	atomicState.dim = "dim" // level dimmer brightness
	atomicState.boolean = "true" // True TRUE yes 1 On ON on
	*/
	atomicState.started=false
    atomicState.abortable=true
	if (atomicState.abort) { 
            abort(1)
            return
    }
	if (settings?.homiePublish)
	{
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','init',1,true,settings?.minHomie)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$homie','3.0.1',1,true,settings?.minHomie) 
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$implementation','groovy:uk.co.ukusa.mqtt',1,true,settings?.minHomie)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/version','4a(5)',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/name','alpha',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$name',settings?.hubName,1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$mac','BB:AA:DD:AA:55:55',1,true,settings?.minHomie)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$localip','1.2.3.4',1,true,settings?.minHomie)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$implementation/version','alpha4a rel',1,true)
        if (modes) currentMode()
	}
	mqtt.setStateVar("logLevel",determineLogLevel(settings?.logging ?: "INFO"))
	if ((settings?.mqttRemoveDevices == true))
	{
		log ("Deleting all the MQTT child devices", "DEBUG")
		removeAllChildDevices()  // somehow these stay orphaned, so need this or need to create differently
		// wipe() // This loses you previously enabled devices but if already enabled it also stops them being added again
	}
	if (settings?.WipeDevices == true) {
		wipe()
	}
	atomicState.homie=settings?.homieDevice  // setting the homie tree master device topic for discovery
	if (atomicState.abort) { 
            abort(2)
            return
    }
    deviceEventSubscribes()
	
	atomicState.MQTTOnOffDevices=0
	atomicState.MQTTDimDevices=0
    atomicState.MQTTLockDevices=0
	atomicState.adhocDevices=0
	atomicState.MQTTRGBc=0
	atomicState.MQTTRGBt=0
    if (atomicState.abort) return
    count=0
    count = sensorSubscribes(count)  // currently registers ALL capabilities and attributes for these sensors from all drop downs TODO change
    count = deviceSubscribes(count)  // currently registers ALL capabilities and attributes for these devices from all drop downs TODO change
    count = everythingSubscribes(count)   // registers ALL capabilities and attributes for these devices
	log ("reinitializing", "TRACE")
	atomicState.createDevices=false
	atomicState.lastDevice=''
	if (settings?.HEBasic){
		subscribeOneOffTopics("Hubitat/${settings?.hubName}/+/+/set") // incoming cmds to control HE devices - all types .. or ..
	}
	if (settings?.homiePublish) {
		subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/set") // incoming cmds to control HE devices - all types .. or could restrict to supported types
        subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/+/set") // incoming cmds to control HE devices at sub level eg color/rgb - all types .. or could restrict to supported types
	}

    buildMQTTLookup()  // builds the mapping of device names
	if (atomicState.abort) { 
            abort(3)
            return
    }	
	synchDevices() // handles all the initial state publications for all enabled devices
	if (atomicState.abort) { 
            abort(4)
            return
    }
    
    if(settings?.ShellyDiscovery) {
         subscribeShellyTopic()
         atomicState.delay += 5  //TODO tweak
    }
    if(settings?.SonoffDiscovery) {
        runIn (atomicState.delay, "subscribeSonoffTopic")
        atomicState.delay += 5  //TODO tweak
    }	
	if(settings?.homieDiscovery) {
		log ("homie discovery enabled", "INFO")
		runIn(atomicState.delay, "subscribeHomieTopic")
		atomicState.delay += 5  //TODO tweak
 atomicState.delay += 10
		runIn(atomicState.delay, "subscribeHomieStateTopics")  
		atomicState.delay += 2  // TODO tweak - we have the number of homie devices very early in MQTT driver  reduced from 10 to 2
atomicState.delay += 10
        runIn (atomicState.delay, "subscribeHomieNameTopics")
		atomicState.delay += 5 // TODO tweak
	}
	else log ("Skipping homie MQTT discovery", "INFO")
	if (atomicState.abort) { 
            abort(6)
            return
    }
	if(settings?.HAStatestream){
		log ("HA stateStream enabled", "INFO")
		atomicState.delay += 5  //TODO tweak
		runIn (atomicState.delay, "subscribeHADevices")
		atomicState.delay += 5  //TODO tweak
		runIn (atomicState.delay, "subscribeHADeviceEvents")
		atomicState.delay += 10 // TODO tweak
		atomicState.delay+=30  // TODO check and calculate based on # sensors
	}
	else log ("Skipping HA stateStream MQTT discovery", "INFO")
	if (atomicState.abort) { 
            abort(6)
            return
    }
	log ("Total startup time will be around " + atomicState.delay + " seconds", "INFO")
    runIn (atomicState.delay, "devSummary")
    log ("Initialize exit", "INFO")
    atomicState.abort=false
    atomicState.abortable=false
}

def abort (where) {
            log ("Abort Initialize $where","Error")
            unschedule()// This may need removing too
            //unsubscribe()
            atomicState.abort=false
            atomicState.abortable=false
            atomicState.appCount=atomicState.appCount-1    
}

def addProperty(key,value) {
    //atomicState.properties=[:]
    def temp=atomicState.properties
    if (temp[key] == null) {
       // log.error "Created first key for ${key}   ${value} "
        temp[key] = value
        mqtt.publishMsg (key+'/$properties',"${temp[key]}",1,true,settings?.minHomie)
    }
    else {
        if (temp[key].contains (value)){
        //    log.error "${value} Already exists in ${temp[key]}"
            return
        }
        temp[key] = temp[key] + "," + value
        // log.error "Appended ${value}  to ${key} ${temp[key]}"
        mqtt.publishMsg (key+'/$properties',"${temp[key]}",1,true,settings?.minHomie)
        
    }
    atomicState.properties=temp
}
    
    

def buildMQTTLookup() {            // allows lookup of the HE device using normalised name used in homie tree
    atomicState.nameMap = [:]
	atomicState.topicMap=[:]
    MQTTswitches = (settings?.switches)
	count=0
	nodes=""
	if (MQTTswitches != null) {
		log ("["+(MQTTswitches.size()) +  "] switches enabled for MQTT ", "TRACE")
		def temp = atomicState.nameMap
		for (String item : MQTTswitches) {
   			log ("    MQTT Switch Device " + item, "TRACE")
			normName= normalize(item)
			nodes=nodes+normName +','
			// Build a lookup table for normName to full name
			temp[normName] = item
	//switched(null, item, MQTTswitches.currentSwitch[0]) // sends an initial status message to MQTT
	// Maybe here's a good place to setup the HA Discovery info
			atomicState.MQTTOnOffDevices++
		}
		atomicState.nameMap = temp
	}
	else log ("[0] switches enabled for MQTT", "TRACE")
	
	MQTTdimmers = (settings?.dimmers)
	if (MQTTdimmers != null){
		log ("["+(MQTTdimmers.size()) +  "] dimmers enabled for MQTT","TRACE")
		temp=atomicState.nameMap
		for (String item : MQTTdimmers) {
   			log ("    MQTT Dimmer Device " + item, "TRACE")
			normName= normalize(item)
			nodes=nodes+normName +','
			temp[normName] = item  //TODO check we dont have duplicate names for two devices ??
	//switchedDim(null, item, MQTTdimmers.currentSwitch[0])
	// Maybe here's a good place to setup the HA Discovery info
	// dimmed(null, item, MQTTdimmers.currentLevel[0])
			atomicState.MQTTDimDevices++
		}
		atomicState.nameMap = temp
	}
	else log ("[0] dimmers enabled for MQTT","TRACE")
	if (nodes.length()>0)    nodes=nodes.substring(0, nodes.length() - 1)
	if (settings?.homiePublish) mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',nodes,1,true,settings?.minHomie)

    //<Casey
	MQTTlocks = (settings?.locks)
	if (MQTTlocks != null) {
		log ("["+(MQTTlocks.size()) +  "] locks enabled for MQTT ", "TRACE")
		def temp = atomicState.nameMap
		for (String item : MQTTlocks) {
   			log ("    MQTT Lock Device " + item, "TRACE")
			normName= normalize(item)
			nodes=nodes+normName +','
			// Build a lookup table for normName to full name
			temp[normName] = item
			atomicState.MQTTLockDevices++
		}
		atomicState.nameMap = temp
	}
	else log ("[0] locks enabled for MQTT", "TRACE")
//Casey>
    
	
	MQTTRGB = (settings?.colour)
	if (MQTTRGB != null){
		log ("["+(MQTTRGB.size()) +  "] colour control devicesl enabled for MQTT","TRACE")
		temp=atomicState.nameMap
		for (String item : MQTTRGB) {
   			log ("    MQTT Colour Control Device " + item, "TRACE")
			normName= normalize(item)
			nodes=nodes+normName +','
			temp[normName] = item  //TODO check we dont have duplicate names for two devices ?? BUG  This is very possible here as same device !!
	// switchedDim(null, item, MQTTRGB.currentSwitch[0])
	// Maybe here's a good place to setup the HA Discovery info
	// dimmed(null, item, MQTTRGB.currentLevel[0])
			atomicState.MQTTRGBc++
		}
		atomicState.nameMap = temp
	}
	else log ("[0] colour control enabled for MQTT","TRACE")
	if (nodes.length()>0)    nodes=nodes.substring(0, nodes.length() - 1)
	if (settings?.homiePublish) mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',nodes,1,true,settings?.minHomie)
	
	MQTTRGB = (settings?.colourT)
	if (MQTTRGB != null){
		log ("["+(MQTTRGB.size()) +  "] colour temperature capable devices enabled for MQTT","TRACE")
		temp=atomicState.nameMap
		for (String item : MQTTRGB) {
   			log ("    MQTT Colour Temp Device " + item, "TRACE")
			normName= normalize(item)
			nodes=nodes+normName +','
			temp[normName] = item  //TODO check we dont have duplicate names for two devices ??
	//switchedDim(null, item, MQTTRGB.currentSwitch[0])
	// Maybe here's a good place to setup the HA Discovery info
	//dimmed(null, item, MQTTRGB.currentLevel[0])
			atomicState.MQTTRGBt++
		}
		atomicState.nameMap = temp
	}
	else log ("[0] colour temp enabled for MQTT","TRACE")
	if (nodes.length()>0)    nodes=nodes.substring(0, nodes.length() - 1)
	if (settings?.homiePublish) mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',nodes,1,true,settings?.minHomie)
    
}

def mqttSubscribes() {  //events from MQTT driver
    
    
    //TODO  Presence Sensors
    
    
    subscribe(mqtt,"MQTTStatus", mqttStatus)
	subscribe(mqtt,"HASynch", synchDevices)
	subscribe(mqtt,"OnOffDev", onoffCapability)
	subscribe(mqtt,"DimDev", dimCapability)
    subscribe(mqtt,"ButtonDev", buttonCapability)
	subscribe(mqtt,"SensorDev", sensorCapability)
    subscribe(mqtt,"LockDev", lockCapability) //Casey
	subscribe(mqtt,"LabelDevice", reNameDev)
	subscribe(mqtt,"HASwitchDev", HASwitchCapability)
	subscribe(mqtt,"HALightDev", HALightCapability)
	subscribe(mqtt,"HASensorDev", HASensorCapability)  //friendly name
    subscribe(mqtt,"HASensorType", HASensorType)  //device_class
	subscribe(mqtt,"HABinarySensorDev", HABinarySensorCapability)
	subscribe(mqtt,"HAInputBooleanDev", HAInputBooleanCapability)
    subscribe(mqtt,"HAPerson", HAPresenceCapability)
	subscribe(mqtt,"HACoverDev", HACoverCapability)
    subscribe(mqtt,"HALockDev", HALockCapability)
    subscribe(mqtt,"HADeviceTrackerDev", HADeviceTrackerCapability)
    subscribe(mqtt,"HAClimateDev", HAClimateCapability)
    subscribe(mqtt,"HAGroupDev", HAGroupCapability)
    subscribe(mqtt,"ShellyDevice",ShellyCapabilities)
    //subscribe(mqtt,"ShellyDimDev",dimCapabilityShelly)
	subscribe(mqtt,"OnOff", onoffEvent)
	subscribe(mqtt,"Dim",dimEvent)
	subscribe(mqtt,"Command",cmdEvent)
	subscribe(mqtt,"Sensor",sensorEvent)
	subscribe(mqtt,"BinarySensor",binarySensorEvent)
	subscribe(mqtt,"SensorUnit",sensorUOM)
    subscribe(mqtt,"Lock", lockEvent) //Casey
	subscribe(mqtt,"Group",groupEvent)
    subscribe(mqtt,"VariableDev",varCapability)
	subscribe(mqtt,"InputBoolean",inputBooleanEvent)
subscribe(mqtt,"person",presenceEvent)
    subscribe (mqtt,"presence", mqttOnline)
	subscribe(mqtt,"Lookup", LookupManual)
	subscribe(mqtt,"SensorDevClass",HABinSensorType)
	subscribe(mqtt,"getTopic", topicPayload)
}


def deviceEventSubscribes() {
    if(modes) subscribe(location, modeEvent)
	subscribe(location, "systemStart", sysStart)
	subscribe(switches, "switch", switched)
	subscribe(dimmers, "level", dimmed)
	subscribe(dimmers, "switch", switchedDim)
	//subscribe(colour, "color", colourDevices)
	subscribe(locks, "lock", locked) //Casey
    
    // adhoc events from driver
	subscribe(adhoc,"OnOff",onoffEvent)
    // TODO CHECK  no dimEvent sub ??
	subscribe(adhoc,"topic", stateTopics)
	subscribe(adhoc,"mapTopic", mapTopics)
	subscribe(adhoc,"changeState",stateChange)
	subscribe(adhoc,"changeLevel",levelChange)
    subscribe(adhoc,"changeText",textChange)
    subscribe (globVars,"variable",varChange)
    subscribe (gVars,"variable",varChange)
}

def sensorSubscribes(count) {   // These are report only - they have no commands
    
    attCount=0  // TODO now not local
    
        count = registerSpecific (motionsensors,count,'motion','sensorDevices')
        count = registerSpecific (contactsensors,count,'contact','sensorDevices')
        count = registerAll (sensors,count,'sensorDevices')
        count = registerSpecific (shocksensors,count,'shock','sensorDevices')
        count = registerSpecific (smokesensors,count,'smoke','sensorDevices')
        count = registerSpecific (presencesensors,count,'presence','sensorDevices')
        count = registerSpecific (humiditysensors,count,'humidity','sensorDevices')
        count = registerSpecific (tempsensors,count,'temperature','sensorDevices')
        count = registerSpecific (batterysensors,count,'battery','sensorDevices')
        count = registerSpecific (carbonmonoxidesensors,count,'carbonmonoxide','sensorDevices')
        count = registerSpecific (voltagesensors,count,'voltage','sensorDevices')
        count = registerSpecific (powersensors,count,'power','sensorDevices')
        count = registerSpecific(watersensors,count,'water','sensorDevices')
        count = registerSpecific (globVars,count,'variable','sensorDevices')
       
    
    
    
    

    return (count)
}

def deviceSubscribes(count) {
        count = registerAll (colour,count,'colourDevices')
        //count = registerSpecific (colour,count,'ColorControl','colourDevices')
        count = registerAll (colourT,count,'colourDevices')
        //count = registerSpecific (colourT,count,'ColorTemperature','colourDevices')
        count = registerAll (thermostats,count,'thermostatDevices')
        count = registerAll (buttonsPush,count,'buttons')
        count = registerAll (alarms,count,'otherDevices')
        count = registerAll (bulbs,count,'otherDevices')
        count = registerAll (chimes,count,'otherDevices')
        count = registerAll (garagedoors,count,'otherDevices')
        count = registerAll (keypads,count,'keypadDevices')
        count = registerAll (outlets,count,'otherDevices')
        count = registerAll (relayswitches,count,'otherDevices')
        count = registerAll (valves,count,'otherDevices')
        count = registerAll (windowshades,count,'otherDevices')

    //date1= new Date()
    //log ("Device subs end ${date1}","INFO")
    atomicState.delay=0
    int i= count/5
	//atomicState.delay =count   //estimate of time/dev > MQTT  // TODO
    estStartup= atomicState.delay + (count/3)
    //log ("Counted ${count} HE  MQTT devices enabled with ${attCount} attributes.  Startup delay (excluding discovery) ~ ${estStartup} seconds", "INFO")
    log ("Counted ${count} HE MQTT device (capabilities) enabled with ${attCount} attributes", "INFO")
	if (settings?.homieDevice) mqtt.setStateVar("homieDevice",settings?.homieDevice)
	count=0
	if (settings?.adhoc!= null)
	{
		log ("["+(settings?.adhoc.size()) +"] manual/adhoc devices enabled for MQTT","INFO")
		atomicState.delay += 1  // TODO tweak check we need this much delay reduced from 10 to 1
		index=0
		for (String item : settings?.adhoc) {
			//atomicState.delay += 1
			pauseExecution(200)  // TODO paces responses - NB sendTopics runs after 10 seconds currently i.e 20 devices - need to tweak
            myType=adhoc[index].currentMqtt
            log ("This device ${item} is of type ${myType}", "DEBUG")
			try {  // This is constructed to recreate attributes in device if they were previously only state variables via update()
                update=false
                value=adhoc[index].currentStateTopic
                    if (value==null) update=true 
                    else  subscribeOneOffTopics(value)
                value=adhoc[index].currentCmdTopic  //why ?
                    if (value==null) update=true    // may not have one - not controllable
                value=adhoc[index].currentStateOFF
                    if (value==null) update=true 
                value=adhoc[index].currentStateON
                    if (value==null) update=true
                
                
                if (adhoc[index].currentMqtt=="dim"){  // and the other attributes for dimmers
                    value=adhoc[index].currentMaxDim
                        if (value==null) update=true 
                    value=adhoc[index].currentLevelTopic
                        if (value==null) update=true  
                    else {
                        adhoc[index].getStateTopics()  // adds the DNI entries - move code to here eventually
                        
                        // There was a delay here see below to make sure getStateTopics completed before the subscribe
                        subscribeOneOffTopics(value)    
                    }
                    value=adhoc[index].currentLevelCmdTopic  // why ?
                        if (value==null) update=true         // may not have one - not controllable 
                }
                
                else if (adhoc[index].currentMqtt=="text"){  // and the other attributes for displayText
                    value=adhoc[index].currentTextTopic
                        if (value==null) update=true  
                    else {
                        
                        // There was a delay here see below 
                        
                        subscribeOneOffTopics(value)
                    }
                    value=adhoc[index].currenttextCmdTopic   // why ?
                        if (value==null) update=true         // may not have one - if not controllable   
                }              
                // adhoc[index].getStateTopics()  // we only need to do this if one of the above is null
                
                
// CURRENTLY THIS (BELOW) IS STILL HANDLED IN getStateTopics() within the drivers - should move into app to make drivers less custom 
// This is also incomplete in the DisplayText driver
/*                
    if (device.currentLevelTopic!=null) 
	{
		if (device.currentStateTopic==null) 
		{	
			stateTopic = device.currentLevelTopic  // substitute state into level
			sendEvent (name: "mapTopic" , value: device, data: [level: device.currentLevelTopic, state: stateTopic, valueMax: device.currentMaxBrightness, stateON: device.currentStateON, stateOFF: device.currentStateOFF])
		}
	else  //have both state and level topics
		{  
			sendEvent(name: "mapTopic", value: device, data: [level: device.currentLevelTopic, state: device.currentStateTopic, valueMax: device.currentMaxBrightness, stateON: device.currentStateON, stateOFF: device.currentStateOFF])
		}
	}
	else if (device.currentStateTopic!=null) 
	{
		if (device.currentLevelTopic==null) 
		{
			levelTopic = device.currentStateTopic  // substitute state into level
			sendEvent(name: "mapTopic", value: device, data: [level: levelTopic, state: device.currentStateTopic, valueMax: device.currentMaxBrightness, stateON: device.currentStateON, stateOFF: device.currentStateOFF])
		}
	}

    //runIn(10, "sendStateTopics")  // TODO
	// this helps avoids incoming MQTT messages before the mappings have completed
	// TODO maybe find a better way of knowing when can safely run - each adhoc device adds 500ms so this only copes with about 20 devices
	// could use a calculated value

*/

                // But we need to build from the same information that getStateTopics() provided which is just a subcribe for onoff
                // Dimmers and text it registers DNI for dim topic (as that is extra) via mapTopic #1186  TODO CHECK
                // In switches it simply subscribes to the state topic (doesnt add a DNI) #1176
           /*
                if (update==true){
                    log.error "############# Upgrading device ${item} to have attributes #############"
                    adhoc[index].upgrade()
                }
            */
                index++
				count++
			}
			catch (e) {
				log ("Device ${item} does not have MQTT (Telnet) virtual capabilities","WARN")
			}

		}
		//atomicState.delay+= count  //TODO tweak  need to keep as int 
	}
	atomicState.adhocDevices=count // settings?.adhoc.size() 
}

def everythingSubscribes(count) {   
    count = registerAll (everything,count)
}


def registerSpecific (devList, count, capability, handlerReq='none'){      //registers handlers for a specific device capability 
     devList.each { sen ->
         //if (capability=='variable') log( "Variable in ${sen} is ${sen.currentVariable}", "INFO")
          sen.capabilities.each { cap ->
              if ("${cap}" == "${capability}") {
                  //log.error "Found $cap and $capability"
                  cap.attributes.each { attr ->
                      log ("$sen Specific Registartion of $cap $attr", "INFO")
                      // lookupHandler(sen,cap.name,attr.name,handlerReq)
                      attCount++
                  }
              }
              else log ("$sen Lost a requested capability $capability $cap", "DEBUG")   // ERROR 
          }
         count++
     }
    return (count)
}


def registerAll (devList,count,handlerReq='none') {  //registers handlers for every capability and attribute a device has
    //  a variable attribute will not get registered as it has no matching capability !
        devList.each { sen ->
          sen.capabilities.each { cap ->
            cap.attributes.each { attr ->
                //subscribe(sen, attr.name, buttons)
                lookupHandler(sen,cap.name,attr.name,handlerReq)
                attCount++
                    log ("$sen subscribing to " + cap.name + "  " + attr.name, "DEBUG")
                // released doubleTapped pushed numberOfButtons held
            }
            //capCount++
	    }
        count++
            
	}
    return (count)
}

def lookupHandler(device,capability,attribute,handlerReq='none')
{
    log ("Need to subscribe to events from ${capability}  ${attribute} using ${handlerReq}", "TRACE")
    
   //if (handlerReq=='none') {
    
   switch(capability) {
   case "SwitchLevel":
	   handler="dimmed"
	   break
   case "Switch":
	   handler="switched"   
       break
   case "Switched":   // TODO This isnt right check dimmer and onoff handling
	   handler="switchedDim"
   case "Light":
       break
   case "Thermostat": 
       handler="thermostatDevices"
       break
   case "ColorControl":
   case "ColorTemperature":
   case "ColorMode":
       handler="colourDevices" 
       break
   case "Lock":
        handler="locked"
		break
   case "HoldableButton":
   case "PushableButton":
   case "DoubleTapableButton":
   case "ReleasableButton":
       handler="buttons" 
       break
   case "Alarm":
   case "Bulb":
   case "Chime":
   case "GarageDoorControl":   
   case "Outlet":   
   case "RelaySwitch":
   case "Valve":
   case "Variable":  // never happens
   case "WaterSensors":
   case "WindowShades":
       handler="otherDevices" 
       break
   case "SecurityKeypad":
       break
   default:
       log ( "Handling ${device} ${capability} ${attribute} with (default) sensor", "DEBUG")
       handler="sensorDevices"
       break

    }
//    }
       if (handlerReq != 'none') {
           if (handlerReq != handler) log ( "Auto Handler Mismatch [${device} ${capability} ${attribute}] ReqHandler:${handlerReq} AutoHandler:${handler}", "DEBUG")
           handler=handlerReq  // give it the requested one for now...
       }
       

/*
	subscribe(location, "systemStart", sysStart)
	subscribe(switches, "switch", switched)
	subscribe(dimmers, "level", dimmed)
	subscribe(dimmers, "switch", switchedDim)
	//subscribe(colour, "color", colourDevices)
	subscribe(locks, "lock", locked) //Casey
    if(modes) subscribe(location, modeEvent)
	subscribe(adhoc,"OnOff",onoffEvent)
    // TODO CHECK  no dimEvent sub ??
	subscribe(adhoc,"topic", stateTopics)
	subscribe(adhoc,"mapTopic", mapTopics)
	subscribe(adhoc,"changeState",stateChange)
	subscribe(adhoc,"changeLevel",levelChange)
    subscribe(adhoc,"changeText",textChange)
*/
    subscribe(device,attribute,handler)
}

def allDevices(evt) {  // dummy handler for now
    log.error "allDevices() was called with ${evt.name}  ${evt.value}  ${evt.displayName}"
}

def wipe() { // TODO  check when this needs to run .. only having null issues because werent initialized at app install	
	atomicState.onoffDevices=[] 
	atomicState.dimDevices=[]
	atomicState.sensorDevices=[]
    atomicState.lockDevices=[]  //Casey
    atomicState.SonoffDevices=[]
    atomicState.ShellyDevices=[]
	atomicState.HASwitchDevices=[]
	atomicState.HALightDevices=[]
	atomicState.HASensorDevices=[]
	atomicState.HABinarySensorDevices=[]
	atomicState.HAInputBooleanDevices=[]
    atomicState.HACoverDevices=[]
    atomicState.HAClimateDevices=[]
    atomicState.HADeviceTrackerDevices=[]
    atomicState.HALockDevices=[]
	atomicState.HAGroupDevices=[]
    atomicState.HAPresenceDevices=[]
    atomicState.buttonDevices=[]
    atomicState.varDevices=[]
	log ("All atomicState devices[] cleared","WARN")
}

def currentMode() {
            if (settings?.HEBasic) mqtt.publishMsg ("Hubitat/${settings?.hubName}/mode","${location.mode}")   
	        if (settings?.homiePublish) {
			    normName = normalize(name) 
			    sTopic=	"homie/${atomicState.normHubName}/hub/mode"
                mqtt.publishMsg (sTopic,"${location.mode}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,settings?.minHomie) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,settings?.minHomie) 
                mqtt.publishMsg (sTopic+'/$settable','true',1,true,settings?.minHomie) 
                mqtt.publishMsg (sTopic+'/$format',"${location.modes}",1,true,settings?.minHomie)
            }
}   
def modeEvent(evt){
	if(evt.name != "mode") return
    if (settings?.HEBasic) mqtt.publishMsg ("Hubitat/${settings?.hubName}/mode","${evt.value}")   
	if (settings?.homiePublish) {
			normName = normalize(name) 
			sTopic=	"homie/${atomicState.normHubName}/hub/mode"
			mqtt.publishMsg (sTopic,evt.value,1,true)
    }
}



def mqttStatus(evt) {
    log("MQTT Status is ${evt.value}","INFO")
    if (evt.value=='Online'){
        log ("MQTT already connected", "INFO")
        atomicState.MQTTconnected=true
    }
        
    else if (evt.value=='Status') {
        log ("MQTT has reconnected, restarting APP", "INFO")
 /*       if (atomicState.aborted) {
            atomicState.aborted=false
            atomicState.abort=false // This should allow any code running in initialize() to run - BUT we need to be sure it aborted first     
        }*/
        atomicState.MQTTconnected=true
        if (!atomicState.startup) {
            log("reStart Requested but I think there's another instance still initializing","WARN")
            log (" Abort is $atomicState.abort ", "WARN")
               // should wait unitil this does abort I think
            runIn(5, "reStart")
        }
        runIn(5, "reStart")
    }
    else {
        log ("MQTT connection error", "ERROR")
        atomicState.MQTTconnected=false
        if (atomicState.restartPending==true){  
            log ("Restart already in progress","WARN")
            //atomicState.abort=true // This should cause any code running in initialize() to abort
            return
        }
        else {
            atomicState.restartPending=true // If this gets set then can't restart so going to set a timed unset 

            atomicState.MQTTconnected=false
            atomicState.abort=true // This should cause any code running in initialize() to abort
            atomicState.count=0 
            log ("Awaiting MQTT reconnect", "ERROR")

            runIn(600, "reStart") // will still retry in 10 minuntes
            if (!atomicState.started) {  // still running initialize()
            while (atomicState.abort) {
                log ("Waiting to abort startup..","WARN")
                pauseExecution(5000)
                }
            }
            log ("Initialize was aborted", "ERROR")
            /*
            unsubscribe()
	        unschedule()
            runIn (60000, "clearRestart")
	        initialize()
            */
        }
    }
    
}

def clearRestart() {
    log ("Force clearing the reset pending flag","ERROR")
    atomicState.restartPending=false
}

def synchDevices(evt) {
    log ("Resynch MQTT device states and HA discovery topics","INFO")
    
    MQTTRGB = (settings?.colour)  //separate as extra values
	if (MQTTRGB != null){
        count=0
		for (String item : MQTTRGB) {
			switchedDim(null, item,"onoff", MQTTRGB.currentSwitch[count])  //?? handle in colourDevices() ??
			dimmed(null, item, "dim", MQTTRGB.currentLevel[count])  //??
			hsv=[MQTTRGB.currentHue[count], MQTTRGB.currentSaturation[count], MQTTRGB.currentLevel[count]]
			colourDevices(null, item, "hsv", hsv)
            try {
                colorName=MQTTRGBT.currentColorName[count]
                log ("Colour Name is ${colorName}","INFO")
                colourDevices(null,item,"colorName",colorName) 
            }
            catch (e) {
			}            
            count++
		}
	}
    MQTTRGBT = (settings?.colourT)  //separate as extra values
	if (MQTTRGBT != null){
        count=0
		for (String item : MQTTRGBT) {
			switchedDim(null, item,"onoff", MQTTRGBT.currentSwitch[count])
			dimmed(null, item, "dim", MQTTRGBT.currentLevel[count])
            hsv=[MQTTRGBT.currentHue[count], MQTTRGBT.currentSaturation[count], MQTTRGBT.currentLevel[count]]
            colourDevices(null,item,"hsv",hsv) // not useful as always #FFFFFF - what does this call provide additionally to MQTTRGB above ?
            colorTemp=MQTTRGBT.currentColorTemperature[count]
            colourDevices(null,item,"colorTemperature",colorTemp) 
            try {
                colorName=MQTTRGBT.currentColorName[count]
                colourDevices(null,item,"colorName",colorName)
            }
            catch (e) {
            }
            try {
                colorMode=MQTTRGBT.currentColorMode[count]
                colourDevices(null,item,"cMode",colorMode)
            }
            catch (e) {
            }
            count++
		}
	}
// This is different because it's publishing all capabailities and attributes out to the Hubitat topic - currently just for reference
// This just adds the capabilities and attributes with CURRENT values to MQTT Hubitat topic - however they are not updated if they change
    loopDev = (settings?.sensors)     
	if (loopDev != null){
			loopDev.each{
			mydName = it.name
			myName = it.displayName
			def attrs = it.supportedAttributes
			if (attrs.size()>1) multiple=true else multiple=false
				attrs.each { attr ->
					def currentState = it.currentState(attr.name)   // what not use currentValue instead TODO ?
					try {
						aValue= currentState.value.toString()
					}
					catch (e) {
				 		aValue='-'
					}
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/attributes/${attr}",aValue)	
				}
				it.capabilities.each { cap ->
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}","-")
					cap.attributes.each { attrib ->
						try {
							def currentState = it.currentState(attrib.name)
							aValue= currentState.value.toString()
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",aValue)
						}
						catch (e) {
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",'-')
						}
					}
				}	
        	}
		}
    // fundamental
    devLoop (settings?.switches,"switch","switched","onoff")    
    devLoop (settings?.dimmers,"level","dimmed","dim") 
    devLoop (settings?.dimmers,"switch","switchedDim","onoff")
    devLoop (settings?.locks,"lock","locked")
    // others
    devLoop (settings?.alarms,"alarm","otherDevices")
    devLoop (settings?.bulbs,"switch","switched","onoff")
    devLoop (settings?.chimes,"chime","otherDevices")
    devLoop (settings?.garageDoors,"garageDoor","otherDevices")
    devLoop (settings?.keypads,"lastCodeName","keypadDevices")
    devLoop (settings?.keypads,"securityKeypad","keypadDevices")
    devLoop (settings?.outlets,"outlet","otherDevices")
    devLoop (settings?.relaySwitches,"relaySwitch","otherDevices")
    devLoop (settings?.valves,"valve","otherDevices")
    devLoop (settings?.waterSensors,"waterSensor","otherDevices")
    devLoop (settings?.globVars,"variable","otherDevices")
    devLoop (settings?.gVars,"variable","otherDevices")
    //buttons
    devLoop (settings?.buttonspush,"numberOfButtons","buttons")
    devLoop (settings?.buttonspush,"pushed","buttons")
    devLoop (settings?.buttonshold,"held","buttons")
    devLoop (settings?.buttonsdtap,"doubleTapped","buttons")
    devLoop (settings?.buttonsrelease,"released","buttons")
    devLoop (settings?.buttons,"button","buttons")  
     //sensors 
    devLoop (settings?.contactsensors,"contact","sensorDevices")
    devLoop (settings?.tempsensors,"temperature","sensorDevices")
    devLoop (settings?.batterysensors,"battery","sensorDevices")
    devLoop (settings?.motionsensors,"motion","sensorDevices")
    devLoop (settings?.humiditysensors,"humidity","sensorDevices")
    devLoop (settings?.smokesensors,"smoke","sensorDevices")
    devLoop (settings?.presencesensors,"presence","sensorDevices")
    devLoop (settings?.powersensors,"power","sensorDevices")
    devLoop (settings?.voltagesensors,"voltage","sensorDevices")
    // thermostats
    devLoop (settings?.thermostats,"heatingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"coolingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatMode","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatFanMode","thermostatDevices")
    devLoop (settings?.thermostats,"supportedThermostatModes","thermostatDevices","thermostatModes")
    devLoop (settings?.thermostats,"supportedNestThermostatModes","thermostatDevices","thermostatModes") 
    devLoop (settings?.thermostats,"supportedThermostatFanModes","thermostatDevices","thermostatFanModes")
    devLoop (settings?.thermostats,"supportedNestThermostatFanModes","thermostatDevices","thermostaFantModes")
    devLoop (settings?.thermostats,"thermostatOperatingState","thermostatDevices")

	
}


def devLoop(deviceList, attribute, handler, type='none'){  // This registers a single 'named' attribute for a device
    if (deviceList != null){
		deviceList.each{
			mydName = it.name
			myName = it.displayName
            if (type == 'none') type=attribute
			def attrs = it.supportedAttributes
			if(it.currentValue(attribute)!=null){
				log ("## " + it.name + " $attribute  ${it.currentValue(attribute)}","DEBUG") // + ${attrs}
				if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here
                log ("#### $attribute sensor #### ${myName} has attributes ${attrs}","TRACE")  // not all are sensors  //log.warn
                
                if(handler=="sensorDevices") sensorDevices(null, myName, type, it.currentValue(attribute),multiple,it.id)
                else if (handler=="thermostatDevices") thermostatDevices(null, myName, type, it.currentValue(attribute),multiple,it.id)
                else if (handler=="switched") switched(null, myName, type, it.currentValue(attribute)) //,multiple,it.id)
                else if (handler=="dimmed") dimmed(null, myName, type, it.currentValue(attribute)) //,multiple,it.id)
                else if (handler=="switchedDim") switchedDim(null, myName, type, it.currentValue(attribute)) //,multiple,it.id)
                else if (handler=="buttons") buttons(null, myName, type, it.currentValue(attribute)) //,multiple,it.id)
                else if (handler=="otherDevices") otherDevices(null, myName, type, it.currentValue(attribute)) //,multiple,it.id)
                else if (handler=="locked") locked(null, myName, type, it.currentValue(attribute)) //,multiple,it.id)
                else if (handler=="keypadDevices") keypadDevices(null, myName, type, it.currentValue(attribute)) //,multiple,it.id)
			}
            
            else log("No [" + attribute + "] attribute value available for [${myName}]", "WARN")
		}
	}
}

def stateTopics(evt) {  // Returns names of all registered state topics for adhoc devices
	log ("Got topic ${evt.value}","DEBUG")
	subscribeOneOffTopics(evt.value)
}
    
def mqttOnline(evt) {
       if (evt.value=="present") atomicState.MQTTconnected=true
       else atomicState.MQTTconnected=false      
}

def mapTopics(evt) {  	
						//data.stateON and data.stateOFF available here too - (if defined in device)
						//if there is no onoff state topic for the device then it will be created with the dim name and the map will have the same entry so lookup still works
	//log ( "###################### "+evt.value+" ######################", "ERROR")
	def tempMap=atomicState.topicMap
	def content=[:]
	def data = parseJson(evt.data)
	log ("Topic mapped key " + data.level + " to " + data.state + " with " + data.valueMax, "DEBUG")
	if (data.valueMax!=null) valueMax=data.valueMax else valueMax='?'
	if (data.stateON!=null) valueON=data.stateON else valueON='?'
	if (data.stateOFF!=null) valueOFF=data.stateOFF else valueON='?'		
	content=[topic: data.state, maxLevel: valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "dim"]
	tempMap[data.level]=content
	content=[topic: data.state, maxLevel: valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "onoff"]
	tempMap[data.state]=content   // this creates an entry for the switch part of a dimmer so states are available
	atomicState.topicMap = tempMap
		for (e in tempMap) {
    		//log ( "[topic]: key = ${e.key}, value = ${e.value}","ERROR")
		}
}

def stateChange(evt) {  // for a manual adhoc device  // TODO these next three are identical !
	def data = parseJson(evt.data)
			index=0
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index, "TRACE")
				mqtt.publishMsg (data.topic,evt.value,1,true)
            }
			index++
	}
}

def levelChange(evt) {  // for a manual adhoc device
	def data = parseJson(evt.data)
			index=0  
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index,"TRACE")
				mqtt.publishMsg (data.dimTopic,evt.value,1,true)  
				}
			index++
	}
}
def textChange(evt) {  // for a manual adhoc device
    def data = parseJson(evt.data)
			index=0
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index, "TRACE")
				mqtt.publishMsg (data.topic,evt.value,1,true)  
				}
			index++
	}
}

def varChange(evt) {  // for an enabled Omni Device with variable attribute (globalVars)

			index=0
			for (String item : settings?.globVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
    	    index=0
			for (String item : settings?.gVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
}

private logDebug(msg) {
	if (settings?.debugOutput || settings?.debugOutput == null) {
		log ("$msg", "DEBUG")
	}
}

private determineLogLevel(data) {

    switch (data?.toUpperCase()) {
        case "TRACE":
            return 0
            break
        case "DEBUG":
            return 1
            break
        case "INFO":
            return 2
            break
        case "WARN":
            return 3
            break
        case "ERROR":
        	return 4
            break
		case "DISABLED":
		    return 5
			break
        default:
            return 1
    }
}

def topicPayload(evt) {	
	if (evt.value!='#NoNe#'){
		mqtt.ack()
		log ('Acknowledge $property exists',"TRACE")
	}
	if (atomicState.Category=='') {
		log ("Blank category","DEBUG")
		return
	}
	def data = parseJson(evt.data)	
	if (data.state.contains(atomicState.Category)){
		log ("${atomicState.Category}  already exists in ${data.state}","DEBUG")
		return
	}

	log  ("RX:  ${evt.value}  /  ${data.state[]}  /  ${data.topic}  +  ${atomicState.Category}","DEBUG") 
	if (evt.value=="#NoNe#") first='' else first=","
	mqtt.publishMsg (data.topic, data.state.join(",") + first + atomicState.Category,1,true,settings?.minHomie)
	log ("Publishing to ${data.topic} payload is ${data.state.join(",") + first + atomicState.Category}","DEBUG")
	atomicState.Category=''	
}


def HADiscoveryAdvertise (name, type="none", category="none", payON="true",payOFF="false",nameSuffix='',UOM='',id=0) {  // payON and payOFF vary a lot for sensors so need extra params) {
    if (!settings?.HADiscovery) return   // && HAtype!='?')
	normName = normalize(name+nameSuffix) 
	log ("Advertising ${name} device ${type}  ${category} to HA","TRACE")
	if (atomicState.nameMap.containsValue(name)) log ("Found in nameMap" + name, "DEBUG") else log ("NOT Found in nameMap" + name, "DEBUG")
		sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'   //TODO tidy
		sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		sColorTopic="homie/${atomicState.normHubName}/${normName}"+'/color'
        sLockTopic="homie/${atomicState.normHubName}/${normName}"+'/lock'  //Casey
		sSensTopic="homie/${atomicState.normHubName}/${normalize(name)}"  // the suffix is not used here

		pName = '"name":"'+name+nameSuffix+'"'
		pUID = ',"unique_id":"Hubitat-MQTT:_' + normName + '"'
		pDevClass=''
		payload=''
        pID=''
    String ID = "${id}"
    if (ID != '0') {
//        pID= ',"device": {"identifiers": ["test'+ ID + '"],"name": "Contact Sensor ' + '"}'  // TODO Investigate if this can work
        log ("pID is " + pID , "DEBUG")
    }

  
    
		pON = ',"payload_on":"true"'  //default for booleans in homie
		pOFF = ',"payload_off":"false"'
		if (type=="switch"|type=="light") {
			pState = ',"state_topic":"'+ sTopic + '"'
			pCmd = ',"command_topic":"'+ sTopic + '/set"'
			pUOM = ''
			//pON = ',"payload_on":"'+payON+'"'   // Is this ever needed ?
			//pOFF = ',"payload_off":"'+payOFF+'"'
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="switch") payload='{'+pName+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+'}'
			if (type=="light") {
				pOnType = ',"on_command_type":"first"'
				pBriState = ',"brightness_state_topic":"' + sDimTopic + '"'
				pBriCmd = ',"brightness_command_topic":"' + sDimTopic + '/set"'
				pBriTemp= ',"brightness_value_template":"{{ value }}"'
				pBriScale = ',"brightness_scale":100'
				if (category=="colour") {
					pColState = ',"color_temp_state_topic": "' + sColorTopic + '-temperature/temp"'
					pColTempCmd = ',"color_temp_command_topic": "' + sColorTopic + '-temperature/set"'
					pColTempVal = ',"color_temp_value_template": "{{ ((value | float / 100) * (500 - 153)) + 153  }}"'
					//pHSState = ',"hs_state_topic": "' + sColorTopic + '/hsv"'
                    pHSState = ',"hs_state_topic": "' + sColorTopic +'"'
					pHSCmd = ',"hs_command_topic": "' + sColorTopic + '/set"'
					//pHSValTemp = ',"hs_value_template": "{{ value_json.h }},{{ value_json.s }}"'
                    pHSValTemp = ',"hs_value_template":"' + "{{value.split(',')[0]}},{{value.split(',')[1]}}" + '"'
					HAtype="light"  // for discovery
					payload='{'+pName+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pColState+pColTempCmd+pColTempVal+pHSState+pHSCmd+pHSValTemp+pID+'}'
				}
				else payload='{'+pName+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pID+'}'
			}
		}	
		else if (type=="binary_sensor" | type=="sensor") {
			 // TODO Look at why this is different to above and combine if poss
			sTopic=sSensTopic+'/'+category
			//pName = '"name":"'+name+'"'
			//pON = ',"payload_on":"'+payON+'"'  // Is this ever needed
			//pOFF = ',"payload_off":"'+payOFF+'"'
			//pDevClass=''
			pState = ',"state_topic":"'+ sTopic + '"'
		
			//if (UOM!='') pUOM = ',"unit_of_measurement":"'+UOM+'"' else pUOM=''
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="binary_sensor") {
				// HA categories for various binary sensors https://www.home-assistant.io/components/binary_sensor/
				// TODO must map binary_sensor payload values to ON OFF
				if (category == "motion") pDevClass = ',"device_class": "motion"'
				else if (category == "contact") {
					pDevClass = ',"device_class": "opening"'  
					//pState = ',"state_topic":"'+ sTopic + '/status"'  // Here we are electing between onoff boolean and the status name e.g active/inactive. Using true:false as HA templates value anyway
				}
				else if (category == "smoke-alarm") pDevClass = ',"device_class": "smoke"'
				else if (category == "carbonMonoxide-alarm") pDevClass = ',"device_class": "gas"'
                else if (category == "presence-sensor") pDevClass = ',"device_class": "presence"'
				else if (category == "water") pDevClass = ',"device_class": "water"'	
				//else if (category == "battery") pDevClass = ',"device_class": "battery"'  // LOW/OK indicator, perhaps set if < 10%
				//pON = ',"payload_on":"'+payON+'"'  //TODO check if this is ever needed for boolean sensors - will be for enum
				//pOFF = ',"payload_off":"'+payOFF+'"'   //TODO need a selector here
				pUOM=''
			}
/*
			else {
				sTopic= "homie/louey/weatherview-sky/measure-wind-angle"
				pState = ',"state_topic":"'+ sTopic + '"'
				if (payON!='true') pUOM = ',"unit_of_measurement":"'+payON+'"' else pUOM=''
				pON = ""
				pOFF = ""
			}
*/
			if (type=="sensor") {
				pUOM=',"unit_of_measurement": "'+UOM+'"'
				pON=''  // remove on:off states from sensor adverts ? Do I need to be more selective say with some (analogue?) 'sensors' that might also have an on:off state ? TODO check
				pOFF=''
				if (category == "measure-temperature")  { 
				//pDevClass = ',"device_class": "temperature"'
				// if (tempUnits=="Celsius x.x째C")	pValTemp = ',"value_template":"{{ value | round(1) }}"' 
				}
			}
				
			payload='{'+pName+pUID+pDevClass+pState+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pID+'}' 
			
		}
    //Casey <
        else if (type=="lock") {
			pState = ',"state_topic":"'+ sLockTopic + '"'
			pCmd = ',"command_topic":"'+ sLockTopic + '/set"'
    		pLOCK = ',"payload_lock":"true"'  //default for booleans in homie
	    	pUNLOCK = ',"payload_unlock":"false"'
			pUOM = ''
			pIcon = '' // ',"icon":"mdi:lock"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			payload='{'+pName+pUID+pState+pCmd+pUOM+pLOCK+pUNLOCK+pIcon+pDev+pValTemp+'}'
        }
        //Casey >
/*    
        else if (type=="button") {  // TODO complete
			pState = ',"state_topic":"'+ sLockTopic + '"'
			pCmd = ',"command_topic":"'+ sLockTopic + '/set"'
    		pLOCK = ',"payload_lock":"true"'  //default for booleans in homie
	    	pUNLOCK = ',"payload_unlock":"false"'
			pUOM = ''
			pIcon = '' // ',"icon":"mdi:lock"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			payload='{'+pName+pUID+pState+pCmd+pUOM+pLOCK+pUNLOCK+pIcon+pDev+pValTemp+'}'
        }
*/           
            
            
            
            
 
		//if (!atomicState.started) //TODO BUG Can't limit this here as these happen adhoc after startup unless can force early state synch on startup
		// will see what results if we repeatedly send them - maybe OK as send only
		// Was OK for sensors but RGB bulbs wont be - got mismatch of level/state - will need to send just once so need state synch
		//if (!atomicState.started && payload.size()>1 )// shouldnt need this anymore although I see sesnors keep sensing when activated 
		if (payload.size()>1 ){  // shouldnt need this anymore although I see sesnors keep sensing when activated 
	    //if (payload.size()>1 ) {
			log ("Sending Discovery: message "+ name + " "  + payload, "TRACE") 
			if (settings?.HARemember=="Remember") mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/${normName}/config", payload.toString(),1,true)
			else mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/${normName}/config", payload)
		}
   		atomicState.lastDevice=name  // kludge atm to pair up separate events arriving here for hue and sat - there's another way too (see above)
	
}	

def log(data, type) {
	data = "MQTT: ${data ?: ''}"
    if (determineLogLevel(type) >= determineLogLevel(settings?.logging ?: "INFO")) {
        switch (type?.toUpperCase()) {
            case "TRACE":
                log.trace "${data}"
                break
            case "DEBUG":
                log.debug "${data}"
                break
            case "INFO":
                log.info "${data}"
                break
            case "WARN":
                log.warn "${data}"
                break
            case "ERROR":
                log.error "${data}"
                break
			case "DISABLED":
			    break
            default:
                log.error "MQTT: -- ${device.label} -- Invalid Log Setting"
        }
    }
}

private removeAllChildDevices() {   
	getChildDevices().each {deleteChildDevice(it.deviceNetworkId)}
	log ("Deleted all child devices", "WARN")
}

//#######################################################################################################################################
//#######################################   This section handles subscriptions to MQTT topics   #########################################
//#######################################################################################################################################


def subscribeShellyTopic() {
	log ("Adding Shelly status topics","INFO") //
	//mqtt.subscribeTopic('shellies/#')
    mqtt.subscribeTopic('shellies/+/onlineRet') // /online  is no use here as is not a retained or updated topic used in LWT (bug in Shelly)
}
def subscribeSonoffTopic() {
	log ("Adding Sonoff property and node subscription topics [Not Yet implemented]","INFO")
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
}

def subscribeHomieTopic() {
	log ("Adding homie property and node subscription topics for " + atomicState.homie, "INFO")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$properties')
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$type')      //TODO from here could get a device > type list as this returns all devices with a type
}

def subscribeHomieStateTopics() {
	log ("Adding homie onoff & dim events subscription topics ", "INFO")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/onoff')
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim')
	// how to add sensors ??	looks like individually				//mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$type') already above
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/sensorname')	// TODO this is no good for sensors as each topic is named differently and need $type=sensor
    mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')    // This will return sensors that have units from which we could grab sensor name and build tree - and subscribe to enabled devices
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/+')		// need to check for $sensor and then enable whole tree or read $properties and enable individually or use $type above
	// too much returned by above
	// maybe add sensor name from enabled devices ??    			// how do we determine its a sensor value for a random incoming MQTT message......?
																	// need to know either via $sensor or name ??
																	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$properties')    // already subscribed above
																	// multiple sensor names but have count at least, sensor values are not dependably retained on MQTT
	
}

def subscribeHomieNameTopics() {
	log ("Adding homie name subscription topics ", "INFO")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$name')
}

def subscribeHADevices() {  // ToDo - these might benefit from pacing
	log ("Adding HA switches, lights and sensors friendly names topics ", "INFO")
	mqtt.subscribeTopic(atomicState.HA+'/switch/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this creates device
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/device_class') // // this creates device
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// this creates device
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/lock/+/friendly_name')
        
    // Currently not discovering these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/friendly_name')
}

def subscribeHADeviceEvents() {// This runs 10 secs after above currently

	log ("Adding HA switch, sensor, and light events topics", "INFO")
	mqtt.subscribeTopic(atomicState.HA+'/switch/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/brightness')
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this also creates device if device_class was missing
	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/state')// TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')// TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/state') // TODO spread /delay a bit
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// TODO spread /delay a bit  // moved above as this creates device
	mqtt.subscribeTopic(atomicState.HA+'/group/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/current_position')
    
    // Currently not handling state updates for these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/climate/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/lock/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/state')

}

    def subscribeOneOffTopics(topic) {
	mqtt.subscribeTopic(topic)
}

//#######################################################################################################################################
//##############################   This section takes internal events/state changes and updates the devices  ###############################
//##############################   It also publishes discovery topics using the  HA MQTT discovery protocol  ###############################
//#######################################################################################################################################

def switched(evt, name=null, type=null, state=null) {
   
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
		log(" Device is switched ${state}  ${name} ${xName}", "DEBUG")
	}   
	else 
	{
		xName=name
		log(" Device (synch) is switched ${state}  ${name} ${xName}", "DEBUG")
	}
	if (settings?.HEBasic)
		{
				mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/onoff","${state}") // basic MQTT status
		}
	if (settings?.homiePublish) {
			normName = normalize(name) 
			if (state=="on") nState = "true" else nState = "false"    //TODO make flexible
			sTopic=	"homie/${atomicState.normHubName}/${normName}"
		
			//================  Limited homie spec implemenation ================
            addProperty(sTopic,"onoff")
			//mqtt.publishMsg (sTopic+'/$properties',"onoff",1,true)  // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name,1,true)   
			mqtt.publishMsg (sTopic+'/$type',"socket",1,true,settings?.minHomie)  
			mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,settings?.minHomie) 
			mqtt.publishMsg (sTopic+'/onoff/$name',name,1,true,settings?.minHomie) 
			mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'
			mqtt.publishMsg (sTopic,nState,1,settings?.homieStatesPersist) 
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
		if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"switch","none")	
		}
		else if (settings?.HADiscovery) log ("HADiscovery switched discarded for ${name}","DEBUG")
}

def switchedDim(evt, name=null, type=null, state=null, devType=null) {
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
		log("Device is SwitchedDim ${state}  ${name} ${xName}", "DEBUG")
	} 
	else 
	{
        xName=name
		log("Device (synch) switchedDim ${state}  ${name} ${xName}", "DEBUG")
	}
		if (settings?.HEBasic)
		{
				mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/onoff","${state.toString()}") // basic MQTT status  TODO persistence ?
		}

		if (settings?.homiePublish) {
			normName = normalize(name)
            sTopic=	"homie/${atomicState.normHubName}/${normName}"
			if (state=="on") nState = "true" else nState = "false"  // TODO customisable
			addProperty(sTopic,"onoff")
            addProperty(sTopic,"dim")
		
			//================ homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)   // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			mqtt.publishMsg (sTopic+'/$type',"light",1,true,settings?.minHomie)  
			mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,settings?.minHomie)   
			mqtt.publishMsg (sTopic+'/onoff/$name',name.toString(),1,true,settings?.minHomie)  
			mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/onoff',nState.toString(),1,settings?.homieStatesPersist)
			//log ("Updated homie/${atomicState.normHubName}/${normName}/onoff to ${nState.toString()}", "ERROR")   // only for log visibility
			//===========================================================
		}
	if (settings?.HADiscovery){
		if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"switch","none")
		}
		else if (settings?.HADiscovery) log ("HADiscovery switchedDim discarded for ${name}","DEBUG")
	}
}

def dimmed(evt, name=null, type=null, state=null) {
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
		log ("Device dimmed ${state}  ${name}", "DEBUG")
	} 
	else {
		xName=name
		log ("Device (synch) dimmed ${state}  ${name}", "DEBUG")
	}
	if (settings?.HEBasic) {
		mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/dim","${state}")
	}
	
	if (settings?.homiePublish) {
    	normName = normalize(name) 
		//================  Limited homie spec implemenation ================
		sTopic="homie/${atomicState.normHubName}/${normName}"
		sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		mqtt.publishMsg (sDimTopic,"${state}",1,true)
		//log ("Updated ${sDimTopic} to ${state}", "ERROR")   // only for log visibility
        addProperty(sTopic,'onoff')
        addProperty(sTopic,'dim')
        //sTopic=sTopic+'/onoff'
		//mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)  // limited homie implementation
		mqtt.publishMsg (sTopic+'/$name',"${name}",1,true)  
		mqtt.publishMsg (sTopic+'/$type',"light",1,true,settings?.minHomie)   
		mqtt.publishMsg (sTopic+'/dim/$settable',"true",1,true,settings?.minHomie)  
		mqtt.publishMsg (sTopic+'/dim/$name',"${name}",1,true,settings?.minHomie) 
		mqtt.publishMsg (sTopic+'/dim/$datatype',"integer",1,true,settings?.minHomie)
		mqtt.publishMsg (sTopic+'/dim/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
		mqtt.publishMsg (sTopic+'/dim/$format',"0:100",1,true,settings?.minHomie)
		//===================================================================
	}
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"light","none")
	}
	else if (settings?.HADiscovery) log ("HADiscovery dimmed discarded for ${name}","DEBUG")
}


//Casey <
def locked(evt, name=null, type=null, state=null) {
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
		log(" Device is locked ${state}  ${name} ${xName}", "DEBUG")
	}
	else
	{
		xName=name
		log(" Device (synch) is locked ${state}  ${name} ${xName}", "DEBUG")
	}
	if (settings?.HEBasic)
		{
				mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/lock","${state}") // basic MQTT status
		}
	if (settings?.homiePublish) {
		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        addProperty(sTopic,'lock')
			if (state=="locked") nState = "true" else nState = "false"    //TODO make flexible

			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',"lock",1,true)  // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name,1,true)
			mqtt.publishMsg (sTopic+'/$type',"socket",1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/lock/$settable',"true",1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/lock/$name',name,1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/lock/$datatype',"boolean",1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/lock/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			sTopic="homie/${atomicState.normHubName}/${normName}"+'/lock'
			mqtt.publishMsg (sTopic,nState,1,settings?.homieStatesPersist)
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"lock","none")
    } else {
        log ("Locked event is NOT null for ${name}","INFO")
    }
}
//Casey >


def buttons(evt, name=null, type=null, state=null) {
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name.toLowerCase()
	}
	else
	{
		xName=name
        log(" Device (synch) is ${state}  ${name} ${xName} ${type}", "DEBUG") 

	}
	if (settings?.HEBasic)
		{
            //mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/${xName}","${state}") // basic MQTT status
            mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/${type}","${state}") // basic MQTT status
		}
	if (settings?.homiePublish) {
		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        addProperty(sTopic,'button')
            // mqtt.publishMsg (sTopic+'/button/'+"${xName}","${state}",1,true)
        
            mqtt.publishMsg (sTopic+'/button/'+"${normalize(type)}","${state}",1,true)
			if (state=="4") nState = "true" else nState = "false"    //TODO make flexible

			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',"lock",1,true)  // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name,1,true)
			mqtt.publishMsg (sTopic+'/$type',"button",1,true,settings?.minHomie)
        
			mqtt.publishMsg (sTopic+'/button/$settable',"false",1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/button/$name',name,1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/button/$datatype',"integer",1,true,settings?.minHomie)
            mqtt.publishMsg (sTopic+'/button/$format',"0:100",1,true,settings?.minHomie)
			mqtt.publishMsg (sTopic+'/button/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			sTopic="homie/${atomicState.normHubName}/${normName}"+'/button'
        mqtt.publishMsg (sTopic,"${state}",1,settings?.homieStatesPersist)
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"button","none")
    } else {
        log ("Button event is NOT null for ${name}","INFO")
    }
}






/*
def thermostat() {  // TODO Remove from sensors below and place here
    
}
*/
def thermostatDevices(evt, name=null, type=null, state=null, multiple=false, id=0) { 
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // this is the attribute name
		log ("This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("thermostatDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("thermostatDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
		if (settings?.HEBasic) {
			mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/${xType}","${state.toString()}")
		}
		HAtype='unknown'
		UOM=''
    	if (settings?.homiePublish) {  //TODO use case rather than if else if
		    sTopic="homie/${atomicState.normHubName}/${normName}"
            if (xType=='temperature'){
				category='measure-temperature'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,settings?.minHomie)
				HAtype="sensor"
			}
			else if (xType=="heatingSetpoint"){  //TODO combine above
				category='heating-setpoint'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,settings?.minHomie)
                mqtt.publishMsg (sTopic+'/'+category+'/$settable',"true",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,settings?.minHomie)
				HAtype="sensor"
			}
            else if (xType=="coolingSetpoint"){  //TODO combine above
				category='cooling-setpoint'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,settings?.minHomie)
				HAtype="sensor"
			}
            else if (xType=="thermostatMode"){  //TODO combine above
				category='mode'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,settings?.minHomie)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				HAtype="sensor"    
			}
            else if (xType=="thermostatModes"){  //TODO combine above
				category='mode'
                settable="true"
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)
                
                // regex to strip leading [ and trailing ] and ,_ change to ,
   
                //choices=choices.replaceAll(", ", ',')
 
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,settings?.minHomie)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                mqtt.publishMsg (sTopic+'/'+"state"+'/$format',"${state.toString()},idle",1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                state=null
				HAtype="sensor"
			}
            else if (xType=="thermostatOperatingState"){  //TODO combine above
				category='state'
                settable="false"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,settings?.minHomie)

                //mqtt.publishMsg (sTopic+'/'+category+'/state',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				HAtype="sensor"
            }        
            else if (xType=="thermostatFanMode"){  //TODO combine above
				category='fanmode'
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,settings?.minHomie)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				HAtype="sensor"
			}
            else if (xType=="thermostatFanModes"){
                category='fanmode'
                settable="true"
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)
                
                // regex to strip leading [ and trailing ] and ,_ change to ,
               //string=string.replaceAll("^\[|, |]$", ',')
                //choices=choices.replaceAll(", ", ',')
 
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,settings?.minHomie)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                //mqtt.publishMsg (sTopic+'/'+"state"+'/$format',"${state.toString()},idle",1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                state=null
				HAtype="sensor"     
            } 
			
            else {
				category = 'unknown'
				log ("t Unknown category for type ${xType} reported by device ${name}","WARN")
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
            addProperty(sTopic,category)
          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"thermostat",1,true,settings?.minHomie) 
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,settings?.minHomie)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,settings?.minHomie)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                if (state!=null) {
                    if(tempUnits=="Celsius x.x째C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }
			    //log ("Updated " +sTopic+'/'+ category + " to ${nState.toString()}", "ERROR")   // only for log visibility
	
	// payON and payOFF vary a lot for sensors so need extra params
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,nameSuffix,UOM,id)  // these are created as sub topics
		}
		//else HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,sTopic+'/'+category,UOM)  // will only be called once
		else  HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,'',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery thermostat discarded for ${name}","DEBUG")
	
	//TODO Do I need to publish HA Discovery before or after homie state topics - if they are not retained ??  Check with all these

        }
}

def keypadDevices(evt, name=null, type=null, state=null, multiple=false, id=0) { // subs must be used in HA discovery as device must be separated into multiple entities
 	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // this is the attribute name
		log ("keypadDevices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("keypadDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","WARN")
	}
    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("otherDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
        //######  Hubitat ######
		if (settings?.HEBasic) {
			mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/${xType}","${state.toString()}")
		}
		HAtype='unknown'
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"
            if (xType=='lastCodeName'){  
				category='lastuser'        
            }
            else if (xType=='securityKeypad'){  //TODO
				category='securitymode'
                settable="true"
            }           
		    else if (xType=='motion'){  //TODO
				category='motion'       
            }
            else if (xType=='alarm'){  //TODO
				category='alarm'
            }
            else if (xType=='temperature'){  //TODO
				category='measure-temperature'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"real",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','째C',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-273:999',1,true,settings?.minHomie)
				UOM="degrees"
				HAtype="sensor"
			}
        }
        
        
        
			else {
				category = 'unknown'
				log ("k Unknown Category for type ${xType} reported by device ${name}","ERROR")
			}
        
        //   ####### homie #######
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	//atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	//pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	//mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
                addProperty(sTopic,category)
    
        if (xType=='securityKeypad'){
                settable='true'
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,settings?.minHomie)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[<code>,disarmed,armed home,armed away,armed night]',1,true,settings?.minHomie)
        }
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"keypad",1,true,settings?.minHomie) 
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,settings?.minHomie)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,settings?.minHomie)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                if (state!=null) {
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }
			    //log ("Updated " +sTopic+'/'+ category + " to ${nState.toString()}", "ERROR")   // only for log visibility
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
/*
if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,nameSuffix,UOM,id)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,'',UOM)  // will only be called once
*/
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
	
	//TODO Do I need to publish HA Discovery before or after homie state topics - if they are not retained ??  Check with all these
   
    
    
    
    
}
    
def otherDevices(evt, name=null, type=null, state=null, multiple=false, id=0) {  // subs must be used in HA discovery as device must be separated into multiple entities 
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // this is the attribute name
		log ("otherDevices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "WARN")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("otherDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","WARN")
	}
    
	    dType="sensor"
        normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("otherDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
        //######  Hubitat ######
		if (settings?.HEBasic) {
            if (xType=='variable')  mqtt.publishMsg ("Hubitat/${settings?.hubName}/Variables/${name}","${state.toString()}")
			else mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/${xType}","${state.toString()}")
		}
		HAtype='unknown'
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"
            
			if (xType=='motion'){  //TODO
				category='motion'
        
            }
           if (xType=='alarm'){  //TODO
				category='alarm'
        
            }
            if (xType=='variable'){  
				category='variable'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,settings?.minHomie)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
         
        
            }
            else if (xType=='voltage'){  //TODO
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,settings?.minHomie)
				UOM="volts"
				HAtype="sensor"
			}
        }
        
        
        
			else {
				category = 'unknown'
				log ("o Unknown Category for type ${xType} reported by device ${name}","ERROR")
			}
        
        //   ####### homie #######
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	//atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	//pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	//mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
    addProperty(sTopic,category)
          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',dType,1,true,settings?.minHomie) 
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,settings?.minHomie)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,settings?.minHomie)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,settings?.minHomie)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,settings?.minHomie)
                if (state!=null) {
                    if(tempUnits=="Celsius x.x째C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  //                          <<<<<   This publishes the actual event value
                }
			    //log ("Updated " +sTopic+'/'+ category + " to ${nState.toString()}", "ERROR")   // only for log visibility
	
	// payON and payOFF vary a lot for sensors so need extra params
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,nameSuffix,UOM,id)  // these are created as sub topics
		}
		//else HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,sTopic+'/'+category,UOM)  // will only be called once
		else  HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,'',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
	
	//TODO Do I need to publish HA Discovery before or after homie state topics - if they are not retained ??  Check with all these

    }   
   
    
    

def sensorDevices(evt, name=null, type=null, state=null, multiple=false, id=0) {  // subs must be used in HA discovery as device must be separated into multiple entities


	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xType=evt.name  // this is the attribute name
		log ("This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("sensorDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("sensorDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
		if (settings?.HEBasic) {
			mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/${xType}","${state.toString()}")
		}
		HAtype='unknown'
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"
            
			if (xType=='motion'){
				category='motion'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,settings?.minHomie)
				HAtype="binary_sensor"
				payON="active"
				payOFF="inactive"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,settings?.minHomie)
					state='true'  // Need to choose between boolean and enum
				}
				else if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,settings?.minHomie)
					state='false'  // Need to choose between boolean and enum
				}
			}
            
           else if (xType=='push'){  // don't think this can this ever run 
               log ("Button push event running in sensors", "ERROR")
				category='button'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,settings?.minHomie)

				HAtype="button"
			}
            
            
            
            
			else if (xType=='contact'){
				category='contact'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,settings?.minHomie)  // Need to choose between boolean and enum
				HAtype="binary_sensor"
				payON="open"
				payOFF="closed"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,settings?.minHomie)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,settings?.minHomie)
					state='false'  // Need to choose between boolean and enum
				}
			}
			else if (xType=='temperature'){
				category='measure-temperature'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if (tempUnits=="Fahrenheit 째F") UOM="째F" else UOM="째C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,settings?.minHomie)
				HAtype="sensor"
			}
          
 			else if (xType=='humidity'){
				category='measure-humidity'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,settings?.minHomie)
				UOM="%"
				HAtype="sensor"
			}
			else if (xType=='battery'){
				category='measure-battery'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,settings?.minHomie)
				UOM="%"
				HAtype="sensor"
			}
			else if (xType=='energy'){
				category='measure-energy'   // value and unit enum KWh
				UOM="watts"
			}
			else if (xType=='illuminance'){
				category='measure-light'   // value and unit enum lux
			}
			else if (xType=='smoke'){
				category='smoke-alarm'  //enum clear|detected|tested
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,settings?.minHomie)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,settings?.minHomie)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,settings?.minHomie)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
            else if (xType=='presence'){
				category='presence-sensor'  //enum home|away
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,settings?.minHomie)
				HAtype="binary_sensor"
				payON="present"
				payOFF="not present"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,settings?.minHomie)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,settings?.minHomie)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='carbonMonoxide'){
				category='carbonMonoxide-alarm'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,settings?.minHomie)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,settings?.minHomie)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,settings?.minHomie)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='sound'){
				category='sound-level'   // detected|not detected
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','dB',1,true,settings?.minHomie)
				UOM="dB"
				HAtype="sensor"
			}
			else if (xType=='voltage'){
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,settings?.minHomie)
				UOM="volts"
				HAtype="sensor"
			}
			else if (xType=='power'){  // TODO is it this or 'energy' above ?
				category='measure-power'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,settings?.minHomie)
				UOM="watts"
				HAtype="sensor"
			}
			else if (xType=='water'){
				category='water'
				HAtype="binary_sensor"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,settings?.minHomie)
				payON="wet"
				payOFF="dry"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,settings?.minHomie)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,settings?.minHomie)
					state='false'  // Need to choose between boolean and enum
				}
			}
            else if (xType=="securityKeypad"){
                log ("securityKeypad ${name} reported ${state} in sensors","WARN")
                 }
			else {
				category = 'unknown'
				log ("s Unknown Category for type ${xType} reported by device ${name}","ERROR")
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	//atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	//pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	//mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
    addProperty(sTopic,category)
          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"sensor",1,true,settings?.minHomie)
                if (category=='unknown')
            { mqtt.publishMsg (sTopic+'/'+category+'/'+xType,state.toString(),1,true) }
            else{
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,settings?.minHomie)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,settings?.minHomie)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,settings?.minHomie)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                if (state!=null) {
                    if(tempUnits=="Celsius x.x째C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }
			    //log ("Updated " +sTopic+'/'+ category + " to ${nState.toString()}", "ERROR")   // only for log visibility
	
	// payON and payOFF vary a lot for sensors so need extra params
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,nameSuffix,UOM,id)  // these are created as sub topics
		}
		//else HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,sTopic+'/'+category,UOM)  // will only be called once
		else  HADiscoveryAdvertise(name,HAtype,category,payON,payOFF,'',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
        }
	//TODO Do I need to publish HA Discovery before or after homie state topics - if they are not retained ??  Check with all these
    }
}
//def dimmed(evt, name=null, type=null, state=null)
def colourDevices(evt, name=null,type=null, state=null) {	
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
		xType=evt.name  // this is the attribute name
		log ("Got a colour event " + evt.name + " " + evt.value, "DEBUG") 
	} 
	else {
		xName=name
		xType=type
		log ("Got a colour synch " + xName + " " + type + " " + state, "DEBUG") 
	}
	
	normName = normalize(name)
	normxName = normalize(xName) 
	if (settings?.HEBasic) {
		mqtt.publishMsg ("Hubitat/${settings?.hubName}/${name}/${xType}","${state.toString()}")  // TODO This is generalised needs tweaking
	}
	if (settings?.homiePublish) {  //TODO case rather than if
		sTopic="homie/${atomicState.normHubName}/${normName}"
		category='unknown'
		// TODO
		// colorName
		// RGB
		// color
		 
		// with colour temperature capability
		//color
		//colorName
		//colorTemperature
		//RGB
        
        if (xType=='rgbInit'){
                //mqtt.publishMsg (sTopic+'/'+category+'/hsv','right place',1,true,settings?.minHomie)
            }

            
		
			else if (xType=='colorTemperature'){
				category='color-temperature'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','Kelvin',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','1500:8000',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)
                int mireds=(int)1000000/state.toInteger()
                mqtt.publishMsg (sTopic+'/'+category+'/mireds',"${mireds}",1,true,settings?.minHomie)
				//UOM="%"
				HAtype="RGB"
			}
			else if (xType=='dim'){  // DONT think this happens
				category='DIM'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)	
				//UOM="%"
				HAtype="RGB"
			}

			else if (xType=='hue'){
			    category='color'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/h',state.toString(),1,settings?.homieStatesPersist,settings?.minHomie)  //unnecessary ?
				//int temp=state.toInteger()
				//temp=(temp*36)/10  //TODO Taken out to keep 0-100 'low' but wary if I should have done so
                theDevice=evt.getDevice()
                //hueNum=state.toInteger()
                hueNum=theDevice.currentValue("hue")
                Integer LHueNum = (hueNum*3.6).toInteger()
                //hueNum=hueNum*3.6
                satNum=theDevice.currentValue("saturation")
                valNum=theDevice.currentValue("level")                    
                        log ("H: ${hueNum} ${satNum} ${valNum}","INFO")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNuM},${satNum},${valNum}",1,true)     // TODO CHECKRGB            
                        mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)
				HAtype="RGB"
			}
			else if (xType=='level'){  //hope this doesn't conflict with dimmed
				category='color'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/v',state.toString(),1,settings?.homieStatesPersist,settings?.minHomie)  // TODO Check is this right  // unnecessary ?
                theDevice=evt.getDevice()
                hueNum=theDevice.currentValue("hue")
                LHueNum = (hueNum*3.6).toInteger()
                satNum=theDevice.currentValue("saturation")
                //valNum=state.toInteger()
                valNum=theDevice.currentValue("level")
                mqtt.publishMsg (sTopic+'/dim',valNum.toString())
                        //log ("V: (${LHueNum}) ${hueNum} ${satNum} ${valNum}","INFO")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true)                   
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             
				HAtype="RGB"
		    }
			else if (xType=='saturation'){   
				category='color'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/s',state.toString(),1,settings?.homieStatesPersist,settings?.minHomie)  // unnecessary ??
                theDevice=evt.getDevice()
                hueNum=theDevice.currentValue("hue")
                LHueNum = (hueNum*3.6).toInteger()                            
                satNum=theDevice.currentValue("saturation")
                //satNum=state.toInteger()
                valNum=theDevice.currentValue("level")                
                        //log ("S: ${hueNum} ${satNum} ${valNum}","INFO")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true) 
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             
				//UOM="%"
				HAtype="RGB"
			}
		else if (xType=="hsv") {
				category='color'
// TODO CHECKRGB			
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/h',state[0].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/s',state[1].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/v',state[2].toString(),1,settings?.homieStatesPersist)  // TODO Check is this right
				//mqtt.publishMsg (sTopic+'/color',"${state[0]},${state[1]},${state[2]}",1,settings?.homieStatesPersist)
	   			mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,settings?.minHomie)
                int hue= state[0].intValue()
                LHueNum = (hue*3.6).toInteger()
                int sat= state[1].intValue()
                if (val==null) val=99
                mqtt.publishMsg (sTopic+'/color',"${LHueNum},${sat},${val}",1,settings?.homieStatesPersist)
                // Where does this get published - old format .. TODO BUG ??
				//mqtt.publishMsg (sTopic+'/color','{"h":'+state[0].toString()+',"s":'+state[1].toString()+',"v":'+state[2].toString()+'}',1,settings?.homieStatesPersist)
                    //if (state[2] == null) int val=99 else int val=state[2].intValue()     
                        //oldRGB=hsvToRGB (hue*3.6,sat, val,"high")
                       RGB=hubitat.helper.ColorUtils.hsvToRGB([hue,sat, val])
           
                mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)
            
                 // mqtt.publishMsg (sTopic+'/'+category,"[${hueNum},${satNum},${valNum}]",1,true)   // TODO check - should this be enabled             
				HAtype="RGB"
		}
			else if (xType=='onoff'){   // Dont think this happens  - this topic created by the 'switched' event
				category='ONOFF'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true,settings?.minHomie)
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)	
				//UOM="%"
				HAtype="RGB"
			}
			else if (xType=='switch'){   // hope this doesnt conflict with switchedDim - ot is called
				category='onoff'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,settings?.minHomie)	
				//UOM="%"
				HAtype="RGB"
			}

            else if (xType=='colorName'){   // hope this doesnt conflict with switchedDim - ot is called
				category='color-name'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','text',1,true,settings?.minHomie)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,settings?.minHomie)
                //mqtt.publishMsg (sTopic+'/'+category,'its blue',1,true)
				//UOM="%"
				HAtype="RGB"
			}

		else log ("Received a new colour event ${xType} from ${name}","TRACE")
		

		
		if (xType=="RGB"||xType=="RGBT")
		{
			category='color' // this is a temporary kludge TODO better
			log ("Ignoring ${xTYPE} for  ${name.toString()} value ${state.toString()}","WARN")
			return  // This is overwriting color attribute with #FFFFFF as currentColor() returns that so dont action
		}
        if (category=="unknown") log ("Need to handle ${xType} in RGB colour", "ERROR")
		log ("Handling an ${xType} event - for ${name.toString()}", "TRACE")
		

			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation//  TODO BUG multiple properties
        
       /*
			atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG check TODO maybe have to check against sTopic
			pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
			mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
*/
            addProperty(sTopic,category)
        
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true) 
			mqtt.publishMsg (sTopic+'/$type',"RGBT light",1,true,settings?.minHomie)   
			mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,settings?.minHomie)  
			mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,settings?.minHomie)
			if (state=="on") state = "true" 
			else if (state=='off') state = "false"  // TODO customisable
            if (category != 'color') {  // hue was overwriting color map - need to check why I even do next publish TODO BUG ?      
			    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)
                }
            
		//	mqtt.publishMsg (sTopic+'/color/r',255,1,settings?.homieStatesPersist)  /? TODO What is this for ? Red ? but no g or b ??
		
			//{"h":216,"s":100,"v":67}
	//TODO BUG refine this by checking name matches (if use this)
	//	mqtt.publishMsg (sTopic+'/color',"${extractInt(atomicState.hue)},${extractInt(atomicState.sat)},${extractInt(atomicState.lev)}",1,settings?.homieStatesPersist)
	    mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,settings?.minHomie)
	//	mqtt.publishMsg (sTopic+'/color/hsv','{"h":'+extractInt(atomicState.hue)+',"s":'+extractInt(atomicState.sat)+',"v":'+extractInt(atomicState.lev)+'}',1,settings?.homieStatesPersist)
	}
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"light","colour")
	}
	else if (settings?.HADiscovery) log ("HADiscovery RGB discarded for ${name}","DEBUG")
	
	
}

//#######################################################################################################################################
//#########################   This section adds the names to the dropdown selectors and creates the devices   ###########################
//#######################################################################################################################################

def onoffCapability(evt) {
	temp = atomicState.onoffDevices
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list:OnOff ${evt.value}", "TRACE")
	}
	else { 
		log ("Adding to dropdown list:OnOff ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.onoffDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
	createChildDevice (evt.value, "onoff", "homie", evt.value)
}

def dimCapability(evt) {  //TODO merge with above
	temp = atomicState.dimDevices
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in list:Dimmer ${evt.value}", "TRACE")
	}
	else {
		log ("Adding to dropdown list:Dimmer ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.dimDevices = temp
	}
	createChildDevice (evt.value, "dim", "homie", evt.value)
}

def buttonCapability(evt) {
	temp = atomicState.buttonDevices
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list: ${evt.value}", "TRACE")
	}
	else { 
		log ("Adding to dropdown list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.buttonDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
	createChildDevice (evt.value, "button", "homie", evt.value)
}

def varCapability(evt) {
    temp = atomicState.varDevices
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list: ${evt.value}", "TRACE")
	}
	else { 
		log ("Adding to dropdown list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.varDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
	createChildDevice (evt.value, "variable", "homie", evt.value)
    
    
}

def sensorCapability(evt) {  //TODO merge with above
	temp = atomicState.sensorDevices
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
	log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("Homie adding sensor to list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.sensorDevices = temp
	}
	createChildDevice (evt.value, "sensor", "homie", evt.value)
}

def dimCapabilityShelly(evt) { //TODO merge
    //log  ("Not implemented yet !", "ERROR")
}

//Casey <
def lockCapability(evt) { 
	temp = atomicState.lockDevices
	if (temp==null) temp=[]
	if (temp.contains(evt.value)) {
		log ("Already in dropdown list: ${evt.value}", "TRACE")
	}
	else {
		log ("Adding to dropdown list: ${evt.value}", "TRACE")
		temp.add(evt.value)
		atomicState.lockDevices=temp
	}
	//log("Creating homie device " + evt.value,"TRACE")
	createChildDevice (evt.value, "onoff", "homie", evt.value)  // <--- just realized I missed this originally; not sure what it needs to be without actually testing
}
//Casey >

def ShellyCapabilities(evt) {
    log ("Found Shelly Device ${evt.value}","INFO")
    shellyType=evt.value.substring(0,evt.value.indexOf('-'))
    if (shellyType=='shellyswitch25')
    {
       onoffCapabilityShelly(evt.value + ' relay 0')
       onoffCapabilityShelly(evt.value + ' relay 1') 
    }
    else log ("currently unsupported type #${shellyType}#","WARN")
}

def onoffCapabilityShelly(name) { //TODO merge
	temp = atomicState.ShellyDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
	log ("Already in list: ${name}", "TRACE")
	}
	else {
		log ("Shelly adding relay to list: ${name}", "INFO")
		temp.add(name)
		atomicState.ShellyDevices = temp
	}
	createChildDevice (name, "onoff", "Shelly", name)
}

def HASwitchCapability(evt) {  //TODO merge with above
	temp = atomicState.HASwitchDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding switch to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HASwitchDevices = temp
	}
	createChildDevice (evt.value, "onoff", "HA", label)
}

def HALightCapability(evt) { //TODO merge with above
	temp = atomicState.HALightDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding light to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HALightDevices = temp
	}
	createChildDevice (evt.value, "dim", "HA", label)
}
def HASensorType(evt) { //device_type
    def data = parseJson(evt.data)
    sType=data.payload
    log ("HA Sensor ${evt.value}  device_type ${sType}","TRACE")
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]

	label=data.label
    if (data.label==null) label=evt.value
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding sensor to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HASensorDevices = temp
	}
	createChildDevice (evt.value, "sensor", "HA", label, sType)
}

    
def HASensorCapability(evt) {  // friendlyName  // This is going to get added twice with topicname and friendlyname
    // log ("HA Sensor friendly name  ${evt.value}","WARN")
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
/*
        else if (temp.contains(normalize(evt.value))) {
		log ("Normalized name already in list: ${evt.value}", "ERROR")
	}
*/
	else {
		log ("HA Adding sensor to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HASensorDevices = temp
	}
    createChildDevice (evt.value, "sensor", "HA", label)
}

def HABinarySensorCapability(evt) {  // TODO merge with above
	temp = atomicState.HABinarySensorDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	dType=data.type
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding binary sensor to list: ${evt.value}  ${dType}  ", "DEBUG")
		temp.add(evt.value)
		atomicState.HABinarySensorDevices = temp
	}
	// 4th param 'friendlyname' is not yet available so evt.value passed instead - will be renamed later in reNameDev()
	createChildDevice (evt.value, "binary_sensor", "HA", evt.value, dType)  
}

def HAGroupCapability(evt) {  // TODO merge with above
	temp = atomicState.HAGroupDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding group to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAGroupDevices = temp
	}
	createChildDevice (evt.value, "group", "HA", label)
}

def HACoverCapability(evt) {  // TODO merge with above
	temp = atomicState.HACoverDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding cover to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HACoverDevices = temp
	}
	createChildDevice (evt.value, "cover", "HA", label)
}
    
def HALockCapability(evt) {  // TODO merge with above
	temp = atomicState.HALockDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding lock to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HALockDevices = temp
	}
	createChildDevice (evt.value, "lock", "HA", label)
}
    
def HAClimateCapability(evt) {  // TODO merge with above
	temp = atomicState.HAClimateDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding climate to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAClimateDevices = temp
	}
	createChildDevice (evt.value, "climate", "HA", label)
}
    
def HADeviceTrackerCapability(evt) {  // TODO merge with above
	temp = atomicState.HADeviceTrackerDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding device tracker to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HADeviceTrackerDevices = temp
	}
	createChildDevice (evt.value, "deviceTracker", "HA", label)
}
    
def HAInputBooleanCapability(evt) {  // TODO merge with above
	temp = atomicState.HAInputBooleanDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding group to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAInputBooleanDevices = temp
	}
	createChildDevice (evt.value, "inputBoolean", "HA", label)
}

def HAPresenceCapability(evt) {  // TODO merge with above
	temp = atomicState.HAPresenceDevices
	if (temp==null) temp=[]
	def data = parseJson(evt.data)
	label=data.label
	if (temp.contains(evt.value)) {
		//log ("Already in list: ${evt.value}", "TRACE")
	}
	else {
		log ("HA Adding group to list: ${evt.value}  label ", "TRACE")
		temp.add(evt.value)
		atomicState.HAPresenceDevices = temp
	}
	createChildDevice (evt.value, "presence", "HA", label)
}

//########################################################################################################################################
//###########################  This section finds the device from incoming MQTT 'set' message to allow control   #########################
//########################################################################################################################################

def LookupManual(evt) {
	def dimDevice=false
	def onoffDevice=false
	def textDevice=false
	def data = parseJson(evt.data)
	deviceID=data.topic
	if (settings?.HEBasic)
	{
		if (deviceID.indexOf ("Hubitat/"+settings?.hubName)==0)  {  // this is an incoming MQTT command on the basic topic control topic 
			log ("Need to action this command " + data + " " + deviceID, "TRACE")
		}
	}
	tempMap=atomicState.topicMap
	// content=[topic: data.state, maxLevel: valueMax, stateON: data.stateON, stateOFF, data.stateOFF]
	log ("Need to find devices using [" + evt.value + "] "+ deviceID,"TRACE")
	log ("Settings " + settings?.adhoc, "TRACE")
	log ("Looking up in topic map for "+ deviceID + "  ==  "  + tempMap[deviceID], "DEBUG")
	LookupID = tempMap[deviceID]
	if (LookupID != null)
		{
			log ("***** Found in map ***** for "+ data.topic + "  ==  "  + LookupID.topic, "DEBUG")
			devType="map"
			if (LookupID.type=="onoff") 
			{
				onoffDevice=true
				stateON = LookupID.stateON
				stateOFF = LookupID.stateOFF
			}
			else if (LookupID.type=="dim") 
			{
				dimDevice=true
				LookupLevel=LookupID.maxLevel
				if (LookupLevel == '?') {
					log ("However there was no corresponding MaxValue for " + data.topic, "WARN")
					log ("The valueMap is ... " + LookupLevel,"WARN")
				}
			}
			deviceID = LookupID.topic
		}
		else {
			log ("Didnt find this entry in the topicMap lookup for " + deviceID  , "DEBUG")
			for ( e in tempMap ) {
    			log ("<topic>: key = ${e.key}, value = ${e.value}","DEBUG")
			}
			devType='?'
		}
		
	// should be found later by deviceNetworkID lookup (below)
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ deviceID){
				log ("Manual device found via Lookup " + item + "  " + adhoc[index].type, "DEBUG")
                
                //atts=adhoc[index].supportedAttributes
                // log.error "This is ==" + atts[3] + "== " + [atts].contains "switch" // TODO
                
                def currentState = adhoc[index].currentValue("switch")  //TODO Kludge
                if (currentState!=null){
                    log ("Has switch capability: ${item}", "TRACE")
                    onoffDevice=true
                }
                currentState = adhoc[index].currentValue("level")
                if (currentState!=null){
                    log ("Has dim capability: ${item}", "TRACE")
                   dimDevice=true
                }
				if (devType != "map") devType="manual"
				// TODO quit loop when found ??
				//if (!dimDevice) onoffDevice=true //TODO - is it right to assume this ? NO
	
				device=adhoc[index]  
				//TODO exit loop on match or match multiple ? - currently matching last
			}
			index++
		}
	
		if (device==null) // try the HE local devices published to MQTT
		{
				topic = data.topic.split('/')
				if (topic[0] != "Hubitat")
				{
					log ("Unexpected topic " + data.topic + " " + topic[0], "DEBUG")
					return
				}
				dName=topic[2]
			    log ("Didnt find the device by DNI lookup either " + dName, "DEBUG")
				index=0
				for (String item : settings?.switches) {   // SWITCHES 
					if (item==dName) 
					{
						log ("Found " + dName + " in switches. DNI: " + switches[index].deviceNetworkId, "INFO")
						device=switches[index]
						if (topic[3]=="onoff") onoffDevice=true
						devType="system"
					}
					index++
				}
				index=0
				for (String item : settings?.dimmers) {   // DIMMERS
					if (item==dName) 
					{
					    log ("Found " + dName + " in dimmers. DNI:  " + dimmers[index].deviceNetworkId, "INFO")
						device=dimmers[index]
						if (topic[3]=="onoff") onoffDevice=true
						else if (topic[3]=="dim") dimDevice=true
						devType="system"
					}
					index++
				}
		}
	textDev=device.currentState("mqtt")   // use currentValue instead TODO 
	
	if (textDev!=null) {
        if (textDev.getStringValue()=="text") textDevice=true
	}
	
	if (device==null) 	log ("Can't find " + deviceID + " " + dName + " device by DNI","ERROR")
	if (devType!='?'){	
		log ("${device.name} Unknown device type -   dim:" + dimDevice + " onoff:"+ onoffDevice + " type:"+ devType,"DEBUG")
		
/*
if (devType=="manual" && !onoffdevice && !dimdevice) {    // we are going to have to deal with text here
			// need to create 'text' rather than 'manual' type in the device when created 

			if (device.currentState("MQTT") == "text") {
				log ("Sending device text " + device.name , "WARN")
				device.setValue (evt.value)
			}
		}
*/		
        if (textDevice) {
            device.updateText (evt.value)
        }
		
		if (onoffDevice)  
		{
		log ("Handling as onoff", "DEBUG")
			if (devType=="map") {
				if (evt.value==LookupID.stateOFF) device.toOFF()
				else if (evt.value==LookupID.stateON) device.toON()
			}
			else {  // will have to surmise state required
				log ("Surmising required state [" +evt.value+"] for " + device.name,"DEBUG")
                if (device.currentValue('stateON')!=null) OnValues=device.currentValue('stateON')
			else OnValues="on,On,ON,true,True,TRUE,yes,Yes,YES,1"
			if (device.currentValue('stateOFF')!=null) OffValues=device.currentValue('stateOFF')
			else OffValues="off,Off,OFF,false,False,FALSE,no,No,NO,0"
				//if (OnValues.contains(evt.value.toLowerCase()))
                if (OnValues.contains(evt.value))
				{
					if (devType == "system") device.on() else device.toON()
				}
				//else if (OffValues.contains(evt.value.toLowerCase()))
                else if (OffValues.contains(evt.value))
				{
					if (devType == "system") device.off() else device.toOFF()
				}
				else log ("Unknown state value " + evt.value +" - need to add in device settings (or lookup)","WARN")	
				}
			}
		}
	
	
		if (dimDevice) {
			//if (devType=="dim") {
				 log ("Handling as dim", "DEBUG")
				 try {  // see if its numeric  // LookupLevel should be valid
					float convertedNumber = Float.parseFloat(evt.value)  // TODO messy and repeatedly used

					if (LookupLevel == null)
					 {
						 if (devType=="system"){
							 device.setLevel (evt.value.toInteger(),0)
						 }
						 else log ("There's no corresponding MaxValue for " + data.topic, "WARN")
					 }
					else {
						convertedNumber = convertedNumber * (100/Float.parseFloat(LookupLevel.toString()))  //think this will work for 1.0 too
						intLevel = convertedNumber = convertedNumber.round()
						adjLevel=intLevel.toString()
						log ( " The numeric payload for " + device.name + " was converted from " + evt.value + " to " + adjLevel, "DEBUG")
						device.toLevel(adjLevel,1)
					}
			}
			catch (Exception e1) {
				log ("This payload wasnt numeric  " + evt.value + "  " + evt.data + "  " + e1, "WARN")
				}
			//}
		}
		if (devType=="unknown") log ("Incoming MQTT message for unknown device "+deviceID,"ERROR")
	}

//#######################################################################################################################################
//############################   This section handles MQTT 'set' events/state changes and updates the devices   #########################
//#######################################################################################################################################

def onoffEvent (evt) {
	def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
	log ("Received an OnOff event from ${evt.value} turned ${data.status}", "TRACE")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (OnOff) matches " + item +" " + index,"DEBUG")
				// TODO quit loop when found
				//child=item
				child=adhoc[index]  // this isn't actually a child it is a real 'adhoc' device
				//exit  // return might be bad
			}
				index++
		}
			if (child==null) {
				//log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
		}	
	}	
	log  ("Got " + child, "TRACE")
	currStatus=data.status
	isStatus="off"
	if (currStatus == "off") child.setStateType ("off","on")
	else if (currStatus == "off") child.setStateType ("off","on")
	else if (currStatus == "Off") child.setStateType ("Off","On")
	else if (currStatus == "OFF") child.setStateType ("OFF","ON")
	else if (currStatus == "false") child.setStateType ("false","true")
	else if (currStatus == "False") child.setStateType ("False","True")
	else if (currStatus == "FALSE") child.setStateType ("FALSE","TRUE")
	else if (currStatus == "0") child.setStateType ("0","1")
	else 
	{
	isStatus = 'on'
	if (currStatus == "on") child.setStateType ("off","on")
	else if (currStatus == "On") child.setStateType ("off","on")
	else if (currStatus == "On") child.setStateType ("Off","On")
	else if (currStatus == "ON") child.setStateType ("OFF","ON")
	else if (currStatus == "true") child.setStateType ("false","true")
	else if (currStatus == "True") child.setStateType ("False","True")
	else if (currStatus == "TRUE") child.setStateType ("FALSE","TRUE")
	else if (currStatus == "1") child.setStateType ("0","1")
	else isStatus = "#"
	}
	if (currStatus == "unavailable") isStatus="?"
		if (isStatus=="off") {
			//child.off
			child.toOFF()
			//log ("OFF "+ child, "DEBUG")
		}
		else if (isStatus=="on"){
			//child.on()
			child.toON()
			//log ("ON "+ child, "DEBUG")
		}
		else if (isStatus=="?"){  // This is likely a Philips Hue bulb that is powered off
			log ("Reported OnOff status was ${currStatus} for device ${evt.value}","INFO")
		}
	    else log("Bad reported OnOff status... was ${currStatus} for device ${evt.value}","WARN")
}

def dimEvent (evt) {
	def data = parseJson(evt.data)
	//data.state is the same as data.payload[0] 
    //log ("event data: ${data}", "INFO")
	log ("Received a dim event from ${evt.value} level ${data.level}", "TRACE")
	child=getChildDevice("MQTT:homie_"+evt.value) 
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		// now check adhoc virtual devices
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (Dim) matches " + item +" " + index,"DEBUG")
				// TODO quit loop when found or match all - currently match last
				child=adhoc[index]  // this isnt actually a child it is a real adhoc device
			}
				index++
		}
			if (child==null) return	
	}	
	log ("Setting Child dim level to ${data.level}", "TRACE")
	child.toLevel(data.level,1)   // Is this assuming I am using a virtual device ?? If so BUG
    child.setLevel(data.level,1)
}

def sensorEvent(evt) {
	def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
    //log ("Received a sensor event from ${evt.value} level ${data.status}", "INFO")
	child=getChildDevice("MQTT:homie_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)		
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
			return
		}	
	}
    log ("Received a sensor event from ${evt.value} level ${data.status}", "INFO")
    if (evt.value.contains ("humidity"))child.setHumidity(data.status) // TODO Check if device is not Omni does this error
    else if (evt.value.contains ("temperature"))child.setTemperature(data.status)
    else if (evt.value.contains ("accelertion"))child.setAcceleration(data.status)
    else if (evt.value.contains ("carbonDioxide"))child.setCarbonDioxed(data.status)
    else if (evt.value.contains ("carbonMonoxide"))child.setCarbonMonoxide(data.status)
    else if (evt.value.contains ("contact"))child.setContact(data.status)
    else if (evt.value.contains ("illuminance"))child.setIlluminance(data.status)
    else if (evt.value.contains ("motion"))child.setMotion(data.status)
    else if (evt.value.contains ("presence"))child.setPresence(data.status)
    else if (evt.value.contains ("smoke"))child.setSmoke(data.status)
    else if (evt.value.contains ("water"))child.setVariable(data.status)
    // pressure will go into variable
	child.setVariable(data.status)
}

def binarySensorEvent(evt) {
	def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
	log ("Received a binary sensor event from ${evt.value}  state is   ${data.status}", "TRACE")
	child=getChildDevice("MQTT:homie_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)		
		if (child==null) {
			log ("getChild failed for " + evt.value + "   not enabled ?", "DEBUG")
			return
		}	
	}	
	//log ("Checking how I handle a ${data.status} message for ${evt.value} of type ${child.typeName} ??", "DEBUG")
	typeName=child.typeName
		
			if (data.status=="off") {
				if (typeName=="Virtual Motion Sensor") child.inactive()					
																			/*
																			// active/inactive setTemperature
																			// motion : inactive
																			// temperature : 21.12
																			*/		
				
				if (typeName=="Virtual Switch") child.off()   						
																			// on/off
																			// switch : on

				if (typeName=="Virtual Contact Sensor") child.close()   	
																			// open/close
					

				if (typeName=="Virtual Presence") child.departed()  						
																			/*
																			// arrived/departed     
																			// presence : present
																		    */

				if (typeName=="Virtual Omni Sensor") child.motionInactive()  //lots 
																			/*
																			COClear/CODetected accelerationActive/accelerationInactive arrived/departed close/open smokeClear/smokeDetected dry/wet
																			motionActive/motionInactive setIlluminance setRelativeHumidity setTemperature setCarbonDioxide 
																			acceleration : inactive
																			carbonDioxide : 350
																			carbonMonoxide : clear
																			contact : closed
																			humidity : 35
																			illuminance : 50
																			motion : inactive
																			presence : present
																			smoke : clear
																			temperature : 70
																			water : dry
																			*/

				if (typeName=="Virtual Multi Sensor") child.inactive() 
																			/*
																			active/inactive open/close setTemperature  
																			contact : closed
																			temperature : 21.12
																			acceleration : inactive
																			*/ 


			}	
			else if (data.status=="on"){
				if (typeName=="Virtual Motion Sensor") child.active()
				if (typeName=="Virtual Switch") child.on()
				if (typeName=="Virtual Contact Sensor") child.open()
				if (typeName=="Virtual Presence") child.arrived()
				if (typeName=="Virtual Omni Sensor") child.motionActive()
				if (typeName=="Virtual Multi Sensor") child.active()
		}
	
	//child.setValue(data.status)
}

def groupEvent(evt) {
//TODO Half done BUGGY ?
	def data = parseJson(evt.data)
    //log ("group: event data: ${data}", "TRACE")
	log ("Received an OnOff event from ${evt.value} turned ${data.status}", "TRACE")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
	if (child==null) {
		log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (OnOff) matches " + item +" " + index,"DEBUG")
				// TODO quit loop when found
				//child=item
				child=adhoc[index]  // this isn't actually a child it is a real adhoc device
				//exit  // return might be bad
			}
				index++
		}
			if (child==null) {
				//log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
		}	
	}	
	//log  ("Got " + child + " "+  data.Status, "TRACE")

		if (data.status=="off") child.toOFF()  else if (data.status=="on") child.toON()
}
    
def presenceEvent(evt) {
//TODO Half done BUGGY ?
	def data = parseJson(evt.data)
    //log ("presence: event data: ${data}", "TRACE")
	log ("Received a person presence event from ${evt.value} turned ${data.status}", "TRACE")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
	if (child==null) {
		log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (person) matches " + item +" " + index,"DEBUG")
				// TODO quit loop when found
				//child=item
				child=adhoc[index]  // this isn't actually a child it is a real adhoc device
				//exit  // return might be bad
			}
				index++
		}
			if (child==null) {
				//log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
		}	
	}	
	//log  ("Got " + child + " "+  data.Status, "TRACE")

		if (data.status=="home") child.arrived()  else child.departed()  // away status might be a zone name
}

    

def inputBooleanEvent(evt) {   // TODO This is probably identical to 'group' above and can easily be combined
//TODO Half done BUGGY ?
	def data = parseJson(evt.data)
    //log ("inputBoolean: event data: ${data}", "INFO")
	log ("Received an OnOff event from ${evt.value} turned ${data.status}", "TRACE")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
	if (child==null) {
		//log ("getChild failed for " + evt.value, "TRACE")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
		index=0	
		for (String item : settings?.adhoc) {
			if (adhoc[index].deviceNetworkId == "MQTT:Internal "+ data.topic){
				log ("FOUND (OnOff) matches " + item +" " + index,"DEBUG")
				// TODO quit loop when found
				//child=item
				child=adhoc[index]  // this isn't actually a child it is a real adhoc device
				//exit  // return might be bad
			}
				index++
		}
			if (child==null) {
				//log ("Device not enabled: "+ evt.value,"TRACE")
				return
			}
		}	
	}	
	log  ("Got " + child + " "+  data.Status, "DEBUG")

		if (data.status=="off") {
			//child.off()
			child.toOFF()  // This is a real device so wont have toOFF - maybe need my virtual
			log ("OFF "+ child, "TRACE")
		}
		else if (data.status=="on"){
			//child.on()
			child.toON()
			log ("ON "+ child, "TRACE")
		}
}

def HABinSensorType(evt) {
	def data = parseJson(evt.data)
	log  ("Received binary_sensor type event of ${data.type} from ${evt.value}","TRACE")
}

def sensorUOM(evt) { 
	def data = parseJson(evt.data)
	child=getChildDevice("MQTT:homie_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		child=getChildDevice("MQTT:HA_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
			return
		}	
	}		
	unit = "째" //+data.label[7]  // TODO hack until I work out unicode 16 convert better \u00b0 

	if (child.typeName=="MQTT Dimmer" || child.typeName=="MQTT Switch" ){  // only call for my device drivers
	child.setPrefix("")
	child.setSuffix(unit)
	}
}

def cmdEvent (evt) {  // 'set' command from homie for a Hubitat or manual device via Hubitat basic 
	// TODO This has value and data transposed in the two versions for discovered and adhoc .. tidy up
	def data = parseJson(evt.data)
	log ("MQTT set command received for " + evt.value + " " + data.cmd + " " + data.state,"INFO")
	normName=evt.value
	if (atomicState.nameMap[normName]==null){
		log ("No name map for ${normName} so assume Hubitat basic topic or homie /hub", "INFO") // could check from data.topic.topic[0]
		matchName=normName
			 }
		else matchName=atomicState.nameMap[normName]
        log ("${data.cmd} received ${data.state}","TRACE")
    if (matchName=="hub"){
        if (data.cmd=="mode") {
            
	        if (location.mode != data.state) {
		        if (location.modes?.find{it.name == data.state}) {
			        location.setMode(data.state)
		        } 
            else {
			    log ( "Hub Mode Cmd: unknown mode ${data.state}","ERROR")
		        }
	        }
        }
    }
    
 //Casey <
    

	else if (data.cmd=="lock") {
		MQTTlocks = (settings?.locks)
		log ("Lock Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTlocks.each {   // This is awful - looping through - do it the other way
			if (it.displayName==matchName){
				// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				LockValues="true"
				UnlockValues="false"
				if (LockValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system")
					it.lock()  // think can only be a system type here
					//else device.toON()
				}
				else if (UnlockValues.contains(data.state.toLowerCase()))
				{
                    if (settings?.allowMqttUnlock) {
					    it.unlock() // think can only be a system type here                    
                    } else {
                        log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                    }
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}

    } 
//Casey >   
    
	else if (data.cmd=="onoff" || data.cmd=="switch") {  // TODO convert to select / case   'switch' comes from RGB devices
		MQTTswitches = (settings?.switches)
		log ("Switch Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTswitches.each {   // This is awful - looping through - do it the other way		
			if (it.displayName==matchName){	
				// DUPLICATED TODO combine this as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
//log.error "${it.displayName} should be checking for ${it.currentValue('stateON')}"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")	
			}
		}	
					
		MQTTdimmers = (settings?.dimmers)
		log ("Dimmer Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTdimmers.each {  // This is awful - looping through - do it the other way
			if (it.displayName==matchName){
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}
		
		
		MQTTRGB = (settings?.colour)
		// log ("ColourC Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTRGB.each {  // This is awful - looping through - do it the other way
		if (it.displayName==matchName){
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}
// TODO Think this can be ignore FTTB as it is a near duplicate in terms of lookup	
		MQTTRGB = (settings?.colourT)
    	//log ("ColourT Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
		MQTTRGB.each {   // This is awful - looping through - do it the other way
		if (it.displayName==matchName){
			// TODO combine this below as one method for all
				log ("Surmising required state [" +data.state+"] for " + evt.value,"DEBUG")
				OnValues="on,true,yes,1"  
				OffValues="off,false,no,0"
				if (OnValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.on()  // think can only be a system type here
					//else device.toON()
				}
				else if (OffValues.contains(data.state.toLowerCase()))
				{
					//if (devType == "system") 
					it.off() // think can only be a system type here
					//else device.toOFF()
				}
				else log ("Unknown state value " + data.state +" - need to add to lookup","WARN")
			}
		}
			
	}
	
	else if (data.cmd=="dim") {
		intLevel=data.state.toInteger()
		if ((0 <= intLevel)) //  && (intLevel <= 100)) //TODO Check removing this upper bound check doesn't break anything
		{
			
			log ("Dimmer Lookup for  "+  evt.value + " is " + matchName + " [" + atomicState.nameMap[index] +"] ","TRACE")
			MQTTdimmers = (settings?.dimmers)
			MQTTdimmers.each {  // This is awful - looping through - do it the other way
				if (it.displayName==matchName){
					log ("Found " + it.displayName, "TRACE")
					it.setLevel(intLevel,1)
				}
			}
			adhoc=(settings?.adhoc) 
			adhoc.each { 
				if (it.displayName==matchName){ 
				it.setLevel(intLevel,1)
				}
			}
			MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setLevel(intLevel,1)
				}
			}
            MQTTRGB = (settings?.colourT)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setLevel(intLevel,1)
				}
			}
		}		
	}
	
	else if (data.cmd=="color") {
		
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName){
                    if (data.state[0]=='#') {
                        HSV=hubitat.helper.ColorUtils.rgbToHSV([red, green, blue])
                        HSL=[:]
                        HSL.put('hue',HSV[0].toInteger())
                        HSL.put('saturation',HSV[1].toInteger())
                        HSL.put('level',HSV[2].toInteger())
                        it.setColor(HSL)
                        //it.setColor(HSV)
                        return
                    }
					float Rtemp= Float.parseFloat(data.state)/3.6
					int hue = Math.round (Rtemp)  // 0-360
                    it.setHue(hue)  // 0-100
                   // int sat = hue
					if (data.payload.size()>1) {
						Rtemp= Float.parseFloat(data.payload[1])/1.0
						int sat = Math.round (Rtemp)
                        pauseExecution(5000)  //   really !!!! TODO Look at why I did this
                        it.setSaturation(sat)  // 0-100
						//it.setSaturation(sat)  // 0-100
					}
					
                        //it.setHue(hue)
                        HSL=[:]                 
                        HSL.put('hue',hue.toInteger())
                        HSL.put('saturation',sat)
                        HSL.put('level',50)
                        it.setColor(HSL)
                    //it.setHue(hue)  // 0-100
				}
			}
        
        	MQTTRGB = (settings?.colourT)  // Absolute duplicate of above except for colourT - fix TODO
			MQTTRGB.each {
				if (it.displayName==matchName){
                    if (data.state[0]=='#') {
                        RGB=hubitat.helper.ColorUtils.hexToRGB(data.state)
//log.error "Got an #RGB value ${data.state} >>  ${RGB}"
                        HSV=hubitat.helper.ColorUtils.rgbToHSV(RGB)                   
//log.error "HSV is ${HSV}    ${HSV[0]} ${HSV[1]} ${HSV[2]}"

                        def HSL = [:]
                        HSL.put('hue',HSV[0].toInteger())
                        HSL.put('saturation',HSV[1].toInteger())
                        HSL.put('level',HSV[2].toInteger())
                                               
//log.error "HSV is ${HSV}      ${HSV.hue} ${HSV.saturation} ${HSV.value}"
                         it.setColor(HSL)
                        //it.setColor([HSV])
//log.error "SetColor RGBWT" + HSV + "   " + HSL
                       // it.setSaturation(HSV.saturation.toInteger())
					   // it.setHue(HSV.hue.toInteger())
					   // it.setLevel(HSV.value.toInteger())
                        RGB=hubitat.helper.ColorUtils.hsvToRGB(HSV)
//log.error "Returned RGB is ${RGB}"
                        return
                    }
					float Rtemp= Float.parseFloat(data.state)/3.6 //TODO checkRGB
					int hue = Math.round (Rtemp)  // 0-360
					if (data.payload.size()>1) {
						Rtemp= Float.parseFloat(data.payload[1])
						int sat = Math.round (Rtemp)
						it.setSaturation(sat)  // 0-100
					}
					it.setHue(hue)
				}
			}
		
	}
	
	else if (data.cmd=="hsv") {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName){
					it.setSaturation(data.payload[1].toInteger())
					it.setHue(data.payload[0].toInteger())
					it.setLevel(data.payload[2].toInteger())
				}
			}
	}
	
	else if (data.cmd=="hue") {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName){
					it.setHue(data.payload[0].toInteger())
				}
			}
	}
	else if (data.cmd=="level") {  // currently only searching colour bulbs for this as it's a RGB event
			MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setLevel(data.payload[0].toInteger())
				}
			}
	}
	else if (data.cmd=="saturation") {
			MQTTRGB = (settings?.colour)
			MQTTRGB.each { 
				if (it.displayName==matchName){
					it.setSaturation(data.payload[0].toInteger())
				}
			}
	}
	
	else if (data.cmd=="colorTemperature") { // This is from the Hubitat Basic topic
			MQTTRGB = (settings?.colour)
			MQTTRGB.each {
				if (it.displayName==matchName){
					it.setColorTemperature (data.state.toInteger())	
				}
			}
	}
	else if (data.cmd=="color-temperature") {  // This is from the homie topic                           //TOD these on homie are normalised names - need to match as such i.e. as in thermostats below TODO BUG ??
			MQTTRGBT = (settings?.colourT)
			MQTTRGBT.each { 
				if (it.displayName==matchName){
                    int cKelvin=data.state.toInteger()
                    int cMired=0
                    if (cKelvin>1000) cMired=(int)1000000/cKelvin // was Kelvin
                    else { // wasalready  mireds
                        cMired = cKelvin 
                        cKelvin=(int)1000000/cMired
                    }
					it.setColorTemperature (cKelvin)
					//colTopic=data.topic.topic.substring(0, data.topic.topic.length() - 4)  // TODO KLUDGE for time being
                    //mqtt.publishMsg (colTopic,"${cKelvin}",1,settings?.homieStatesPersist)   // UGH setting reported value to set valueFnine
                    //mqtt.publishMsg (colTopic+'/mireds'," ${cMired}",1,settings?.homieStatesPersist)    
               }
			}
	}

	else if (data.cmd=="battery"||data.cmd=="motion"||data.cmd=="temperature") {
		log ("Trying to 'set' a sensor value ${data.cmd} for ${evt.value}", "WARN")
		log ("   ... only 'onoff', 'dim', 'color' and 'color-temperature' are settable currently", "WARN")
	}
    
    else if (data.cmd=="heating-setpoint"||data.cmd=="cooling-setpoint"||data.cmd=="mode"||data.cmd=="fanmode") {  // Thermostat temporary handler shouldnt be in sensors
           	thermDev=(settings?.thermostats)
	        if (thermDev != null){
		        thermDev.each{                 
                    if (normalize(it.displayName)==matchName) {
                        //log ("Changing ${data.cmd} of ${it.name} to ${data.state}","ERROR")
                        
                        if (data.cmd=="heating-setpoint"){
                            Float setTemp = data.state.toFloat()  // string seemed to error -- just rechecking
                            it.setHeatingSetpoint(setTemp)
                            //it.setHeatingSetpoint(data.state)
                        }
                        else if (data.cmd=="cooling-setpoint") {
                            setTemp = data.state.toFloat()
                            //thermDev.setCoolingSetpoint(data.state)
                            it.setCoolingSetpoint(setTemp)
                        }
                        else if (data.cmd=="mode") it.setThermostatMode(data.state)
                        else if (data.cmd=="fanmode") it.setThermostatFanMode(data.state)
                    }
                }
           }
           else log ("No matching thermostat found for command ${data.cmd} for ${evt.value}", "WARN")
    }
    else if (data.cmd=="securitymode"){
        if (data.state=='----') return
    	Keypads = (settings?.keypads)
			Keypads.each {
				if (normalize(it.displayName)==matchName){
                    if (data.state=='armed night') it.armNight()
                    else if (data.state=='armed home') it.armHome()
                    else if (data.state=='armed away') it.armAway()
                    else {
                         String code = it.currentLockCodes.toString()
                         mqtt.publishMsg ("homie/${atomicState.normHubName}/${matchName}/securitymode/set",'----',1,false)
                        //if (code.contains(':"' + data.state + '"}')) it.disarm()
                        if (code.contains('{"name":"MQTT","code":"'+data.state+'"}')) it.disarm()
                    }
				}
			}
    }
    
    else if (data.cmd=="variable"){
       gVariables =(settings?.gVars)
            gVariables.each {
				if (normalize(it.displayName)==matchName){
                  it.setVariable (data.state)
				}
			}
       gVariables =(settings?.globVars)
            gVariables.each {
				if (normalize(it.displayName)==matchName){
                  it.setVariable (data.state)
				}
			}

        
    }
    
    
            
    
    
	else log ("No matching devices with this command available for ${data.cmd} for ${evt.value}", "WARN")

}

def extractInt( String input ) {
  return input.replaceAll("[^0-9]", "")
}

/*def mqttRX(evt) {
	log ("${evt.name} ${evt.value}", "INFO")
}*/

//#######################################################################################################################################
//############################   This section contains general utility nethods and the createChild() method     #########################
//#######################################################################################################################################

def normalize(name) {
	//TODO research how to include NFD
	//log ("Normalize: " + name + " >>> " + name.trim().toLowerCase().replaceAll(/[^\w-]/,"_").replaceAll(/[-]/,'_'),"TRACE")
	return name ? name.trim().toLowerCase().replaceAll(/[^\w-]/,"-").replaceAll(/[_]/,'-') : undefined
	//return name ? name.trim().toLowerCase().replaceAll(/[.*+?^${} ()|]/,"_").replaceAll(/[^a-z0-9_]/,""): undefined
	//return name ? name.trim().toLowerCase().normalize("NFD").replace(/[ -]+/g, "_").replace(/[^a-z0-9_]/g, "") : undefined
}

def reNameDev(evt) { 
	    dID=evt.value
		child=getChildDevice(dID)
	    if (child == null) {
		   log ("reName: Child doesn't exist (no state or unsupported type ?) "+ evt.value + " " + evt.name , "TRACE")
		   return
	   }
	def data = parseJson(evt.data)
	child.label= data.label
	log ("reNamed  ${evt.value} to ${data.label}" ,"TRACE")
	} 

def createChildDevice(name, type, system, friendlyName, dType='default') {
	// friendlyname may not be available yet so name will have been passed and it will be renamed later in reNameDev()
	log("CreateDevice called " + name + " " + type + " " + system + " " + friendlyName + "  :  " + dType,"TRACE")
	if (name==null) return
	//if (atomicState.started) return // TODO Stops creation of devices after timed startup has elapsed - but also stops ongoing incremental discovery.... decide which to use
	devEnabled=false
	def prefix = "MQTT:"
	String enabledDevices=(settings?.HA_Lights) + ',' + (settings?.HA_Switches) + ',' + (settings?.Homie_dim) + "," + (settings?.Homie_onoff) + ','
	if (system=="HA") {
		if (settings?.HA_Switches != null)
		{									   
			if (settings?.HA_Switches.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
		if (settings?.HA_Lights != null) {
			if (settings?.HA_Lights.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
		if (settings?.HA_Sensors != null) {
			if (settings?.HA_Sensors.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
		if (settings?.HA_BinarySensors != null) {
			if (settings?.HA_BinarySensors.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_Presence != null) {
			if (settings?.HA_Presence.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
		if (settings?.HA_Groups != null) {
			if (settings?.HA_Groups.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_DeviceTrackers != null) {
			if (settings?.HA_DeviceTrackers.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_Covers != null) {
			if (settings?.HA_Covers.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_Climates != null) {
			if (settings?.HA_Climates.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
        if (settings?.HA_Locks != null) {
			if (settings?.HA_Locks.contains (name))
			{
				devEnabled=true
				prefix="MQTT:HA_"
			}
		}
	}
	else if (system=="homie")
	{
		if (settings?.Homie_onoff != null)
		{									   
			if (settings?.Homie_onoff.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
		if (settings?.Homie_dim != null) {
			if (settings?.Homie_dim.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
		if (settings?.Homie_sensor != null) {
			if (settings?.Homie_sensor.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
		if (settings?.Homie_binarySensor != null) {
			if (settings?.Homie_binarySensor.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
        if (settings?.Homie_variable != null) {
			if (settings?.Homie_variable.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
        if (settings?.Homie_button != null) {
			if (settings?.Homie_button.contains (name))
			{
				devEnabled=true
				prefix="MQTT:homie_"
			}
		}
	}
    else if (system=='Sonoff') {
		devEnabled=true
		prefix="MQTT:Sonoff_"
	}

    else if (system=='Shelly') {
		devEnabled=true
		prefix="MQTT:Shelly_"
	}

	else if (system=='internal') {
		devEnabled=true
		prefix="MQTT:Internal_"
	}

	if (!devEnabled)
	{
		log ("["+system+"] Create blocked for " + name, "TRACE")
		return
	}
	else log ("["+system+"] Create OK for " + name + " : " + dType, "TRACE")
	
	child=getChildDevice(prefix+name) 
	if (child != null) 
		{
			// dont expect this if mqttRemoveDevices was true
			// TODO decide ..this gets fired (but ignored) on every change of state update - can we eliminate that without breaking incremental discovery ?
			// no but could use ...  if(atomicState.started)
			if (!atomicState.started && (settings?.mqttRemoveDevices == true)) log ("Child already exists " + prefix+name, "TRACE")
			return
		}
	def nameSpace="ukusa"
	if (type=='onoff') devType='MQTT Switch'
	else if (type=='dim') devType='MQTT Dimmer'
	else if (type=='group') devType='MQTT Switch'  // TODO check if a HA group can have a level ?
	else if (type=='inputBoolean') devType='MQTT Switch'
    else if (type=='presence') {
            nameSpace='hubitat'
            devType='Virtual Presence'
    }
    else if (type=='button') {
            nameSpace='hubitat'
            devType='Virtual Button'
    }
    else if (type=='lock') {
            nameSpace='hubitat'
            devType='Virtual Lock'
    }
    else if (type=='cover') {
            nameSpace='hubitat'
            devType='Virtual Shade'
    }
    else if (type=='deviceTracker') {
            nameSpace='hubitat'
            //devType= "Virtual Contact Sensor"
            devType= "Virtual Presence"
    }
    else if (type=='climates') {
            nameSpace='hubitat'
            //devType='Virtual something'
            log ("HA climate device not implemented yet, no device created", "WARN")
            return
    }
    else if (type=='sensor' || type=='binary_sensor') {
     
        log ("Got a sensor of type ${dType}", "ERROR")
        devType= "Virtual Omni Sensor"
        nameSpace="hubitat"
   
		
		    // again loads have no device_type e.g. arduino_thingshield_alarm  backdoor_x_coordinate  Alexa Sonos

		//devType= "MQTT Text"  // TODO - map to specific capabilities using xType rather than a general text device - build custom attribute for Dashboard attribute template
                               

/*
//  (some of these are not boolean)
//  Acceleration Sensor
//  Button
//  Contact Sensor
//  Dimmer
//  Fan Controller
//  Garage Door Controller
//  Lock
//  Motion Sensor
//  Multi Sensor
//  Omni Sensor
//  Presence
//  RGB Light
//  RGBW Light
//  Switch
//  Temperature Sensor
//  Thermostat
//  audioVolume

		
		nameSpace="hubitat"
		if (dType=="default") devType= "Virtual Omni Sensor"

			// problem (eg comfort_alarm_tamper)
			// '   '  occasionally a binary_sensor includes no device_class (e.g. C-Bus Gateway IP reachable) so this would never get created
        

None: Generic on/off. This is the default and doesnt need to be set.
battery: On means low, Off means normal
cold: On means cold, Off means normal
connectivity: On means connected, Off means disconnected
door: On means open, Off means closed
garage_door: On means open, Off means closed
gas: On means gas detected, Off means no gas (clear)
heat: On means hot, Off means normal
light: On means light detected, Off means no light
lock: On means open (unlocked), Off means closed (locked)
moisture: On means moisture detected (wet), Off means no moisture (dry)
motion: On means motion detected, Off means no motion (clear)
moving: On means moving, Off means not moving (stopped)
occupancy: On means occupied, Off means not occupied (clear)
opening: On means open, Off means closed
plug: On means device is plugged in, Off means device is unplugged
power: On means power detected, Off means no power
presence: On means home, Off means away
problem: On means problem detected, Off means no problem (OK)
safety: On means unsafe, Off means safe
smoke: On means smoke detected, Off means no smoke (clear)
sound: On means sound detected, Off means no sound (clear)
vibration: On means vibration detected, Off means no vibration (clear)
window: On means open, Off means closed
*/
    	// TODO Check over and add more colour bulbs etc ?
        if (dType=="default") devType= "Virtual Omni Sensor"
        else if (dType=="None") devType= "Virtual Contact Sensor"
        else if (dType=="acceleration") devType= "Virtual Acceleration Sensor"
        else if (dType=="audioVol") devType= "Virtual audioVolume"
        else if (dType=="battery") devType= "Virtual Omni Sensor"  // TODO THIS is wrong 
        else if (dType=="button") devType= "Virtual Button Sensor"    
        else if (dType=="cold") devType= "Virtual Contact Sensor"
		else if (dType=="connectivity") devType= "Virtual Contact Sensor"
        //else if (dType=="deviceTracker") devType= "Virtual Contact Sensor"
        else if (dType=="door") devType= "Virtual Contact Sensor"
        else if (dType=="garage_door") devType= "Virtual Garage Door Controller"
        else if (dType=="gas") devType= "Virtual Contact Sensor"
		else if (dType=="heat") devType= "Virtual Contact Sensor"
        else if (dType=="humidity") devType= "Virtual Humidity Sensor"
        else if (dType=="illuminance") devType= "Virtual Illuminance Sensor"   
		else if (dType=="light") devType= "Virtual Switch"		
        else if (dType=="lock") devType= "Virtual Lock Sensor"
        //else if (dType=="moisture") devType= "Virtual Multi Sensor"  // check as overly complex
        else if (dType=="moisture") devType= "Generic Component Water Sensor"  
        else if (dType=="motion") devType= "Virtual Motion Sensor"
		else if (dType=="moving") devType= "Virtual Acceleration Sensor"
        else if (dType=="occupancy") devType= "Virtual Presence"
        else if (dType=="opening") devType= "Virtual Contact Sensor"
        else if (dType=="plug") devType= "Virtual Switch"
        else if (dType=="power") devType= "Virtual Switch"
        else if (dType=="presence") devType= "Virtual Presence" 
        else if (dType=="pressure") devType= "Virtual Omni Sensor"    
		else if (dType=="problem") devType= "Virtual Omni Sensor"  //TODO
		else if (dType=="safety") devType= "Virtual Contact Sensor"
		//else if (dType=="smoke") devType= "Virtual Contact Sensor"
        else if (dType=="smoke") devType= "Generic Component Smoke Detector"
		else if (dType=="sound") devType= "Virtual audioVolume"  // check think this is not boolean
        else if (dType=="temperature") devType= "Virtual Temperature Sensor"  // check think this is not boolean    
        //else if (dType=="vibration") devType= "Virtual Motion Sensor"
        else if (dType=="vibration") devType= "Generic Glass Break Detector"
        else if (dType=="window") devType= "Virtual Contact Sensor"
		else log (name + " found no device type mapping for " + dType + '  ' +  devType,"ERROR")
	}
	
	
	// ######  This is where to add additional device types and their matching driver ######
			 
	else {
			log ("Skipping creating device " + name +" as no type yet for " + type, "WARN")
			return
	}
			
		//log ("Creating type " + type + " as  + ("+ dType +") " + devType + " named MQTT:" + name + " " + friendlyName, "DEBUG")
		//mqtt.createChild(name)  // This was to create device as driver child
		def pfix = ""

	
		try {   
				childDevice = addChildDevice(nameSpace, devType, prefix+name, null,[completedSetup: true, label: pfix + friendlyName])
				child=getChildDevice(prefix+name)  //hmm seems childDevice is not a device object 
			    if (child == null) log ("Child was never created" + prefix+name , "ERROR")
			    else log ("Created Child device with label "+ child.label,"INFO")
			    atomicState.count++			
			    childrenCount = getChildDevices().size()		
				if (system=='homie'){
					child.setStateTopic('homie/'+atomicState.homie+'/'+name+'/onoff')
					child.setStateCmdTopic('homie/'+atomicState.homie+'/'+name+'/onoff')
				}
				else if (system=="HA"){
					if (type == 'sensor') {  // no command topic
						child.setStateTopic(atomicState.HA+'/sensor/'+name+'/state')
					}
					else if (type == 'group') {
						child.setStateTopic(atomicState.HA+'/group/'+name+'/state')
						child.setStateCmdTopic(atomicState.HA+'/group/'+name+'/state/cmd')
					}
					else {
						child.setStateTopic(atomicState.HA+'/switch/'+name+'/state')
						child.setStateCmdTopic(atomicState.HA+'/switch/'+name+'/state/cmd')
						 }
				}
                else if (system=="Shelly"){
                    if (name[-7..-1] == "relay 0") sTopic = '/relay/0'
                    else if (name[-7..-1] == "relay 1") sTopic = '/relay/1'
                    else sTopic="/unknown/"
                        // uses on off
                   		child.setStateTopic('shellies/'+name+sTopic)
						child.setStateCmdTopic('shellies/'+name+sTopic+'/command') 
                }
                else if (system=="Sonoff"){ 
                    log ("Sonoff not yet implemented","ERROR")
                }
				else if (system=="internal"){  // was setting state topics but now not child devices
				}
				if (type=='dim') {
					if (system=="homie"){
						child.setLevelTopic('homie/'+atomicState.homie+'/'+name+'/dim')
						child.setLevelCmdTopic('homie/'+atomicState.homie+'/'+name+'/dim/set')
						child.setMaxBrightness('1')
					}
					else if (system=="HA"){
						child.setStateTopic(atomicState.HA+'/light/'+name+'/state')  //overwrite the switch entries
						child.setStateCmdTopic(atomicState.HA+'/light/'+name+'/state/cmd')	 
						child.setLevelTopic(atomicState.HA+'/light/'+name+'/brightness') //0-255 in HA ?
						child.setLevelCmdTopic(atomicState.HA+'/light/'+name+'/brightness/cmd')
						child.setMaxBrightness('255') 
					}
					if (type=='sensor') {
						log  ("############ Problem child is " + child.device.typeName, "WARN")
						if (child.typeName=="MQTT Dimmer" || child.typeName=="MQTT Switch" ){  // think must be my driver here
						child.setValue ("")  //TODO no good if not my device driver
					}
					}
			}
			child.setType(system)  // identify as a discovered device
		} catch(Exception ex) {
			log ("addChild/topics failed for " +name + " " +(ex.toString()), "ERROR")
		}
	  advertiseChild()
}

def advertiseChild(){
	return  // These will be 'discovered' devices so not onwardly advertising them or publishing states (may revisit again later)
	log ("### TODO ####   Update MQTT with states for ${name} and also advertise to HA","WARN")
	//HADiscoveryAdvertise()
}

def devSummary() {
	log ("==================================================", "INFO")
	log ("    ${atomicState.MQTTOnOffDevices} Hubitat switch devices enabled on MQTT", "INFO")
	log ("    ${atomicState.MQTTDimDevices} Hubitat dimmer devices enabled on MQTT", "INFO")
	log ("    ${atomicState.adhocDevices} Hubitat virtual devices synched to MQTT", "INFO")
    log ("    ${atomicState.MQTTLockDevices} Hubitat lock devices enabled on MQTT", "INFO")
	log ("    ${atomicState.MQTTRGBc} Hubitat RGB control devices synched to MQTT", "INFO")
	log ("    ${atomicState.MQTTRGBt} Hubitat RGB temperature devices synched to MQTT", "INFO")
    if (settings?.ShellyDiscovery){
        log ("    Discovered ${atomicState.ShellyDevices.size()} Shelly relay devices", "INFO")
    }
    if (settings?.SonoffDiscovery){
        log ("    Discovered ${atomicState.SonoffDevices.size()} Sonoff devices", "INFO")
    }
	if (settings?.homieDiscovery){
		log ("    Discovered ${atomicState.onoffDevices.size()} homie onoff devices", "INFO")
        log ("    Discovered ${atomicState.dimDevices.size()} homie dim devices", "INFO")
		log ("    Discovered ${atomicState.sensorDevices.size()} homie sensor devices", "INFO")
        log ("    Discovered ${atomicState.buttonDevices.size()} homie button devices", "INFO")
        log ("    Discovered ${atomicState.lockDevices.size()} homie lock devices", "INFO")
	}
	if (settings?.HAStatestream) {
		log ("    Discovered ${atomicState.HASwitchDevices.size()} HA switch devices", "INFO")
		log ("    Discovered ${atomicState.HALightDevices.size()} HA light devices", "INFO")
		log ("    Discovered ${atomicState.HASensorDevices.size()} HA sensor devices", "INFO")
		log ("    Discovered ${atomicState.HABinarySensorDevices.size()} HA binary sensor devices", "INFO")
		log ("    Discovered ${atomicState.HAInputBooleanDevices.size()} HA input boolean devices", "INFO")
		log ("    Discovered ${atomicState.HAGroupDevices.size()} HA groups", "INFO")
        log ("    Discovered ${atomicState.HAPresenceDevices.size()} HA persons", "INFO")
        log ("    Discovered ${atomicState.HALockDevices.size()} HA locks", "INFO")
        log ("    Discovered ${atomicState.HAClimateDevices.size()} HA climate devices", "INFO")
        log ("    Discovered ${atomicState.HADeviceTrackerDevices.size()} HA device trackers", "INFO")
        log ("    Discovered ${atomicState.HACoverDevices.size()} HA cover devices", "INFO")
	}
	log ("================== Startup complete ==================", "INFO")
	//mqtt.setStateVar ("MQTTmyStatus","present") // This is now showing MQTT Broker connected rather than startup complete.
	atomicState.started=true
    atomicState.abort=false // can't abort anymore
	if (settings?.homiePublish) mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','ready',1,true) //TODO This can happen much sooner
}

def clearDevices() {
	atomicState.onoffDevices=[]
	atomicState.dimDevices=[]
    atomicState.buttonDevices=[]
    atomicState.sensorDevices=[]
    atomicState.lockDevices=[]
    atomicState.ShellyDevices=[]
    atomicState.SonoffDevices=[]
}

def sendPayload(topic,payload) {
	if (payload==null) {
		log ("Null payload for topic " + topic, "WARN")
		return
	}
	if (topic==null) {
		log ("Null topic for payload " + payload, "WARN")
		return
	}
	log ("Send MQTT " + topic + " " + payload, "TRACE")
	mqtt.publishMsg (topic,payload,1,settings?.homieStatesPersist)
}


/*

DONE:
Preliminary customisation for onoff vs switch cmd set etc
Fixed set support in Hubitat topics (colour, dimmer, onoff)
Bugfixes in count
Startup speed tweaks (still to improve based on # devices)
Fixed HA control
Fixed erratic UI popup options
Fixed alphabetic list sort
Expanded discovery from statestream 
Sensors display units in HA discovery

TODO:
Errors still in omni and multi driver - and sensor devices into HE
Sort HADiscovery timing relative state reporting ~ semi OK now
States before discovery
Sensors check over  
Ongoing .. customisation of topic names/states
Review TODOs in code
Color hsv not settable from Hubitat topic


ISSUES:
Not removing devices when disabled
Currently adding devices to publish from HE > MQTT needs restart of app to add to HA discovery and state announcement on MQTT
(May be able to achieve this without restart)
colour temp not sent to HA
unicode 16 support for sensor units
Identify virtual devices to block cascades
Filter out entries in dropdowns so that HE virtual devices don't show
maxLevels with decimal points are not handled completely. This may impact homie discovery and scaling of level devices
No current recovery after an MQTT disconnect although have never seen one. Subscriptions are lost and the app needs restarting.
Need to consider automatic restart or reconnect with a retained list of all subs.

FUTURE:
Support multiple homie devices
Support multiple HA's
HE incoming HA discovery ...? Don't support ?

*/
