/*
 
  Copyright Kevin Hawkins 2019     apps@ukusa.co.uk

  RESTRICTED LICENCE:
  See associated licence file.
  By usage of this application you accept the terms of the licence.
  Currently no part of this code may be copied, redistributed, altered or used in any way without my express written/email permission.
  This code may be installed for the express purpose of testing and reporting issues. You may also
  alter and adapt this code for your own personal useage, but it may not be onwardly distributed to anyone in any form,  or portions used in any other available application.
  My current intention is to relax the terms of this licence upon general release.

  No representation of any form is made to the suitability of this code or it's fitness for any purpose at all. Use entirly at your own discretion and risk . No liability accepted.

  Logging code was adapted from Eric Vitale's ST LIFX application, with thanks.  Copyright 2016 ericvitale@gmail.com

  Many thanks for contributions from Casey, Jeff, Cody, Kirk, Andy and more. Much appreciated.

  Support via Hubitat community beta threads
  https://community.hubitat.com/t/beta-mqtt-app/32750
  You can contact me via PM on that forum  @kevin

  Bug reports to this GitHub repository please (issues)

*/

/* #########################################################################################################

  This application is provided free of charge .. enjoy. 

  Should you wish you can help keep me awake longer via this link

  https://www.buymeacoffee.com/xAPPO
  or paypal@ukusa.co.uk
  
  Many thanks .. much appreciated

   ######################################################################################################### */

import java.security.MessageDigest
//import groovy.json.JsonSlurper

definition(
	name: "MQTT",
	namespace: "ukusa",
	author: "Kevin Hawkins",
	importUrl: "https://raw.githubusercontent.com/xAPPO/MQTT/beta3/MQTT%20app",
	description: "Links MQTT with HE devices",
	category: "Intranet Connectivity",
	iconUrl: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches.png",
	iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png",
    installOnOpen: true,
	iconX3Url: "https://s3.amazonaws.com/smartapp-icons/Convenience/App-BigButtonsAndSwitches@2x.png"
)


preferences {  // can't use atomicState vars in this section

			//page(name: "Configuration", title: "<h2><b>MQTT</b></h2>", nextPage: "vMQTT", uninstall: false, hideable: true,hideWhenEmpty: true){
            page(name: "configuration", title: "<h2><b>MQTT</b></h2>",install: true, uninstall: true, hideable: true,hideWhenEmpty: true){
            section ("<b>MQTT Broker</b>", hideable: true, hidden: true){
				//createMQTTclient()
                //input "mqtt2", "device.MQTTClient", required: false, multiple: false, title: ""
                //input "mqtt", "device.MQTTClient", required: false, multiple: false, title: "<b>MQTT Broker</b>", submitOnChange: false
				input name: "hubName",  type: "text", title: "<b>Hub Name</b>", description: "  choose a unique name for this Hubitat Hub", required: true, displayDuringSetup: true, submitOnChange: false
		        input name: "MQTTBroker", type: "text", title: "<b>MQTT Broker Address</b>&nbsp&nbsp&nbsp&nbsp&nbsp prefixed tcp://...", description: "e.g. tcp://192.168.1.17:1883  - NB you must include tcp://...", required: true, displayDuringSetup: true
		        input name: "username", type: "text", title: "<b>MQTT Username</b>", description: "(leave blank if none)", required: false, displayDuringSetup: true
		        input name: "password", type: "password", title: "<b>MQTT Password</b>", description: "(leave blank if none)", required: false, displayDuringSetup: true
                //input "newMQTTDev", "button", title: "Create MQTT broker device driver", textColor: "green"
            }

			section ("<b>Configuration</b>", hideable: true, hidden: true) {
				input "mqttRemoveDevices", "bool", title: "<b>Purge Discovered Devices</b><br> WARNING: Setting this will delete all your 'discovered devices' when you click 'Done'. However your selected devices from HA and homie discovery will be re-added automatically when app is run again but you will need to re-add them manually in your Dashboards. Your selected 'published' devices and any manually created 'ad-hoc' devices will not be affected", required: true, defaultValue: false, submitOnChange: false
				input "WipeDevices", "bool", title: "Forget enabled devices;  Warning you will have to manually re-enable your devices for export and import from MQTT", submitOnChange: false
				input "logging", "enum", title: "<b>Log Level</b>", required: false, defaultValue: "INFO", options: ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "DISABLED"]
				input "tempUnits", "enum", title: "<b>Temperature units</b>", required: false, defaultValue: "Celsius x.xx°C", options: ["Celsius x.xx°C", "Celsius x.x°C", "Fahrenheit °F","Fahrenheit x.x°F"]
				input "lengthUnits", "enum", title: "<b>Length units (not yet functional)</b>", required: false, defaultValue: "Metric (mm,m,km)", options: ["Metric (mm,m,km)", "Imperial (inches/feet/miles)"]
                input "allowMqttUnlock", "bool", title: "<b>Allow Unlock via MQTT</b><br>WARNING: Setting this will allow unlocking locks via MQTT.  It is recommended that your MQTT instance requires username/password & is protected by SSL", required: false, defaultValue: false, submitOnChange: false
                input "allowHSMDisarm", "bool", title: "<b>Allow HSM disarm via MQTT</b><br>WARNING: Setting this will allow HSM disarm via MQTT, provided 'Allow HSM control' is ON", required: false, defaultValue: false, submitOnChange: false
                input "allowHSMControl", "bool", title: "<b>Allow HSM control via MQTT</b><br>WARNING: Setting this will allow all HSM control via MQTT (except disarming if 'Allow HSM disarm' is OFF)", required: false, defaultValue: false, submitOnChange: false
                input "mqttKeypadMode", "enum", title: "<b>Allow Keypad control and specify when a code is needed</b><br>WARNING: Setting this will allow controlling Keypade code via MQTT.  It is recommended that your MQTT instance requires username/password & is protected by SSL", required: false, defaultValue: "No control of keypad", options: ["No control of keypad", "No Keycode needed", "Keycode to Arm only","Keycode to Arm/Disarm"]
				input name: "mqttKeypadCode", type: "text", title: "Keypad Code", description: " Code to be used via HA", submitOnChange: false, required: false
            }
                
            section ("<b>MQTT Publish Formats</b>", hideable: true, hidden: true){
				//input "HEBasic", "bool", title: "<b>Hubitat basic MQTT</b>", required: true, defaultValue: false, submitOnChange: false 
				input "homiePublish", "bool", title: "<b>homie 3 protocol</b>", required: true, defaultValue: true, submitOnChange: false
                input "minHomie", "bool", title: "<b>Complete & compliant homie topics</b>", required: true, defaultValue: true, submitOnChange: false
				input "homieStatesPersist","bool",title: "<b>&nbsp&nbsp&nbsp&nbsp... retain homie states</b>", required: false, defaultValue: true, submitOnChange: false
				input "HADiscovery", "bool", title: "<b>Home Assistant MQTT discovery protocol (requires homie3 publish enabled)</b>", required: true, defaultValue: false, submitOnChange: false 	
				input name: "HADiscoveryTopic",  type: "text", title: "<b>Home Assistant Discovery Topic</b>", description: "  as configured in HA", required: false, displayDuringSetup: true, submitOnChange: false
				input "HARemember", "enum", title: "<b>Home Assistant MQTT discovered devices</b>", required: false, defaultValue: "Remember",options: ["Forget", "Remember"], submitOnChange: false			    
            }
                
            section ("<b>Discovery into HE</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                 href(name: "href2",
                 title: "Discovery Protocols",
                 required: false,
                 page: "discovery")
            }

                
            section ("<b>Virtual Devices</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                 href(name: "href",
                 title: "HE Virtual devices associated with arbitrary MQTT topics",
                 required: false,
                 page: "vMQTT")
            }
                
			section ("<b>Publish these device capabilities to MQTT</b>",hideWhenEmpty: true, hideable: true, hidden: true) {
                input "modes", "bool", title: "Mode changes", required: false
                input "hsm", "bool", title: "Hubitat Security Monitor", required: false
                input "everything", "capability.*",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Everything (all capabilities/attributes a selected device supports)</b>", submitOnChange: false
                input "alarms", "capability.alarm",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Alarms</b>", submitOnChange: false
            //  input "actuators", "capability.actuator",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Actuators</b>", submitOnChange: false  
                input "batterysensors", "capability.battery",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Battery sensors</b>", submitOnChange: false
                input "bulbs", "capability.bulb",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Bulbs</b>", submitOnChange: false  
                input "buttons", "capability.button",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons</b>", submitOnChange: false  
                input "buttonshold", "capability.holdableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons holdable</b>", submitOnChange: false
                input "buttonspush", "capability.pushableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons pushable</b>", submitOnChange: false 
                input "buttonsrelease", "capability.releasableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons releasable</b>", submitOnChange: false
                input "buttonsdtap", "capability.doubleTapableButton",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Buttons double tapable</b>", submitOnChange: false
                input "carbonmonoxidesensors", "capability.carbonMonoxideDetector",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Carbon monoxide detectors</b>", submitOnChange: false
                input "chimes", "capability.chime",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Chimes</b>", submitOnChange: false               
                input "colour", "capability.colorControl",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour control light devices</b>", submitOnChange: false
				input "colourT", "capability.colorTemperature",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour temperature light devices</b>", submitOnChange: false
                input "colourMode", "capability.colorMode",hideWhenEmpty: true,multiple: true, required: false, title: "<b>Colour Mode devices</b>", submitOnChange: false
                input "contactsensors", "capability.contactSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Contact sensors</b>", submitOnChange: false
                input "dimmers", "capability.switchLevel",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Dimmers</b>", submitOnChange: false
				input "garagedoors", "capability.garageDoorControl",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Garage Door</b>", submitOnChange: false  
                input "humiditysensors", "capability.relativeHumidityMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Humidity sensors</b>", submitOnChange: false
				input "illuminancesensors", "capability.illuminanceMeasurement",hideWhenEmpty: false, multiple: true, required: false, title: "<b>Illuminance sensors</b>", submitOnChange: false
                input "keypads", "capability.securityKeypad",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Keypads</b>", submitOnChange: false
                input "locks", "capability.lock",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Locks</b>", submitOnChange: false  //Casey
                input "lights", "capability.light",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Lights</b>", submitOnChange: false  //Casey
				input "motionsensors", "capability.motionSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Motion sensors</b>", submitOnChange: false
                input "mqtttext", "capability.telnet",hideWhenEmpty: true, multiple: true, required: false, title: "<b>MQTT Text</b>", submitOnChange: false
                input "musicplayers", "capability.musicPlayer",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Music Players</b>", submitOnChange: false
                input "outlets", "capability.outlet",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Outlets</b>", submitOnChange: false
                input "powersensors", "capability.powerMeter",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Power sensors</b>", submitOnChange: false
				input "presencesensors", "capability.presenceSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Presence sensors</b>", submitOnChange: false
                input "refresh", "capability.refresh",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Refresh (not yet functional)</b>", submitOnChange: false  //Casey
                input "relayswitches", "capability.relaySwitch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Relay Switches</b>", submitOnChange: false
                input "sensors", "capability.sensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Sensors</b>", submitOnChange: false  
                input "shocksensors", "capability.shockSensor",hideWhenEmpty: true, title: "<b>Shock sensors</b>", multiple: true, required: false
                input "smokesensors", "capability.smokeDetector",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Smoke detectors</b>", submitOnChange: false
                input "speechsynthesis", "capability.speechSynthesis",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Speech Synthesis</b>", submitOnChange: false
                input "switches", "capability.switch",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Switches</b>", submitOnChange: false
                input "tempsensors", "capability.temperatureMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Temperature sensors</b>", submitOnChange: false
				input "thermostats", "capability.thermostat",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Thermostats</b>", submitOnChange: false
                input "valves", "capability.valve",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Valves</b>", submitOnChange: false 
                input "globVars", "device.VirtualOmniSensor", required: false, title: "<b>Global Variables</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                input "gVars", "device.RMConnectorVariable", required: false, title: "<b>New Global Vars</b>",hideWhenEmpty: true, multiple: true, submitOnChange: false
                //input "variables", "device.VirtualOmniSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Variables</b>", submitOnChange: false 
                input "voltagesensors", "capability.voltageMeasurement",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Voltage sensors</b>", submitOnChange: false
                input "watersensors", "capability.waterSensor",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Water Sensors</b>", submitOnChange: false
                input "windowshades", "capability.windowShade",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Window Shades</b>", submitOnChange: false
                input "listAll", "capability.*",hideWhenEmpty: true, title: "<b>List devices Capabilities and Attributes to Hubitat Topic</b>", multiple: true, required: false
                //input "lots", "capability.switch", title: "Lots", multiple: true
                //TODO add remaining sensors type (as and if requested)
   
			}	
		}

    //page(name: "vMQTT", nextPage: "discovery")  
    page(name: "vMQTT", nextPage: "configuration")  
	//page(name: "discovery", title: "Select MQTT discovered devices",nextPage: "vMQTT", install: true, uninstall: true)
    page(name: "discovery", title: "Select MQTT discovered devices",nextPage: "configuration")
}


def vMQTT() {
    //dynamicPage(name: "vMQTT", title: "<h2><b>Virtual MQTT Devices and Data</b></h2>(optional)", nextPage: "discovery") {
      dynamicPage(name: "vMQTT", title: "<h2><b>Virtual MQTT Devices and Data</b></h2>(optional)", nextPage: "configuration") {
        atomicState.vList=["RM Connector Variable", "MQTT Text", "Virtual audioVolume", "Virtual Button","Virtual CO Detector", "Virtual Color Temperature Light", "Virtual Contact Sensor", "Virtual Dimmer", "Virtual Fan Controller", "Virtual Garage Door Controller", "Virtual Humidity Sensor", "Virtual Illuminance Sensor", "Virtual Lock", "Virtual Moisture Sensor", "Virtual Motion Sensor", "Virtual Multi Sensor", "Virtual Omni Sensor", "Virtual Presence", "Virtual RGB Light", "Virtual RGBW Light", "Virtual Shade","Virtual Smoke Detector", "Virtual Switch", "Virtual Temperature Sensor", "Virtual Thermostat"  ]
        //atomicState.attList=[:]
        //def attmap = ['acceleration':'active|inactive','contact':'open|closed', 'water':"wet|dry"]
        section {
          //input "resetMappings", "button", title: "Reset Mappings", textColor: "red"
          input "virtuals", "capability.virtual",hideWhenEmpty: true, multiple: true, required: false, title: "<b>Virtual Devices</b>", submitOnChange: false
          input(name: "capability", type: "enum", title: "Device Type",description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.vList)
        }  
        //atomicState.attList=[]
        attList=[]
        //atomicState.edit=false
        
        
/*                        
List myDeviceList = []
lots.each { myDevice ->
  if(myDevice.name != 'xyz') {
     myDeviceList.add(myDevice.id)
  }
}      
switches.each { myDevice ->
  if(myDevice.name != 'xyz') {
     myDeviceList.add(myDevice.id)
  }
}       
dimmers.each { myDevice ->
  if(myDevice.name != 'xyz') {
     myDeviceList.add(myDevice.id)
  }
}
carbonmonoxidesensors.each { myDevice ->
  if(myDevice.name != 'xyz') {
     myDeviceList.add(myDevice.id)
  }
}                
app.updateSettingWithType("lots", myDeviceList, "capability")
*/      
        
        
        //app.removeSetting(var)
       // atomicState.Mappings=[:]
        if (atomicState.Mappings==null) atomicState.Mappings=[:]
/*    // No longer used ??? TODO check    
        for (i=0; i < atomicState.vList.size(); i++) {            //this loops through all the HE virtual drivers (names held in vList)           
                def String varCap2="var_" + atomicState.vList[i].replaceAll("\\s","")
            MQTTvirt = settings[varCap2]
            if (MQTTvirt != null){ 
            MQTTvirt.each { dev -> 
                data2=dev.getData()
                if ((data2['mqtt']=="true")||(data2['mqtt']=="enabled")) {   // these are the MQTT enabled devices for this driver type
                data2.each { key, value ->                  
                if ((value != null) && (value != "") && (value != " ")) {
                    if (key.endsWith ("_Topic")) {                        
                        localMap=atomicState.Mappings    
                        localMap.put (value, dev.deviceNetworkId)
                        atomicState.Mappings=localMap
                    }
                 // } 
               }

                //Map Invert = data2.collectEntries { e -> [(e.value): e.key] }
                }
                }

                log("Original data for $dev.name was $data2 ","DEBUG")
                log ("Complete Topic Mappings are now $atomicState.Mappings", "DEBUG")

	        }   
            }
        }  //end for i loop
*/
        if (capability) {
            def String varCap = "var_" + "${capability}".replaceAll("\\s","")
            sensor=false
            
            settings[varCap].each { virtDev ->
                if (virtDev !=null) virtDev.updateDataValue("mqtt", "enabled")
                log ("Subscribe to events from virtual device $virtDev","KH")
                registerAll (virtDev,0,'auto')
            }
            
            dType = "capability.nowt"
            if (capability.contains("Sensor")||capability.contains("Presence")) sensor=true
            dType="device."+capability.replaceAll("\\s","")           
 //     TODO  iNVESTIGATE IMPACT OF USING NON VIRTUAL DEVICES
            //else if (capability == "All Switches") dType= "capability.switch"
            //else if (capability == "All Dimmers") dType= "capability.switchLevel"
                section {
                 // if (atomicState.tete==null) 
                    atomicState.tete =[]
                    //atomicState.virtList=[]
                    input(name: varCap, type: dType, title: "MQTT enabled $capability devices",description: null, multiple: true, required: false, submitOnChange: true)
              
                }
            
                section {
                    //app.updateSetting("vDev",["none"])
                    app.removeSetting("vDev")
                    
                    input(name: "vDev", type: dType, title: "Edit this $capability device",description: null, multiple: false, required: false, submitOnChange: true)
                    if (vDev == null) {
                        app.updateSetting("vDevName","")
                    input (name: "vDevName",type: "text", title: "... or create a new virtual $capability device called ..." , required: false, submitOnChange: true)

                    if (vDevName != null){
                    atomicState.newDevName=vDevName  // This isn't enough to identify it from an incoming MQTT message - can only identify by topic
                    atomicState.newDevType=capability
                    input "newVDev", "button", title: "Create device $vDevName", textColor: "green"
                    }
                    else atomicState.vDevName=""
                    }
                    else {
                        input "oldVDev", "button", title: "Delete device $vDev", textColor: "red"
//                        input "editVDev", "button", title: "Edit device $vDev", textColor: "blue"
                    }
                    
                }
        }
        atomicState.first=false
        if (atomicState.first) {  // entry from another page
            //atomicState.first=false
        }
        else {
            if (vDev) { // && atomicState.edit) {  // this is the whole page
            
            log ("Selected Device is ${vDev.displayName}  - last was {$atomicState.vDev}","DEBUG")            
            if (vDev.displayName==atomicState.vDev) newDev=false else newDev=true
//            log ("newDev is $newDev","LOG")
          if (newDev) { 
                log("#### Blocking any data updates to device from previous screen ####","INFO")
                atomicState.attList=[]
				temp=atomicState.attList						
				if (vDev.getTypeName()=="RM Connector Variable") temp.add("variable")
                else if (vDev.getTypeName()=="MQTT Text") temp.add("text")
              
                vDev.capabilities.each { cap ->
                    log ("Found $cap in vDev $vDev.displayName","INFO")
                    cap.attributes.each { attr ->
                    log ("Found attribute $attr in $vDev.displayName [$cap]", "WARN")
                    temp.add("${attr}")
               }
          }
		  log ("Attribute list is now $temp","WARN") 
          atomicState.attList=temp											  
		// atomicState.attList now contains every attribute that the newly selected device has	but caution - may not align with attrList=vDev.getSupportedAttributes()	
        // this is because 1) I force text values into atomicState.attList e.g. 'variable' and 'text' and also attrList has ALL (custom) attributes not just those within a capability
                    
        }
          //else log ("Refresh of page with no change of device","KH")  //something changed or F5
            
            section {
                   // input(name: "atts", type: "enum", title: "Device Attributes",description: null, multiple: false, required: false, submitOnChange: true, options: ["Hi","you"])
                }
            atomicState.vDev=vDev.displayName
            dEnabled=null
            try {
                dEnabled = (vDev.getDataValue("mqtt"))
                if (dEnabled==null) {
                    vDev.updateDataValue("mqtt", "default")
                    log ("Updated mqtt to 'default'","WARN")
                    dEnabled="default"
                }
            }        
            catch (e) { 
                   log ("Added and updated mqtt to 'false'","WARN")
                    vDev.updateDataValue("mqtt", "false")
                dEnabled="false"
            }
            

          if (dEnabled=="enabled") {   // don't display if not mqtt enabled                     
                section {
                    temp=atomicState.attList.sort()
                    atomicState.attList=temp
                    //input(name: "atts", type: "enum", title: "Device atomic Attributes",description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.attList)
/*
input(name: "dMode", type: "enum", title: "Method to add device attribute topics",description: null, defaultValue: "Manual", multiple: false, required: true, submitOnChange: true, options: ["Manual", "Assisted from MQTT"]) //, "Create new device"]) 

                    if (dMode=="Assisted from MQTT") assisted=true else assisted=false
*/
assisted=false   // beta2 and beta3 .. disabling this feature temporarily as confusing
                    if (assisted) input (name: "devWildcard", type: "text", title: "Please enter a wildcarded topic encompassing the whole device but no others", submitOnChange: true)
                    if ((assisted) && (devWildcard != null)) {

                        atomicState.dTopic=devWildcard
                        atomicState.devTopics = (atomicState.devTopics != null)?atomicState.devTopics:[]
                        input "topics", "button", title: "Get device topics from MQTT for ${devWildcard}"

                        input "deviceTopics", "enum", multiple: false, title: "<b>MQTT discovered topics within ${devWildcard} device</b>", options: atomicState.devTopics.sort()
                        if (!sensor){
                            input(name: "cmdSuffix", type: "text", title: "Command suffix for topics eg /set or /cmd", required: false, submitOnChange: true)
                        }
                    
                    }
               } //end section
            atomicState.devTopics = (atomicState.devTopics != null)?atomicState.devTopics:[]
            temp2=atomicState.devTopics
            for (i=0; i < temp2.size(); i++) {
                temp2[i]=temp2[i]+ "${cmdSuffix}"
            }
             
      section {  //data value update section                   
        for (i = 0; i < atomicState.attList.size(); i++) { // loops for every attribute device has                                                               
                        def String var = "var" + "${i}"
                        def String varCmd = "varCmd" + "${i}" 
                        def String varAtt = "varAtt" + "${i}"
                        //def String varJSON = "varJSON" + "${i}"
            
                        // TODO Check - if this is a new device what happens
                        // Purge previous device settings
                        //log ( "var is " + var + " and attribute is  "+ atomicState.attList[i],"LOG")
                         try {
                            data=vDev.getDataValue("${atomicState.attList[i]}_Topic")   
                             if (newDev)  app.updateSetting (var,data)
                             
                            dataAtt=vDev.getDataValue("${atomicState.attList[i]}_MAP") 
                             log ("Recovered data for map $i $dataAtt","LOG")
                             if (newDev)  app.updateSetting (varAtt,dataAtt)
                            //dataJSON=vDev.getDataValue("${atomicState.attList[i]}_JSON")
                            // if (newDev)  app.updateSetting (varJSON,dataJSON)  //could be null

                         }
                         catch (e) {
                             log ("No state for $i","DEBUG")
                          } 
                        if (!sensor){
                          try {
                            dataC=vDev.getDataValue("${atomicState.attList[i]}_Cmd")   
                            if (newDev) app.updateSetting (varCmd,dataC) 
                          }
                         catch (e) {
                             log ("No cmd for $i","DEBUG")
                          }
                        }
            
                if (!newDev){ // this happens when a data value was updated and the device is redisplayed (it also happens when page two is originally entered too)
                    //app.removeSetting(var)
                    //app.removeSetting(varCmd)
                    //app.removeSetting(varAtt)
                    //app.removeSetting(varJSON)
                        //try {
                            temp=atomicState.topicLink
                            if (temp==null) temp=[:]

                            //log ("Settings for $var is ${settings[var]} ~ ${attList[i]}", "KH")
                            
                            
							if ((settings[var]!=null) && (settings[var]!=data)) {
/*                                
                                log ("  ","KH")
                                log ("[$i] UPDATE device $vDev.name - ${atomicState.attList[i]}_Topic","KH")
                                log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]}_Topic"),"KH")
*/
                                vDev.updateDataValue("${atomicState.attList[i]}_Topic", settings[var].trim())
                                myVal=settings[var].trim()
                                
// #############################  TODO need to strip JSON 
                                
                                
//                                log ("Updating topicLink .. $myVal = $vDev.deviceNetworkId","LOG")                                
                                if (temp.containsKey(myVal)){
                                    list=temp[myVal]       //.add(topic)
                                    if (list.contains("$vDev.deviceNetworkId")) {
                                    }
                                    else {
                                        list.add ("$vDev.deviceNetworkId")
                                        temp["$myVal"]=list 
                                    }
                                }
                                else {
                                    list=["$vDev.deviceNetworkId"]
                                    temp["$myVal"] = list
                                }
//                                log ("[$i] UPDATED on add to $myVal","KH")  //   ${settings[var]}","KH")
                                jas=myVal.indexOf("{")
                                if ((jas>0) && (myVal.endsWith(':}'))){  //strip json
                                            //log ("Strip JSON value $defOne for subscribe" , "KH")
                                            myVal=myVal.substring(0, jas)   
                                }
                                mqtt = getChildDevice("MQTT: Child device driver")
                                if (mqtt!=null) mqtt.subscribeTopic ("$myVal") // // ("${settings[var]}")  
                                                             
//                                log ("  ","KH")
                            }
                            //log ("varAtt is $varAtt ${settings[varAtt]} $dataAtt", "KH")
                            if ((settings[varAtt]!=null) && (settings[varAtt]!=dataAtt)) {
/*                      
                                log ("      ","KH")
                                log ("[$i] UPDATE device $vDev.name - ${atomicState.attList[i]}_MAP","KH")
                                log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]}_MAP"),"KH")

                                log ("[$i] UPDATED to ${settings[varAtt]}","KH")
                                log ("[$i] CHECK " + vDev.getDataValue("${atomicState.attList[i]}_MAP"),"KH")
                                log ("  ","KH")
*/

//TODO THIS IS A TEMPORARY FIX / HACK
//===================================
                               //attrList=vDev.getSupportedAttributes()
                                //if (attrList[i]!=null && attrList[i].dataType =="ENUM") {
                               if (atomicState.attList[i]=='level') {
                               log ("Blocking adding _MAP data for $atomicState.attList[i]","KH")
                                }
                               else {
                                   log ("Updated[$i] " + atomicState.attList[i] +"_Map to" + settings[varAtt].trim(),"LOG")
                                   vDev.updateDataValue("${atomicState.attList[i]}_MAP", settings[varAtt].trim())
                               }
                            }
/*
                            if (settings[varJSON]!=null){
                                String vJSON= settings[varJSON].toString()
                                //if (settings[varJSON]!=dataJSON) {
                                if (vJSON!=dataJSON) {
                                log ("       ","KH")
                                log ("[$i] UPDATE device $vDev.name - ${atomicState.attList[i]}_JSON","KH")
                                log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]}_MAP"),"KH")
                                vDev.updateDataValue("${atomicState.attList[i]}_JSON", vJSON)
                                log ("[$i] UPDATED to $vJSON","KH")
                                log ("[$i] CHECK " + vDev.getDataValue("${atomicState.attList[i]}_JSON"),"KH")                               
                                log ("    ","KH")
                                }
                            }
*/                          
                            
                          if (!sensor) {
                            if ((settings[varCmd]!=null) && (settings[varCmd]!=dataC)) {
                                // ToDo - be able to send a JSON command
                                log ("  ","DEBUG")
                                log ("[$i] UPDATE device $vDev.name - ${atomicState.attList[i]}_Cmd","DEBUG")
                                log ("[$i] UPDATING - from " + vDev.getDataValue("${atomicState.attList[i]}_Cmd"),"DEBUG")
                                vDev.updateDataValue("${atomicState.attList[i]}_Cmd", settings[varCmd].trim())
                                //myVal=settings[varCmd].trim()
                                //log ("myVal cmd $myVal  vDev  $vDev.deviceNetworkId","DEBUG")
                                //temp[myVal] = vDev.deviceNetworkId  //  Don't get incoming messages on Cmd topics
                                log ("[$i] UPDATED to ${settings[varCmd]}","DEBUG")
                                log ("  ","DEBUG")
                                // subscribe this device for all attributes/events
                                log ("Subscribing to events from device $vDev","KH")
                                registerAll (vDev,0,'auto')
                            }  
                         // }
                            }
/*                     }
                        catch (e) {
				            log ("[$i] Device $vDev.displayName doesn't have data for topics "+e ,"WARN")
			            }
*/
                        atomicState.topicLink=temp

                } // not newDev
                        
                        log ("atomicState.devTopics is $atomicState.devTopics","TRACE")  //maybe old - for the last looked up device
                        log ("atomicState.attList is $atomicState.attList","TRACE")
                        
                        if (assisted) {
                            input(name: var, type: "enum", title: "<b> ${atomicState.attList[i]} </b> attribute MQTT status topic", description: null, multiple: false, required: false, submitOnChange: true, options: atomicState.devTopics.sort() + "/sett")
                            if (!sensor) input(name: varCmd, type: "enum", title: "<b> ${atomicState.attList[i]} </b> MQTT command topic", description: null, multiple: false, required: false, submitOnChange: true, options: temp2.sort())
                        }
                        else {
                            if (i==0){
                            defOne=vDev.getDataValue("${atomicState.attList[i]}_Topic")
                            if ((defOne != null)&&(defOne!='')){
                                log ("TODO This is now not a valid topic to use for ID [$i] [$defOne] ","KH")
                                // This is not now viable as one topic can now map to several devices
                                //if (i==0){
                                    try {
                                        jas=defOne.indexOf("{")
                                        if ((jas>0) && (defOne.endsWith(':}'))){
//                                            log ("Strip JSON value $defOne for DNI" , "KH")
                                            defOne=defOne.substring(0, jas ) 
                                        }
                                        //vDev.setDeviceNetworkId("MQTT:virtual_" + defOne )
//                                        log ("$vDev.displayName - Blocked updating DeviceNetworkId with $defOne","KH")
                                    }
                                    catch(e) { 
                                        log ("DNI nametopic [MQTT:virtual_$defOne already exists please choose another: " +e,"ERROR")
                                        dup=getChildDevice("MQTT:virtual_"+defOne)
                                        if  (dup!=null) log ("You already have a HE device [$dup.displayName] mapped to this MQTT topic","ERROR")
                                    }
                                }
                            }
                            //if (i>0) log ("Several state topics for $vDev","DEBUG")
                        }
                            defTwo=vDev.getDataValue("${atomicState.attList[i]}_Cmd")                        
                            input(name: var, type: "text", defaultValue: defOne,title: "<b> ${atomicState.attList[i]} </b> attribute MQTT status topic", description: null, multiple: false, required: false, submitOnChange: true)
                            if (!sensor) input(name: varCmd, type: "text", defaultValue: defTwo, title: "<b> ${atomicState.attList[i]} </b> MQTT command topic", description: null, multiple: false, required: false, submitOnChange: true)         
                      

       //  try {
            
// BUG TOFIX our i values aren't aligned - we might skip attributes
           attrList=vDev.getSupportedAttributes() // why do this when we have atomicState.attList[] - these may not align as this misses 'text and 'varaiable' but includes custom attributes and those not within a capability
           // attrList is an attribute object  atomicState.AttList is a text list of attributes.
           //log.warn atomicState.attList
           //log.warn attrList
            
           if (attrList[i]!=null && attrList[i].dataType =="ENUM") {
               
             String atts = "${attrList[i].getPossibleValues()}" 
               log ("ENUM on " + attrList[i] + " === " +atomicState.attList[i] + " === " + atts, "LOG")
             //if (vDev.getDataValue("${atomicState.attList[i]}_MAP")){
               if (vDev.getDataValue("${attrList[i]}_MAP")){
                // Think I already have this in dataFalse
               //try {dataAtt=vDev.getDataValue("${atomicState.attList[i]}_MAP")} catch(e) {log ("FAIL OFF","WARN")}
                   try {dataAtt=vDev.getDataValue("${attrList[i]}_MAP")} catch(e) {log ("FAIL OFF","WARN")}
                   // if (newDev){                        
                        app.updateSetting(varAtt,dataAtt)
                        defAtt=dataAtt
                   // }
                   
                    //if (atomicState.attList[i] != "level") {  // Need to expand this to other numerics and non binaries
                   if ("${attrList[i]}" != "level") {  // Need to expand this to other numerics and non binaries
                        if (attrList[i].dataType =="ENUM") { 
                        //input(name: varJSON, type: "text", defaultValue: '', title: "JSON {attribute:} name (optional)" , required: false, submitOnChange: false, hideWhenEmpty: true, width: 4)
                        //input(name: varAtt, type: "text", defaultValue: defAtt, title: "&nbsp &nbsp &nbsp &nbsp MQTT payload values for <b>$atts</b> for the <b>${atomicState.attList[i]}</b> attribute" , required: false, submitOnChange: true)// , width: 6)
                       input(name: varAtt, type: "text", defaultValue: defAtt, title: "&nbsp &nbsp &nbsp &nbsp MQTT payload values for <b>${atts.replace(', ',',')}</b> for the <b>${attrList[i]}</b> attribute" , required: false, submitOnChange: true)// , width: 6)

                        }
                        if (!newDev)  {
                            //log ("2a Updating old ${atomicState.attList[i]}_MAP with ${settings[varAtt]} on $vDev.name","KH")
                            //if (settings[varAtt] != null) vDev.updateDataValue("${atomicState.attList[i]}_MAP", settings[varAtt])// $settings?.stateOFF)
                            if (settings[varAtt] != null) vDev.updateDataValue("${attrList[i]}_MAP", settings[varAtt])// $settings?.stateOFF)
                            //log.debug "2b Updating old ${atomicState.attList[i]}_JSON with ${settings[varJSON]} on $vDev.name"
                            //if ((settings[varJSON] != null)&&(settings[varJSON] != ' ')) vDev.updateDataValue("${atomicState.attList[i]}_JSON", settings[varJSON])// $settings?.stateOFF)
                        }
                    }
            }
            else {
                log ("Adding the default value for ${atomicState.attList[i]}_MAP","KH")
                //vDev.updateDataValue("${atomicState.attList[i]}_MAP", atts)
                atts=atts.replace(', ', ',')
                vDev.updateDataValue("${attrList[i]}_MAP", atts.trim())
                log ("Updating with #$atts#  #${atts.trim()}#","WARN")
            }
           } //not ENUM
/*
            if (vDev.getDataValue("${atomicState.attList[i]}_JSON")){
                 try {dataJSON=vDev.getDataValue("${atomicState.attList[i]}_JSON")} catch(e) {log ("FAIL ON","WARN")}
                    //if (newDev){ 
                        if (dataJSON!=null) app.updateSetting(varJSON,dataJSON)
                        defJSON=dataJSON
                //    }
                if (atomicState.attList[i] != "level") {
                     input(name: varJSON, type: "text",defaultValue: defJSON, title: "&nbsp &nbsp &nbsp &nbsp JSON {attribute:} name (optional) for <b>${atomicState.attList[i]}</b> attribute" , required: false, submitOnChange: true)
                    if (!newDev)  {
                        log.debug "3a Updating old ${atomicState.attList[i]}_JSON with ${settings[varJSON]} on $vDev.name"
                        if ((settings[varJSON] != null)&&(settings[varJSON] != ' ')) {
                            vDev.updateDataValue("${atomicState.attList[i]}_JSON", settings[varJSON])
                        }
                    }
                }
            } 
            else {
                log ("Need to add a default value for ${atomicState.attList[i]}_JSON","KH")
                vDev.updateDataValue("${atomicState.attList[i]}_JSON", " ")
            }
*/
        }// end for loop on each attribute (i) 
          //atomicState.edit=false
   } // end data value update section
         try {
            if (vDev.getDataValue("max_Level")){
				app.removeSetting("maxLev")							  
                section {
                    currentMax=vDev.getDataValue("max_Level")
                    if (currentMax != "null") {  //null is a text value
                        app.updateSetting("maxLev",currentMax) 
                        //if (maxLev!=null) currentMax=maxLev
                        if (!assisted) input(name: "maxLev", type: "text",defaultValue: currentMax, title: "Please enter the maximum possible level:" , required: false, submitOnChange: true)
                        else input(name: "maxLev", type: "enum",defaultValue: currentMax, title: "Please enter the maximum possible level:" , required: false, submitOnChange: true,multiple: false, options: atomicState.devTopics.sort())
                        //if (!newDev)  vDev.updateDataValue("max_Level", "$Topic6")
                        if (!newDev)  vDev.updateDataValue("max_Level", settings?.maxLev)                       
                    }
                }
            }
        }
        catch (e) {}
        //atomicState.edit=false      
        } // not enabled for MQTT
              
        }  //if (vDev)

        
            else
                if ($vDev!=null){
                section (title: "This device <b> $vDev </b> is not enabled on MQTT") {       
                }
        } //atomicState.first
                }
        } // end dynamic page    (vDev)          
       //atomicState.edit=false 
    }

//=========================================================================================================================================================================================================================================

def discovery() {  // can use atomicState vars in this section
    //dynamicPage(name: "discovery", title: "", install: true, nextPage:"hrefPage", uninstall: false) {
    //dynamicPage(name: "discovery", title: "MQTT Discovery Protocols", install: true, nextPage: "configuration", uninstall: false) {
    dynamicPage(name: "discovery", title: "MQTT Discovery Protocols", nextPage: "configuration") {
	section ("<h2><b>MQTT Discovery Protocols > HE </b></h2>(optional)"){
		if (settings?.homieDiscovery && settings?.homieDevice!=null) homieEnabled='<font color="green">' else homieEnabled='<font color="darkred">'
		if (settings?.HAStatestream && settings?.HAStatestreamTopic!=null)  HAEnabled='<font color="green">' else HAEnabled='<font color="darkred">'
        if (settings?.SonoffDiscovery)  SonoffEnabled='<font color="green">' else SonoffEnabled='<font color="darkred">'
        if (settings?.ShellyDiscovery)  ShellyEnabled='<font color="green">' else ShellyEnabled='<font color="darkred">'

	}
	atomicState.onoffDevices = (atomicState.onoffDevices != null)?atomicState.onoffDevices:[]
	atomicState.dimDevices = (atomicState.dimDevices != null)?atomicState.dimDevices:[]
	atomicState.sensorDevices = (atomicState.sensorDevices != null)?atomicState.sensorDevices:[]
    atomicState.buttonDevices = (atomicState.buttonDevices != null)?atomicState.buttonDevices:[]
    atomicState.varDevices = (atomicState.varDevices != null)?atomicState.varDevices:[] 
    atomicState.lockDevices = (atomicState.lockDevices != null)?atomicState.lockDevices:[] //Casey
    atomicState.ShellyDevices = (atomicState.ShellyDevices != null)?atomicState.ShellyDevices:[]
    atomicState.SonoffDevices = (atomicState.SonoffDevices != null)?atomicState.SonoffDevices:[]
    atomicState.HAPresenceDevices = (atomicState.HAPresenceDevices != null)?atomicState.HAPresenceDevices:[]
	atomicState.HASwitchDevices = (atomicState.HASwitchDevices != null)?atomicState.HASwitchDevices:[]
	atomicState.HALightDevices = (atomicState.HALightDevices != null)?atomicState.HALightDevices:[]
	atomicState.HASensorDevices = (atomicState.HASensorDevices != null)?atomicState.HASensorDevices:[]
	atomicState.HABinarySensorDevices = (atomicState.HABinarySensorDevices != null)?atomicState.HABinarySensorDevices:[]
	atomicState.HAGroupDevices = (atomicState.HAGroupDevices != null)?atomicState.HAGroupDevices:[]
	atomicState.HAInputBooleanDevices = (atomicState.HAInputBooleanDevices != null)?atomicState.HAInputBooleanDevices:[]
    atomicState.HACoverDevices = (atomicState.HACoverDevices != null)?atomicState.HACoverDevices:[]
    atomicState.HALockDevices =  (atomicState.HALockDevices != null)?atomicState.HALockDevices:[]
    atomicState.HADeviceTrackerDevices = (atomicState.HADeviceTrackerDevices != null)?atomicState.HADeviceTrackerDevices:[]
    atomicState.HAClimateDevices =  (atomicState.HAClimateDevices != null)?atomicState.HAClimateDevices:[]
    atomicState.HAUnknownDevices =  (atomicState.HAUnknownDevices != null)?atomicState.HAUnknownDevices:[]
    atomicState.homieUnknownDevices =  (atomicState.homieUnknownDevices != null)?atomicState.homieUnknownDevices:[]       
    atomicState.MQTTvirtuals = (atomicState.MQTTvirtuals != null)?atomicState.MQTTvirtuals:[]
		numText=''
        numhomieDevs=0  // number of homie devices
		if (atomicState.onoffDevices != null) numhomieDevs+= atomicState.onoffDevices.size()  // these are all homie devices
		if (atomicState.dimDevices != null) numhomieDevs+= atomicState.dimDevices.size()
		if (atomicState.sensorDevices != null) numhomieDevs+= atomicState.sensorDevices.size()
        if (atomicState.lockDevices != null) numhomieDevs+= atomicState.lockDevices.size()  //Casey
        if (atomicState.buttonDevices != null) numhomieDevs+= atomicState.buttonDevices.size()
        if (atomicState.varDevices != null) numhomieDevs+= atomicState.varDevices.size()
        if (atomicState.homieUnknownDevices != null) numhomieDevs+= atomicState.homieUnknownDevices.size()        
        numHADevs=0  // number of homie devices
		if (atomicState.HABinarySensorDevices != null) numHADevs+= atomicState.HABinarySensorDevices.size()  // these are all homie devices
		if (atomicState.HAClimateDevices != null) numHADevs+= atomicState.HAClimateDevices.size()
		if (atomicState.HACoverDevices != null) numHADevs+= atomicState.HACoverDevices.size()
        if (atomicState.HADeviceTrackerDevices != null) numHADevs+= atomicState.HADeviceTrackerDevices.size()  //Casey
        if (atomicState.HAGroupDevices != null) numHADevs+= atomicState.HAGroupDevices.size()
        if (atomicState.HAInputBooleanDevices != null) numHADevs+= atomicState.HAInputBooleanDevices.size()
        if (atomicState.HALightDevices != null) numHADevs+= atomicState.HALightDevices.size() 
        if (atomicState.HALockDevices != null) numHADevs+= atomicState.HALockDevices.size()  //Casey
        if (atomicState.HAPresenceDevices != null) numHADevs+= atomicState.HAPresenceDevices.size()
        if (atomicState.HASensorDevices != null) numHADevs+= atomicState.HASensorDevices.size()                
        if (atomicState.HASwitchDevices != null) numHADevs+= atomicState.HASwitchDevices.size()
        if (atomicState.HAUnknownDevices != null) numHADevs+= atomicState.HAUnknownDevices.size()        
        // TODO add more ? .. test for null redundant
		def numEnabled=0
		if (Homie_onoff!=null) numEnabled += settings?.Homie_onoff.size()
		if (Homie_dim!=null) numEnabled += settings?.Homie_dim.size()
		if (Homie_sensors!=null) numEnabled += settings?.Homie_sensor.size()
        if (Homie_sensors!=null) numEnabled += settings?.Homie_button.size()
        if (Homie_sensors!=null) numEnabled += settings?.Homie_variable.size()
        if (Homie_sensors!=null) numEnabled += settings?.Homie_unknowns.size()
		if (settings?.homieDiscovery){
			if (atomicState.started) numText = "${numEnabled} of ${numhomieDevs} discovered devices enabled"
			else numText="checking"
		}
		else {
			numText="disabled"
		}

		section (homieEnabled+"<b>homie</b>    [${numText}]</font>", hideable: true, hidden: true){
        if (settings?.Homie_onoff != null) ho = settings?.Homie_onoff.size() else ho=0  // Elvis isnt in the house TODO
        if (settings?.Homie_dim != null) hd = settings?.Homie_dim.size() else hd=0
		if (settings?.Homie_sensor != null) hs = settings?.Homie_sensor.size() else hs=0
		if (settings?.Homie_button != null) hb = settings?.Homie_button.size() else hb=0
		if (settings?.Homie_variable != null) hv = settings?.Homie_variable.size() else hv=0
        if (settings?.Homie_lock != null) hl = settings?.Homie_lock.size() else hl=0
        if (settings?.Homie_unknowns != null) hu = settings?.Homie_unknowns.size() else hu=0
    	input "homieDiscovery", "bool", title: "<b>homie 3 protocol<b>", required: true, defaultValue: false, submitOnChange: false
		input name: "homieDevice", type: "text", title: "<b>homie device topic name</b>", description: "... to import devices from", required: false, displayDuringSetup: false
		input "Homie_onoff", "enum", multiple: true, title: "<b>Discovered ${atomicState.onoffDevices.size()} homie switches &nbsp &nbsp &nbsp [^${ho}]</b>", options: atomicState.onoffDevices.sort()
		input "Homie_dim", "enum", multiple: true, title: "<b>Discovered ${atomicState.dimDevices.size()} homie dimmers &nbsp &nbsp &nbsp [^${hd}]</b>", options: atomicState.dimDevices.sort()
		input "Homie_sensor", "enum", multiple: true, title: "<b>Discovered ${atomicState.sensorDevices.size()} homie sensors &nbsp &nbsp &nbsp [^${hs}]</b>", options: atomicState.sensorDevices.sort()
		input "Homie_button", "enum", multiple: true, title: "<b>Discovered ${atomicState.buttonDevices.size()} homie buttons &nbsp &nbsp &nbsp [^${hb}]</b>", options: atomicState.buttonDevices.sort()
        input "Homie_variable", "enum", multiple: true, title: "<b>Discovered ${atomicState.varDevices.size()} homie variables &nbsp &nbsp &nbsp [^${hv}]</b>", options: atomicState.varDevices.sort()
        input "Homie_lock", "enum", multiple: true, title: "<b>Discovered ${atomicState.lockDevices.size()} homie locks &nbsp &nbsp &nbsp [^${hl}]</b>", options: atomicState.lockDevices.sort()
        input "Homie_unknowns", "enum", multiple: true, title: "<b>Discovered ${atomicState.homieUnknownDevices.size()} homie devices that are not supported yet &nbsp &nbsp &nbsp [^${hu}]</b>", options: atomicState.homieUnknownDevices.sort()   
        }

		
	section {}
		numText=''
		numEnabled=0
		// TODO - below line can still error initially ....alpha
		if (HA_Switches!=null) numEnabled = settings?.HA_Switches.size()
		if (HA_Lights!=null) numEnabled += settings?.HA_Lights.size()
		if (HA_Sensors!=null) numEnabled += settings?.HA_Sensors.size()
		if (HA_BinarySensors!=null) numEnabled += settings?.HA_BinarySensors.size()
		if (HA_Groups!=null) numEnabled += settings?.HA_Groups.size()
        if (HA_Presence!=null) numEnabled += settings?.HA_Presence.size()
		if (HA_InputBooleans!=null) numEnabled += settings?.HA_InputBooleans.size()
		if (numEnabled>=0) numText = "${numEnabled} of ${numHADevs} enabled"
		if (settings?.HAStatestream){
		if (atomicState.started) numText = "${numEnabled} of ${numHADevs} discovered devices enabled"
			else numText="checking"
		}
		else {
			numText="disabled"
		}
		section (HAEnabled+"<b>Home Assistant</b>    [${numText}]</font>", hideable: true, hidden: true) {
            if (settings?.HA_Switches != null) HAsw = settings?.HA_Switches.size() else HAsw=0  // Elvis isnt in the house TODO
			if (settings?.HA_Lights != null) HAli = settings?.HA_Lights.size() else HAli=0
			if (settings?.HA_Sensors != null) HAse = settings?.HA_Sensors.size() else HAse=0
			if (settings?.HA_BinarySensors != null) HAbs = settings?.HA_BinarySensors.size() else HAbs=0
			if (settings?.HA_Groups != null) HAg = settings?.HA_Groups.size() else HAg=0
            if (settings?.HA_Presence != null) HAp = settings?.HA_Presence.size() else HAp=0
			if (settings?.HA_InputBooleans != null) HAib = settings?.HA_InputBooleans.size() else HAib=0
            if (settings?.HA_Covers != null) HAco = settings?.HA_Covers.size() else HAco=0
            if (settings?.HA_Locks != null) HAlo = settings?.HA_Locks.size() else HAlo=0
            if (settings?.HA_DeviceTrackers != null) HAd = settings?.HA_DeviceTrackers.size() else HAd=0
            if (settings?.HA_Climates != null) HAcl = settings?.HA_Climates.size() else HAcl=0
		    input "HAStatestream", "bool", title: "Home Assistant statestream", required: true, defaultValue: false, submitOnChange: true 
	    	input name: "HAStatestreamTopic", type: "text", title: "Home Assistant Statestream topic", description: "", required: false, displayDuringSetup: false
	    	input "HA_Switches", "enum", multiple: true, title: "Discovered  ${atomicState.HASwitchDevices.size()} Home Assistant switches &nbsp &nbsp &nbsp [^${HAsw}]", options: atomicState.HASwitchDevices.sort()
		    input "HA_Lights", "enum", multiple: true, title: "Discovered ${atomicState.HALightDevices.size()} Home Assistant lights &nbsp &nbsp &nbsp [^${HAli}]" , options: atomicState.HALightDevices.sort()
		    input "HA_Sensors", "enum", multiple: true, title: "Discovered ${atomicState.HASensorDevices.size()} Home Assistant sensors &nbsp &nbsp &nbsp [^${HAse}]" , options: atomicState.HASensorDevices.sort()
		    input "HA_BinarySensors", "enum", multiple: true, title: "Discovered ${atomicState.HABinarySensorDevices.size()} Home Assistant binary sensors &nbsp &nbsp &nbsp [^${HAbs}]" , options:  atomicState.HABinarySensorDevices.sort()
		    input "HA_Groups", "enum", multiple: true, title: "Discovered ${atomicState.HAGroupDevices.size()} Home Assistant groups &nbsp &nbsp &nbsp [^${HAg}]" , options: atomicState.HAGroupDevices.sort()
            input "HA_Presence", "enum", multiple: true, title: "Discovered ${atomicState.HAPresenceDevices.size()} Home Assistant persons &nbsp &nbsp &nbsp [^${HAp}]" , options: atomicState.HAPresenceDevices.sort()
		    input "HA_InputBooleans", "enum", multiple: true, title: "Discovered ${atomicState.HAInputBooleanDevices.size()} Home Assistant input booleans &nbsp &nbsp &nbsp [^${HAib}]" , options:  atomicState.HAInputBooleanDevices.sort()
		    input "HA_Covers", "enum", multiple: true, title: "Discovered ${atomicState.HACoverDevices.size()} Home Assistant Covers &nbsp &nbsp &nbsp [^${HAco}]" , options:  atomicState.HACoverDevices.sort()
		    input "HA_Locks", "enum", multiple: true, title: "Discovered ${atomicState.HALockDevices.size()} Home Assistant Locks &nbsp &nbsp &nbsp [^${HAlo}]" , options:  atomicState.HALockDevices.sort()
		    input "HA_DeviceTrackers", "enum", multiple: true, title: "Discovered ${atomicState.HADeviceTrackerDevices.size()} Home Assistant Device Trackers &nbsp &nbsp &nbsp [^${HAd}]" , options:  atomicState.HADeviceTrackerDevices.sort()
            input "HA_Climates", "enum", multiple: true, title: "Discovered ${atomicState.HAClimateDevices.size()} Home Assistant Climate Devices &nbsp &nbsp &nbsp [^${HAcl}]" , options:  atomicState.HAClimateDevices.sort()
            input "HA_Unknowns", "enum", multiple: false, title: "Discovered ${atomicState.HAClimateDevices.size()} Home Assistant Devices that are not supported yet &nbsp &nbsp &nbsp [^${HAcl}]" , options:  atomicState.HAUnknownDevices.sort()   
        }
    }
}



def appButtonHandler(btn) {
    mqtt = getChildDevice("MQTT: Child device driver")
    if (btn=="newVDev") {
            createVirtual()   
        }
    else if (btn=="topics") {
        atomicState.devTopics=[]
        mqtt.subscribeWildcardTopic (atomicState.dTopic)
    }
    else if (btn=="commit") {
        log ("updating the topics","TRACE")
             }
    else if (btn=="resetMappings") {
        atomicState.Mappings=[:]
    }
    else if (btn=="oldVDev") {
        deleteChildDevice(vDev.deviceNetworkId)
        log ("Deleted virtual device $vDev","WARN")
    }
    else if (btn=="editVDev") {
        atomicState.edit=true
    }
}

//child
def createMQTTclient() {   //TODO IP username password
    namespace='ukusa'
    log ("FYI your MQTT child devices are ${getChildDevices()} ","INFO")
    childDev=getChildDevice("MQTT: Child device driver")  
    if (childDev == null){ //This is a carryover of the client app not being 'selected' anymore in an input dropdown.
        
        log ("Creating MQTT client child driver" , "INFO")
        try {
            addChildDevice(namespace, "MQTT Client", "MQTT: Child device driver", null,[completedSetup: true,name: "MQTT: Child device driver", logging: false])
            log ("MQTT child client created","INFO")
        }
        catch (e) {
            log ("Problem creating child device " + e, "TRACE")
             } 
        
    	//childDev=getChildDevice("MQTT: Child device driver")  
    	//if (childDev == null) log ("MQTT client child was never created" , "ERROR")
    }
    else log ("MQTT child client already exists","TRACE")
}
//child
def createVirtual () {
    if (atomicState.newDevType == "MQTT Text") namespace = 'ukusa' else namespace = 'hubitat'
    addChildDevice(namespace, "$atomicState.newDevType", "MQTT:virtual_${atomicState.newDevName}", null,[completedSetup: true,name: "${atomicState.newDevName}", logging: false])
	childDev=getChildDevice("MQTT:virtual_${atomicState.newDevName}")  //hmm seems childDevice is not a device object 
	if (childDev == null) log ("Child was never created" + prefix+name , "ERROR")
    else log ("Created Child $atomicState.newDevType with name $atomicState.newDevName","INFO")
    childDev.updateDataValue("mqtt", "manual")
    childDev.updateDataValue("origin", "user")
    if (childDev.typeName.contains("Sensor")||childDev.typeName.contains("Presence")) sensor=true else sensor=false 
        
                    childDev.capabilities.each { cap ->
                    log ("Found $cap in childDev $childDev.displayName","INFO")
                    cap.attributes.each { attr ->
                    log ("Found attribute $attr in $childDev.displayName [$cap]", "INFO")

                        att="$attr"
                        data=att+"_Topic"
                        if ((childDev.getDataValue(data))&&(childDev.getDataValue(data)!=" ")){
                            log ("$childDev.name data $data already exists","DEBUG")
                            if (att=='level') { 
                                if (!childDev.getDataValue("max_Level")) childDev.updateDataValue("max_Level", "100")
                            } 
                        }
                        else {
                            childDev.updateDataValue(data, " ")  // Have to add a space here so that data displays in my editor
                            log ("Adding data $data to $childDev.displayName","INFO")
                            if (att=='level') childDev.updateDataValue("max_Level", "100")
                        }
								   
                        if (!sensor) {
                            data=att+"_Cmd"
                            if ((childDev.getDataValue(data))&&(childDev.getDataValue(data)!=" ")){
                                 log ("$childDev.name data $data already exists","DEBUG")

                            }
                            else {
                               childDev.updateDataValue(data, " ")
                                log ("Adding data $data to $childDev.displayName","INFO")
                            }
                        }
             }   
         }    
         attr2List=childDev.getSupportedAttributes()
         for (j = 1; j < attr2List.size(); j++) {
           if (attr2List[j].dataType =="ENUM") {
               String atts = "${attr2List[j].getPossibleValues()}" 

              if ((childDev.getDataValue("${attr2List[j]}_MAP"))&&(childDev.getDataValue("${attr2List[j]}_MAP")!=" ")){                          
                log ("$childDev.name ${attr2List[j]}_MAP already exists","TRACE")
              }
              else {
                 log ("Adding the default attribute values to ${attr2List[j]}_MAP","KH")
                  atts=atts.trim()
                 childDev.updateDataValue("${attr2List[j]}_MAP", atts.replace(', ', ','))
              }
           }
           else log ("Attribute was not ENUM [${attr2List[j]}] $attr2List[j].dataType", "INFO")
         }	 // end for 
          if (atomicState.newDevType == "MQTT Text") {
              childDev.updateDataValue("text_Topic", "")  // This attribute is not discovered within capability as it is custom
              childDev.updateDataValue("text_Cmd", "")
          }    
}

def installed() {
	log ( "${app.name} Installed","INFO")
    //createMQTTclient() 
	atomicState.topicMap=[:]
	atomicState.nameMap=[:]
    //createMQTTclient() 
	wipe() // also initialises 
	initialize()
    atomicState.appCount=0
}

def updated() {
	log ("${app.name} Updated", "INFO")
	unsubscribe()
    //createMQTTclient() 
    atomicState.count=0
	unschedule()
	initialize()
}

def uninstalled() {
    log ("Deleting all child devices", "WARN")
    wipe()
	removeAllChildDevices()
}



def reStart(evt) {
    log ("===================== ReStart =====================", "INFO")
    unschedule()
    unsubscribe()
	initialize()
}

def initialize() {
    mqtt = getChildDevice("MQTT: Child device driver")
    if (mqtt==null) {
        createMQTTclient() 
        mqtt = getChildDevice("MQTT: Child device driver")
        if (mqtt==null) log ("MQTT client failed to create","ERROR")
    }
    else log ("MQTT Client driver present","INFO")
    atomicState.normHubName = normalize(settings?.hubName)
    log ("Hubitat hub name is : " + settings?.hubName,"INFO")
    if (mqtt==null) {
        log ("FATAL: No MQTT broker configured","ERROR")
    }
    else {
        mqtt.setHubName (normalize(settings?.hubName),settings?.hubName)
        mqtt.setUserName (settings?.username)
        mqtt.setPassword (settings?.password)
        mqtt.setBrokerAddress (settings?.MQTTBroker)
    }
    if (atomicState.appcount==null) atomicState.appCount=0
    log ("initialising with App count ${atomicState.appCount}","INFO")
    def date1 = new Date()
    atomicState.properties=[:]
    atomicState.topicLink=[:]
    //log.e(location.hubs[0].getZigbeeId())
    atomicState.myHub=false
    // This just enables more logging on my own hubs
    myID=MD5(app.getHubUID())
    if (myID=="d36ba7352b7fc675e7314162377a88be") atomicState.myHub=true //41
    else if (myID=="8e703d9adefe69d652315cf6159671b7") atomicState.myHub=true //42
    else if (myID=="e947798518d8f4b041d701d122c38b30") atomicState.myHub=true //44
    else if (myID=="1234") atomicState.myHub=true  //43 TODO UPDATE THIS ONE
//atomicState.myHub=false
    countTry=5
    aborting=false
    atomicState.abort=false  // just added remove later
    //if (atomicState.abortable) atomicState.abort=true  // JUST TO TEST - will abort if still possible
    while (atomicState.abort) {
        log("Awaiting earlier App to abort [$countTry]","WARN")
        aborting=true
        countTry--
            if (countTry < 0) { 
                log ("Continuing.. Given up waiting for earlier app to abort", "WARN")
                atomicState.abort=false
            }
       else pauseExecution(6000)
    }
    if (aborting) log ( "Earler app sucessfully aborted","WARN")
    aborting=false
    atomicState.abort=false
    mqttSubscribes()
    atomicState.MQTTconnected=false
    xtra=0
    for (int i = 0; i < 86 && (atomicState.MQTTconnected==false); i++) {  // tries to reconnect every 10 seconds
        if (i==0)  log ("Waiting for MQTT connection: $atomicState.MQTTconnected","INFO")
        else log ("Waiting another try [$i] until MQTT connected: $atomicState.MQTTconnected","WARN")
        mqtt.reset()
        pauseExecution(10000+xtra)  // initially 10 seconds
        if (i>5) xtra = 20000  // increase to 30 seconds after a minute
        else if (i>24) xtra = 50000  // 1 minute after 10
        else if (i>74) xtra = 590000  // 10 minutes after an hour
        // will currently run for 2 hours    
    }
    if (i>85) {
        log ("MQTT has failed to connect. Restart the app to try again","ERROR")
        return
             }
   
 /*   
    if (!atomicState.MQTTconnected) mqtt.reset()  // Only want to do this once as the driver will continue to attempt reconnects
    countTry=0
    while (!atomicState.MQTTconnected) {
        log("MQTT .. awaiting connection .. [$countTry]","INFO")
        countTry++
            if (countTry > 10) { 
                log   ("Aborting Restart - too many attempts","ERROR")
                return
            }
        pauseExecution(10000)
    }
    log ("MQTT is connected","INFO")

    atomicState.appCount = atomicState.appCount + 1
    log ("There are now ${atomicState.appCount} instances running","INFO")
        if (atomicState.appCount > 1) {
        log ("####### WE HAVE ${atomicState.appCount} instances running ? #######", "WARN")
            log ("Started is ${atomicState.started} and abort is ${atomicState.abort}","WARN") 
            atomicState.appCount = atomicState.appCount - 1
            if (!atomicState.abortable) {
                log ("Cant abort earlier version now so will continue","WARN")
                if (atomicState.started) log ("Earlier version started up completely so will continue","WARN")
            }
            else {
                atomicState.abort=true  // try and kill previous version
            //return // kill this one

                while (atomicState.abort) {
                aborting=true
                log("Awaiting previous App to abort [$countTry]","INFO")
                countTry++
                if (countTry > 10) { 
                    log ("Continuing.. Given up waiting for previous app to abort","WARN")
                    atomicState.abort=false
                }
               else pauseExecution(6000)
            }
            if (aborting) log ( "Previous app sucessfully aborted","INFO")
           }
        }

    unschedule ("reStart")  // stop any others from starting that are already scheduled
*/

    if (settings?.HAStatestream) {
        mqtt.setHAStatestreamTopic(settings?.HAStatestreamTopic)
        atomicState.HA=settings?.HAStatestreamTopic
    }
	if (settings?.HADiscovery) {  // Outgoing HE > HA
		// TODO ensure homie publish or other adequate topic structure is enabled
		if (!settings?.homiePublish) log ("You must enable homie3 publish too for HA Discovery to work correctly","ERROR")
        
		settings?.homiePublish=true    // TODO doesn't work !  settings are r/o - need to use an atomicState var
        atomicState.HA=settings?.HAStatestreamTopic
		mqtt.subscribeTopic(atomicState.HA+'/status') 
	}
    if (!settings?.minHomie) {
		atomicState.suppress = true 
        if (settings?.homiePublish) log("The published homie topic tree has been simplified in content and is no longer homie3 compliant","WARN")
    }
	else atomicState.suppress = false
	log("Initializing...", "DEBUG")
	atomicState.restartPending=false   // TODO check MQTT connected
	atomicState.started=false
    atomicState.abortable=true
	if (atomicState.abort) { 
            abort(1)
            return
    }
	    mqtt.unsubscribeTopic("homie/${state.normHubName}/" +'$fw/name')
        mqtt.unsubscribeTopic("homie/${state.normHubName}/" + '$fw/client')
        mqtt.unsubscribeTopic("homie/${state.normHubName}/" +'$fw/version')																	
											
   
	//if (settings?.homiePublish)
	//{
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','init',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$homie','3.0.1',1,true,atomicState.suppress) 
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$implementation','groovy:uk.co.ukusa.mqtt',1,true,atomicState.suppress)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/version','3',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$fw/name','beta',1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$name',settings?.hubName,1,true)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$mac','BB:AA:DD:AA:55:55',1,true,atomicState.suppress)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$localip','1.2.3.4',1,true,atomicState.suppress)
		mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$implementation/version','beta 3b',1,true,atomicState.suppress)
        if (modes) currentMode()
        if (hsm) currentHSB()
        sunTimes()
	//}

    mqtt.setLogLevel (determineLogLevel(settings?.logging))
	if ((settings?.mqttRemoveDevices == true))
	{
		log ("Deleting all the MQTT child devices", "DEBUG")
		removeAllDiscoveredChildDevices()  // somehow these stay orphaned, so need this or need to create differently
	}
	if (settings?.WipeDevices == true) {
		wipe()
	}
	atomicState.homie=settings?.homieDevice  // setting the homie tree master device topic for discovery
	if (atomicState.abort) { 
            abort(2)
            return
    }
    buildMQTTLookup()  // builds the mapping of device names
    deviceEventSubscribes()   

    atomicState.MQTTvirtuals=temp    
	atomicState.MQTTOnOffDevices=0
	atomicState.MQTTDimDevices=0
    atomicState.MQTTLockDevices=0
	atomicState.adhocDevices=0
	atomicState.MQTTRGBc=0
	atomicState.MQTTRGBt=0
	atomicState.MQTTKEYPADt=0    
    if (atomicState.abort) return
    count=0
    count = sensorSubscribes(count)  // currently registers ALL capabilities and attributes for these sensors from all drop downs TODO change
    count = deviceSubscribes(count)  // currently registers ALL capabilities and attributes for these devices from all drop downs TODO change
    count = everythingSubscribes(count)   // registers ALL capabilities and attributes for these devices
	log ("reinitializing", "TRACE")
	atomicState.createDevices=false
	atomicState.lastDevice=''
	if (settings?.homiePublish) {
		subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/set") // incoming cmds to control HE devices - all types .. or could restrict to supported types
        subscribeOneOffTopics("homie/${atomicState.normHubName}/+/+/+/set") // incoming cmds to control HE devices at sub level eg color/rgb - all types .. or could restrict to supported types
	}
	if (atomicState.abort) { 
            abort(3)
            return
    }	
	synchDevices() // handles all the initial state publications for all enabled devices
    int time=(int) ((now()-atomicState.timeStamp)/1000)
    log ("HE device publishing to MQTT has completed in $time secs ","BLUE")
	if (atomicState.abort) { 
            abort(4)
            return
    }
    
    if(settings?.ShellyDiscovery) {
         subscribeShellyTopic()
         atomicState.delay += 0  //TODO tweak
    }
    if(settings?.SonoffDiscovery) {
        runIn (atomicState.delay, "subscribeSonoffTopic")
        atomicState.delay += 0  //TODO tweak
    }	
	if(settings?.homieDiscovery) {
		runIn(atomicState.delay, "subscribeHomieTopic")
		runIn(atomicState.delay, "subscribeHomieStateTopics")  
        runIn (atomicState.delay, "subscribeHomieNameTopics")
	}
    else {
        log ("Skipping homie MQTT discovery", "INFO")
        if((settings?.HAStatestream)) start_HADiscovery(null)
    }
                
	if (atomicState.abort) { 
            abort(6)
            return
    }
    
    subscribeVirtuals()  // this subscribes to any adhoc virtuals we have created
    schedule("0 1 0 1/1 * ? *", sunTimes)
    log ("Initialize exit", "INFO")  
    if ((!settings?.homieDiscovery) && (!settings?.HAStatestream)) devSummary(null)

    atomicState.abort=false
    atomicState.abortable=false
}

def mqttChange(evt) {  // Currently all types of devices (SWITCH DIMMER CONTACT) come in here
    if (evt.name=='switch') {
        mqtt = getChildDevice("MQTT: Child device driver")
        topic = evt.device.getDataValue("switch_Cmd")

        //khcheck
          jas=topic.indexOf("{")  //JSON
              if ((jas>0) && (topic.endsWith(':}'))){  //strip json
                 //log ("Strip JSON value $defOne for publish" , "KH")
                  json='{"' + topic.substring(jas+1,topic.length()-2) + '":"' + evt.value +'"}'
                  topic=topic.substring(0, jas)   
          }  
            
        if (evt.value == "${evt.device.getDataValue("mqtt_Switch")}") log ("Blocking ${evt.value} command to MQTT ${evt.name} as already ${evt.value}","INFO")
        else {
            mqtt.publishMsg (topic,evt.value,1,false) // this takes no account of the switch_ON and switch_OFF settings - it assumes the /set was correct
        }
    }
    else if (evt.name=='level') {       
        topic = evt.device.getDataValue("level_Cmd")
        maxL= evt.device.getDataValue("max_Level")
        if (maxL == null) newLevel=evt.value
        else newLevel=(maxL.toInteger() * evt.value.toInteger() / 100).toInteger()  // TODO 50% should be 128 to avoid creep
        if (evt.value == "${evt.device.getDataValue("mqtt_Level")}") log ("Blocking ${evt.value} command to MQTT ${evt.name} as already ${evt.value}","INFO")  // WONT WORK as evt.value is scaled and stored isnt TODO  CONVERT
        else mqtt.publishMsg (topic,newLevel.toString(),1,false)
    } 
}    



def abort (where) {
            log ("Abort Initialize $where","WARN")
            unschedule()// This may need removing too
            //unsubscribe()
            atomicState.abort=false
            atomicState.abortable=false
            atomicState.appCount=atomicState.appCount-1    
}

def addProperty(key,value,device=null) {
    //atomicState.properties=[:]
    mqtt = getChildDevice("MQTT: Child device driver")
    def temp=atomicState.properties
    if (temp[key] == null) {
        temp[key] = value
        if (device!=null)   device.updateDataValue("properties", value)
        mqtt.publishMsg (key+'/$properties',"${temp[key]}",1,true)
    }
    else {
        if (temp[key].contains (value)){
            return
        }
    temp[key] = temp[key] + "," + value
    value=temp[key]
    if (device!=null)   device.updateDataValue("properties", value)
    //mqtt.publishMsg (key+'/$properties',"${temp[key]}",1,true,atomicState.suppress)
    mqtt.publishMsg (key+'/$properties',"${temp[key]}",1,true)
        
    }
    atomicState.properties=temp
} 

def buildMQTTLookup() {    // allows lookup of the HE device using normalised name used in homie tree  // cant I lookup to deviceNetworkID directly ?
    atomicState.nameMap = [:]
	atomicState.topicMap=[:]
    atomicState.newMap =[:]
    def temp1 = atomicState.nameMap
    def temp2 = atomicState.newMap
   // MQTTswitches = (settings?.switches)
	total=0
	atomicState.nodes=""  //always present
    if ((modes)||(hsm)) atomicState.nodes=",hub" else atomicState.nodes=","
    // No sensors in here as can't be controlled from MQTT    
    count=buildMaps((settings?.switches),"switches",temp1,temp2)
       atomicState.MQTTOnOffDevices=count
       total+=count
    count=buildMaps((settings?.dimmers),"dimmers",temp1,temp2)
       atomicState.MQTTDimDevices=count
       total+=count
    count=buildMaps((settings?.colour),"RGB",temp1,temp2)
       atomicState.MQTTRGBc=count
       total+=count
    count=buildMaps((settings?.colourT),"RGBT",temp1,temp2)
       atomicState.MQTTRGBt=count
       total+=count
    count=buildMaps((settings?.garagedoors),"garage doors",temp1,temp2)
       atomicState.MQTTgarageDevices=count
       total+=count
   count=buildMaps((settings?.mqtttext),"mqtt text",temp1,temp2)
       atomicState.MQTTtext=count
       total+=count
    count=buildMaps((settings?.windowshades),"window shades",temp1,temp2)
       atomicState.MQTTwindowDevices=count
       total+=count
    count=buildMaps((settings?.locks),"locks",temp1,temp2)
       atomicState.MQTTLockDevices=count
       total+=count 
    count=buildMaps((settings?.keypads),"keypads",temp1,temp2)
       atomicState.MQTTKEYPADt=count
       total+=count 
    count=buildMaps((settings?.chimes),"chimes",temp1,temp2)
       atomicState.MQTTChimeDevices=count
       total+=count
    count=buildMaps((settings?.bulbs),"bulbs",temp1,temp2)
       atomicState.MQTTBulbDevices=count
       total+=count
    count=buildMaps((settings?.outlets),"outlets",temp1,temp2)
       atomicState.MQTTOutletDevices=count
       total+=count 
    count=buildMaps((settings?.relayswitches),"relay switches",temp1,temp2)
       atomicState.RelaySwitchDevices=count
       total+=count
    count=buildMaps((settings?.thermostats),"thermostats",temp1,temp2)
       atomicState.MQTTThermostats=count
       total+=count 
    count=buildMaps((settings?.valves),"valves",temp1,temp2)
       atomicState.MQTTValveDevices=count    
       total+=count 
    count=buildMaps((settings?.globVars),"global variables",temp1,temp2)
       atomicState.MQTTGlobalVarDevices=count
       total+=count 
    count=buildMaps((settings?.gVars),"gVars",temp1,temp2)
       atomicState.MQTTgVarDevices=count
       total+=count 
    count=buildMaps((settings?.everything),"everything",temp1,temp2)
       atomicState.MQTTEverythingDevices=count
       total+=count
    count=buildMaps((settings?.alarms),"alarms",temp1,temp2)
       atomicState.MQTTAlarmDevices=count
       total+=count 
    atomicState.nameMap = temp1
    atomicState.newMap = temp2
    atomicState.nodes=atomicState.nodes.substring(1)
    atomicState.TotalDevices=total
    if (settings?.homiePublish){
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',atomicState.nodes,1,true,atomicState.suppress)
    }
    nodes=atomicState.nodes
    noddy= nodes.split(',')
    log ("[${noddy.size()}] nodes added $atomicState.nodes", "TRACE")
}

def buildMaps (devices, type, temp1, temp2) {
        count=0
        if (devices != null) {
            devices.each { dev -> 
                name=dev.displayName.toString()
                UID=dev.deviceNetworkId.toString()
                normName=normalize(name).toString()
                log ("    MQTT $type Device " + name + " + " + normName + UID, "TRACE")
		        if (normName!=null) atomicState.nodes += ',' + normName 
                else log ("null name on $dev.displayName","DEBUG")
			    // Build a lookup table for normName to full name & UID
			    temp1 [normName] = name
                temp2 [normName] = UID
                count++
            }     
        }
     return (count)    
}    

def mqttSubscribes() {  //events from MQTT driver    
    subscribe(mqtt,"MQTTStatus", mqttStatus)
    subscribe(mqtt,"HADiscoverStart",start_HADiscovery)
	//subscribe(mqtt,"HASynch", synchDevices)
	subscribe(mqtt,"OnOffDev", onoffCapability)
	subscribe(mqtt,"DimDev", dimCapability)
    subscribe(mqtt,"ButtonDev", buttonCapability)
	subscribe(mqtt,"SensorDev", sensorCapability)
    subscribe(mqtt,"LockDev", lockCapability) //Casey
	//subscribe(mqtt,"LabelDevice", reNameDev)  //LabelDeviceP()
	//subscribe(mqtt,"HASwitchDev", HASwitchCapability)
	//subscribe(mqtt,"HALightDev", HALightCapability)
	//subscribe(mqtt,"HASensorDev", HASensorCapability)  //friendly name
    //subscribe(mqtt,"HASensorType", HASensorType)  //device_class
	//subscribe(mqtt,"HABinarySensorDev", HABinarySensorCapability)
	//subscribe(mqtt,"HAInputBooleanDev", HAInputBooleanCapability)
    //subscribe(mqtt,"HAPerson", HAPresenceCapability)
	//subscribe(mqtt,"HACoverDev", HACoverCapability)
    //subscribe(mqtt,"HALockDev", HALockCapability)
    //subscribe(mqtt,"HADeviceTrackerDev", HADeviceTrackerCapability)
    //subscribe(mqtt,"HAClimateDev", HAClimateCapability)
    //subscribe(mqtt,"HAGroupDev", HAGroupCapability)
    subscribe(mqtt,"ShellyDevice",ShellyCapabilities)
    //subscribe(mqtt,"ShellyDimDev",dimCapabilityShelly)
	//subscribe(mqtt,"OnOff", onoffEvent)
	//subscribe(mqtt,"Dim",dimEvent)
	//subscribe(mqtt,"Command",cmdEvent)
	//subscribe(mqtt,"Sensor",sensorEvent)
	//subscribe(mqtt,"BinarySensor",binarySensorEvent)
	//subscribe(mqtt,"SensorUnit",sensorUOM)
    //subscribe(mqtt,"Lock", lockEvent) //Casey
	//subscribe(mqtt,"Group",groupEvent)
    subscribe(mqtt,"VariableDev",varCapability)
	//subscribe(mqtt,"InputBoolean",inputBooleanEvent)
    //subscribe(mqtt,"WildcardTopics","wildcardTopics")
    //subscribe(mqtt,"person",presenceEvent)
    subscribe (mqtt,"presence", mqttOnline)  //MQTT Broker connected indicator
	//subscribe(mqtt,"Lookup", LookupManual)  //deprecated
	//subscribe(mqtt,"SensorDevClass",HABinSensorType)  //??  doesnt exist
	//subscribe(mqtt,"getTopic", topicPayload)
    //subscribe (mqtt,"HAUnknown",HAUnknownCapability)
    subscribe (mqtt,"HEUnknown",homieUnknownCapability)
    subscribe (mqtt,"endDiscovery",devSummary)
    subscribe (mqtt,"Waiting",mqttProgress)
    subscribe (mqtt,"unsubscribeFriendly",unsubscribeHADevices)
	subscribe (mqtt,"Format",format)
															  
}

def lockEvent(evt) {
        log  ("Lock Event Handler is AWOL","WARN")									
}

def mqttProgress(evt) {
    log ("Waiting for $evt.value","LOG")
}
							   
def deviceEventSubscribes() {   // This raises subscriptions for all enabled devices for the switch , level and lock attributes

    if (hsm) subscribe(location, locationEvent) 
    else {
        if(modes) subscribe(location,"mode",locationEvent)
	    subscribe(location, "systemStart", locationEvent)
    }
	subscribe(switches, "switch", switched)
	subscribe(dimmers, "level", dimmed)
	subscribe(dimmers, "switch", switchedDim) 
    
/*  everythings -----------------------------------------------  // These are now picked up in 
    subscribe(everything, "switch",switched)
    subscribe(everything, "switch",switchedDim)
    subscribe(everything, "level",dimmed)
    subscribe(everything, "lock", locked) //Casey
    //subscribe(everything, "switch",colourDevices)
    //subscribe(everything, "switch",colourDevices)
   -----------------------------------------------------------   
*/
	//subscribe(colour, "color", colourDevices)  //ToDo check this is correct commented out
//	subscribe(locks, "lock", locked) //Casey

    subscribe(var_VirtualSwitch, "switch", switched)
    subscribe(var_VirtualDimmer, "level", dimmed)
    subscribe(var_VirtualColorTemperatureLight, "level", dimmed) // ??
    subscribe(var_VirtualRGBLight, "level", dimmed)
    subscribe(var_VirtualRGBWLight, "level", dimmed)
    subscribe(var_VirtualDimmer, "switch", switchedDim)
    subscribe(var_VirtualColorTemperatureLight, "switch", switchedDim)  // ??
    subscribe(var_VirtualRGBLight, "switch", switchedDim)
    subscribe(var_VirtualRGBWLight, "switch", switchedDim)
    subscribe(var_VirtualGarageDoorController, "contact", otherDevices)  //check
    subscribe(var_VirtualGarageDoorController, "door", otherDevices)  //check
    subscribe(var_VirtualLock,"lock",locked)  //check

/*
    subscribe(var_RM Connector Variable,what,what)
    subscribe(var_MQTT Text,what,what)
    subscribe(var_Virtual audioVolume,what,what)
    subscribe(var_Virtual Button,what,what)
    subscribe(var_Virtual CO Detector,what,what)
    subscribe(var_Virtual Contact Sensor,what,what)
    subscribe(var_Virtual Fan Controller,what,what)
    subscribe(var_Virtual Humidity Sensor,what,what)
    subscribe(var_Virtual Illuminance Sensor,what,what)
    subscribe(var_Virtual Moisture Sensor,what,what)
    subscribe(var_Virtual Motion Sensor,what,what)
    subscribe(var_Virtual Multi Sensor,what,what)
    subscribe(var_Virtual Omni Sensor,what,what)
    subscribe(var_Virtual Presence,what,what)
    subscribe(var_Virtual Shade,what,what)
    subscribe(var_Virtual Smoke Detector,what,what)
    subscribe(var_Virtual Temperature Sensor,what,what)
    subscribe(var_Virtual Thermostat,what,what)
*/

/*					   
    // adhoc events from driver
	subscribe(adhoc,"OnOff",onoffEvent)
    // TODO CHECK  no dimEvent sub ??
	subscribe(adhoc,"topic", stateTopics)
	subscribe(adhoc,"mapTopic", mapTopics)
	subscribe(adhoc,"changeState",stateChange)
	subscribe(adhoc,"changeLevel",levelChange)
    subscribe(adhoc,"changeText",textChange)
*/    
    //subscribe (motionsensors,"motion",sensorDevices)
    subscribe (globVars,"variable",varChange)
    subscribe (gVars,"variable",varChange)
    subscribe (vSwitch,"switch",mqttChange)
    subscribe (vContact,"contact",mqttChange)
    subscribe (vDimmer,"level",mqttChange)
    subscribe (vDimmer,"switch",mqttChange)
}

def sensorSubscribes(count) {   // These are report only attributes- they have no commands
    
        attCount=0  // TODO now not local
        count = registerSpecificAttribute (motionsensors,count,'motion','sensorDevices')
        count = registerSpecificAttribute (contactsensors,count,'contact','sensorDevices')
    //count = registerAll (listAll,count,'auto')  // for Hubitat topic
    //count = registerAll (sensors,count,'sensorDevices')   // for homie topic
        count = registerSpecificAttribute (shocksensors,count,'shock','sensorDevices')
        count = registerSpecificAttribute (smokesensors,count,'smoke','sensorDevices')
        count = registerSpecificAttribute (presencesensors,count,'presence','sensorDevices')
        count = registerSpecificAttribute (humiditysensors,count,'humidity','sensorDevices')
        count = registerSpecificAttribute (illuminancesensors,count,'illuminance','sensorDevices')
        count = registerSpecificAttribute (tempsensors,count,'temperature','sensorDevices')
        count = registerSpecificAttribute (batterysensors,count,'battery','sensorDevices')
        count = registerSpecificAttribute (carbonmonoxidesensors,count,'carbonmonoxide','sensorDevices')
        count = registerSpecificAttribute (voltagesensors,count,'voltage','sensorDevices')
        count = registerSpecificAttribute (powersensors,count,'power','sensorDevices')
        count = registerSpecificAttribute (watersensors,count,'water','sensorDevices')  
        count = registerSpecificAttribute (globVars,count,'variable','otherDevices')  //  ?? Not a sensor as updateable
        count = registerSpecificAttribute (gVars,count,'variable','otherDevices')  //  ?? Not a sensor as updateable
        
    return (count)
}

def deviceSubscribes(count) {  // TODO check - Here I might only have enabled one capability but I am subscribing to all capabilities and attributes - need to only use attributes that are in the capability
    mqtt = getChildDevice("MQTT: Child device driver")
        log ("deviceSubscribes","DEBUG")

        count=registerAll (everything,count)  // auto lookup handle
     
// MUST now use registerSpecificCapability as only specific capabilities are enabled here
 
        // actuators  do nothing no attributes
        // refresh                     TODO
        count = registerSpecificCapability (refresh,count,'Refresh','otherDevices')
        count = registerSpecificCapability (colour,count,'ColorControl','colourDevices')
        count = registerSpecificCapability (colourT,count,'ColorTemperature','colourDevices')
        count = registerSpecificCapability (colourMode,count,'ColorMode','colourDevices')
        count = registerSpecificCapability (thermostats,count,'Thermostat','thermostatDevices')
        count = registerSpecificCapability (buttonspush,count,'PushableButton','buttons')
        count = registerSpecificCapability (buttonshold,count,'HoldableButton','buttons')
        count = registerSpecificCapability (buttonstap,count,'TapableButton','buttons')
        count = registerSpecificCapability (buttonsrelease,count,'ReleasableButton','buttons')
        count = registerSpecificCapability (buttonsdtap,count,'DoubleTapableButton','buttons')
        count = registerSpecificCapability (alarms,count,'Alarm','otherDevices')
        count = registerSpecificCapability (bulbs,count,'Bulb','otherDevices')
        count = registerSpecificCapability (chimes,count,'Chime','otherDevices')
        count = registerSpecificCapability (garagedoors,count,'GarageDoorControl','otherDevices')
        count = registerSpecificCapability (keypads,count,'SecurityKeypad','keypadDevices')
        count = registerSpecificCapability (outlets,count,'Outlet','otherDevices')
        count = registerSpecificCapability (relayswitches,count,'RelaySwitch','otherDevices')
        count = registerSpecificCapability (musicplayers,count,'MusicPlayer','audioDevices')
        count = registerSpecificCapability (speechsynthesis,count,'SpeechSynthesis','audioDevices')
        count = registerSpecificCapability (valves,count,'Valve','OtherDevices')
        count = registerSpecificCapability (windowshades,count,'WindowShade','otherDevices')
        count = registerSpecificCapability (dimmers,count,'SwitchLevel','dimmed')
        count = registerSpecificCapability (locks,count,'Lock','locked')
        count = registerSpecificCapability (switches,count,'Switch','switched')
        count = registerSpecificCapability (lights,count,'Switch','switched')
        count = registerSpecificAttribute (settings?.mqtttext,count,'text','otherDevices')
        count = registerSpecificAttribute (settings?.mqtttext,count,'textPrefix','otherDevices')
        count = registerSpecificAttribute (settings?.mqtttext,count,'textSuffix','otherDevices')
        //count = registerSpecificCapability (switches,count,'Switch','switchedDim')   //??
     

    atomicState.delay=0
    int i= count/5
    estStartup= atomicState.delay + (count/3)
    atomicState.timeStamp=now()
    log ("Starting HE device publishing to MQTT for ${count} HE devices with ${attCount} attributes","BLUE")
    if (settings?.homieDevice) mqtt.setHomieDevice(settings?.homieDevice)
	count=0
}

 
def everythingSubscribes(count) {   
    count = registerAll (everything,count)
    if (everything != null) log ("Registering $everything" , "LOG")
}


def registerSpecificCapability (devList, count, capability, handlerReq='auto'){      //registers handlers for a specific device capability
    changes=true
     devList.each { dev ->
          dev.capabilities.each { cap ->
              if ("${cap}" == "${capability}") {
                  cap.attributes.each { attr ->
                          prop=whatProperty(attr.name)
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes && prop!='unknown') addProperty (key,prop,dev)
                          lookupHandler(dev,cap.name,attr.name,handlerReq)
                          attCount++
                      } 
                  }
              else log ("Capability [$cap][$capability] not required for device [$dev] ", "DEBUG")  
          }
      count++
      }
return (count)
    
    
}

def registerSpecificAttribute (devList, count, attribute, handlerReq='auto'){      //registers handlers for a specific device capability 
     changes=true
     devList.each { dev ->
                      if (attribute=='variable'){   //variables don't list as attributes 
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes) addProperty (key,'variable',dev)
                          lookupHandler(dev,'Variable','variable',handlerReq)
                          attCount++  
                          return false
                      }
                      else if (attribute=='text'){   //variables don't list as attributes 
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes) {
                              addProperty (key,'text',dev)
                              addProperty (key,'prefix',dev)
                              addProperty (key,'suffix',dev)
                          }
                          lookupHandler(dev,'Text','text',handlerReq)
                          lookupHandler(dev,'Text','prefix',handlerReq)
                          lookupHandler(dev,'Text','suffix',handlerReq)
                          attCount++  
                          return false
                      }

          dev.capabilities.each { cap ->
                  cap.attributes.each { attr ->
                      if ("${attr}" == "${attribute}") {
                          log ("$dev Specific Att Registration of $cap $attr", "KGREEN")                          
                          prop=whatProperty(attr.name)
                          normName=normalize(dev.displayName)
                          key = "homie/${atomicState.normHubName}/$normName"
                          if (changes && prop!='unknown') addProperty (key,prop,dev)
                          lookupHandler(dev,cap.name,attr.name,handlerReq)
                          attCount++
                      }
                      else log ("$dev [$attribute] attribute - attribute [$attr] not required for capability [$cap] ", "KGREEN")   // ERROR 
                  }
          }
      count++
      }
return (count)
}

def registerAll (devList,count,handlerReq='auto') {  //registers handlers for every capability and attribute a device has
    //  a variable attribute will not get registered as it has no matching capability !
        changes=true
        devList.each { dev ->
          dev.capabilities.each { cap ->
            cap.attributes.each { attr ->
                log ("$dev (all) subscribing to " + cap.name + "  " + attr.name + "  " + handlerReq, "KGREEN")

                prop=whatProperty(attr.name)
                normName=normalize(dev.displayName)
                key = "homie/${atomicState.normHubName}/$normName"
                if (changes && prop!='unknown') addProperty (key,prop,dev)
                
                //subscribe(dev, attr.name, buttons)
                lookupHandler(dev,cap.name,attr.name,handlerReq)
                //attCount++
                
                

                // released doubleTaped pushed numberOfButtons held
            }
            //capCount++
	    }
        count++        
	}
    return (count)
}

def whatProperty(attr) {
    found=true
    switch (attr) {
        case "switch":
            property="onoff"
            break
        case "level":
            property="dim"
            break
        case "colorTemperature":
            property="color-temperature"
            break
        //case "colorControl":
        case "colorName":
            property="color-name"
            break
        case "hue":
        case "saturation":
        case "hsv":
        case "RGB":
        case "RGBT":
        case "color":
            property="color"
            break
        case "colorMode":
        case "cMode":
            property="color-mode"
            break
        case "thermostatSetpoint":
            property="thermostat-setpoint"
            break
        case "heatingSetpoint":
            property="heating-setpoint"
            break
        case "coolingSetpoint":
            property="cooling-setpoint"
        case "thermostatMode":
            property="mode"
            break
        case "thermostatModes":
        case "supportedThermostatModes":
            property="modes"
            break
        case "thermostatOperatingState":
            property="state"
            break
        case "thermostatFanMode":
            property="fanmode"
            break
        case "thermostatFanModes":
        case "supportedThermostatFanModes":
            property="fanmodes"
            break
        case "hysteresis":
            property="unknown"
            //property "hysteresis"
            break
        case "schedule":
            //property "schedule"
        property="unknown"
            break
        case "lastCodeName":
            property="lastuser"
            break
        case "securityKeypad":
            property="securityMode"
            break
        case "lockCodes":                        //TODO
        case "maxCodes":
        case "codeLength":
        case "codeChanged":
            property='unknown'
            break

        case "battery":
        case "water":
        case "temperature":
        case "humidity":
        case "voltage":
        case "energy":
        case "power":
        case "illuminance":
        case "carbonDioxide":
            property="measure-"+attr
            break
        case "smoke":
        case "carbonMonoxide":
            property=attr+"-alarm"
            break
        case "pushed":
        case "released":
        case "held":
        case "doubleTapped":
        case "numberOfButtons":
            property="button"
            break
        case "status":
        case "volume":
        case "mute":
        case "trackData":
        case "trackDescription":
        case "level": // This can never be executed due to match > dim previously
        case "motion":
        case "contact":
        case "alarm":
        case "presence":                        //CHECK
        case "acceleration":                    //CHECK
        case "cover":
        case "door":
        case "valve":
        case "variable":
        case "lock":
            property=attr.toLowerCase()
            break        
        default:
            log ("Unknown property value $attr","WARN")
            //property=attr.toLowerCase()
            property='unknown'
            found=false
            break
        }      
        return (property)
    // return (property,false)
}

def lookupHandler(device,capability,attribute,handlerReq='auto')
{
   def handler=''
   log ("$device: Need to subscribe to events from ${capability}  ${attribute} using ${handlerReq}", "DEBUG")    
   switch(capability) {
   case "SwitchLevel":
	   handler="dimmed"
	   break
   case "Switch":
   case "Light":
	   handler="switched"   
       break
   case "Switched":   
	   handler="switchedDim"
       break
   case "Thermostat": 
       handler="thermostatDevices"
       break
   case "ColorControl":
   case "ColorTemperature":
   case "ColorMode":
       handler="colourDevices" 
       break
   case "Lock":
        handler="locked"
		break
   case "SpeechSynthesis":
   case "MusicPlayer":
       handler="audioDevices"
       break
   case "HoldableButton":
   case "PushableButton":
   case "DoubleTapableButton":
   case "ReleasableButton":
       handler="buttons"
       break
   case "Alarm":
   case "Bulb":
   case "Chime":
   case "GarageDoorControl":
   case "Outlet":   
   case "RelaySwitch":
   case "Text":
   case "Valve":
   case "Variable":  // artificial
   case "WaterSensors":
   case "WindowShades":
       handler="otherDevices" 
       break
   case "SecurityKeypad":
       handler="keypadDevices"
       break
   default:
       log ("Handling ${device} ${capability} ${attribute} with (default) sensor", "LOG")
       handler="sensorDevices"
       break

    }
   if (handlerReq != 'auto') {
           if (handlerReq != handler) log ( "Auto Handler Mismatch [${device} ${capability} ${attribute}] ReqHandler:${handlerReq} AutoHandler:${handler}", "KH")
           handler=handlerReq  // give it the requested one for now...
    }
    else log ("Everything events subscribe to $device $attribute $handler","DEBUG") // Is attribute inclusion right here ???
    log ("Events subscribe to $device $attribute $handler","DEBUG") // Is attribute inclusion right here ???
    if (handler!="") subscribe(device,attribute,handler)
    else log ("No handler found for $device $attribute","WARN")
}


def wipe() { 
	atomicState.onoffDevices=[] 
	atomicState.dimDevices=[]
	atomicState.sensorDevices=[]
    atomicState.lockDevices=[]  //Casey
    atomicState.SonoffDevices=[]
    atomicState.ShellyDevices=[]
	atomicState.HASwitchDevices=[]
	atomicState.HALightDevices=[]
	atomicState.HASensorDevices=[]
	atomicState.HABinarySensorDevices=[]
	atomicState.HAInputBooleanDevices=[]
    atomicState.HACoverDevices=[]
    atomicState.HAClimateDevices=[]
    atomicState.HADeviceTrackerDevices=[]
    atomicState.HALockDevices=[]
	atomicState.HAGroupDevices=[]
    atomicState.HAPresenceDevices=[]
    atomicState.HAUnknownDevices=[]
    atomicState.homieUnknownDevices=[]
    atomicState.buttonDevices=[]
    atomicState.varDevices=[]
    atomicState.MQTTvirtuals=[]
    atomicState.Mappings=[:]
    log ("All atomicState devices[] cleared","WARN")
    atomicState.vList.each { devType ->
        setting= "var_" + "${devType.replaceAll("\\s","")}"

        app.removeSetting(setting)
    }
    	log ("All discovered devices forgotten","WARN")   
}

def currentMode() {  
	        if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    normName = normalize(name)
                sTopic=	"homie/${atomicState.normHubName}/hub/"
                mqtt.publishMsg (sTopic+'$name',settings?.hubName,1,true)
                if (! hsm) mqtt.publishMsg (sTopic+'$properties',"mode",1,true)
                else mqtt.publishMsg (sTopic+'$properties',"mode,hsmStatus, hsmAlert,hsmArm",1,true)
                mqtt.publishMsg (sTopic+'$type',"sensor",1,true)
			    sTopic=	"homie/${atomicState.normHubName}/hub/mode"
                mqtt.publishMsg (sTopic,"${location.mode}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$format',"${location.modes}",1,true,atomicState.suppress)
            }
} 

def currentHSB() {  
	        if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    normName = normalize(name)
                sTopic=	"homie/${atomicState.normHubName}/hub/"
                mqtt.publishMsg (sTopic+'$name',settings?.hubName,1,true)
                if (!modes) mqtt.publishMsg (sTopic+'$properties',"hsm",1,true)
                else mqtt.publishMsg (sTopic+'$properties',"mode,hsmStatus, hsmAlert,hsmArm",1,true)
                mqtt.publishMsg (sTopic+'$type',"sensor",1,true)
			    sTopic=	"homie/${atomicState.normHubName}/hub/hsmStatus"
                mqtt.publishMsg (sTopic,"${location.hsmStatus}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$format',"[armedAway, armingAway, armedHome, armingHome, armedNight, armingNight, disarmed, allDisarmed]",1,true,atomicState.suppress)
			    sTopic=	"homie/${atomicState.normHubName}/hub/hsmAlert"
                mqtt.publishMsg (sTopic,"none",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$format',"[intrusion, intrusion-home, intrusion-night,smoke, water, rule, cancel, arming, none]",1,true,atomicState.suppress)
            	sTopic=	"homie/${atomicState.normHubName}/hub/hsmArm"
                // mqtt.publishMsg (sTopic," ",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','enum',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                if (settings?.allowHSMControl) mqtt.publishMsg (sTopic+'/$settable','true',1,true,atomicState.suppress) 
                else mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress)
                if (settings?.allowHSMDisarm) mqtt.publishMsg (sTopic+'/$format',"[armAway, armHome, armNight, disarm, armRules, disarmRules, disarmAll, armAll, cancelAlerts, blocked, unknown]",1,true,atomicState.suppress)
                else mqtt.publishMsg (sTopic+'/$format',"[armAway, armHome, armNight, armRules, armAll, cancelAlerts, unknown]",1,true,atomicState.suppress)
        }
}

def sunTimes() {
    	        if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    normName = normalize(name)
                sTopic=	"homie/${atomicState.normHubName}/hub/"
                mqtt.publishMsg (sTopic+'$name',settings?.hubName,1,true)
                if (!settings?.modes) mqtt.publishMsg (sTopic+'$properties',"sunset,sunrise,hsm",1,true)
                else mqtt.publishMsg (sTopic+'$properties',"sunset,sunrise,mode,hsm",1,true)
                mqtt.publishMsg (sTopic+'$type',"sensor",1,true)
			    sTopic=	"homie/${atomicState.normHubName}/hub/sunrise"
                mqtt.publishMsg (sTopic,"${location.sunrise}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','string',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                //mqtt.publishMsg (sTopic+'/$format',"[armedAway, armingAway, armedHome, armingHome, armedNight, armingNight, disarmed, allDisarmed]",1,true,atomicState.suppress)
			    sTopic=	"homie/${atomicState.normHubName}/hub/sunset"
                mqtt.publishMsg (sTopic,"${location.sunset}",1,true)
                mqtt.publishMsg (sTopic+'/$datatype','string',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$retained','true',1,true,atomicState.suppress) 
                mqtt.publishMsg (sTopic+'/$settable','false',1,true,atomicState.suppress) 
                //mqtt.publishMsg (sTopic+'/$format',"[armedAway, armingAway, armedHome, armingHome, armedNight, armingNight, disarmed, allDisarmed]",1,true,atomicState.suppress)
            }    
}

def mqttStatus(evt) {
    log("MQTT Status is ${evt.value}","INFO")
    if (evt.value=='Online'){
        log ("MQTT already connected", "INFO")
        atomicState.MQTTconnected=true
    }
        
    else if (evt.value=='Connect') {   // else if (evt.value=='Status') 
        log ("MQTT has reconnected, restarting APP", "INFO")
        atomicState.MQTTconnected=true
        if (!atomicState.startup) {
            //atomicState.abort=true  // should kill the existing app if it's within the initialisation method
           
            log("restart requested but there's maybe another instance still initializing","WARN")
            log (" Abort is $atomicState.abort ", "WARN")
         //   runIn(10, "reStart")
        }
      //  runIn(5, "reStart") 
    }
    
    else {
        log ("MQTT connection error " + evt.value, "ERROR")
        atomicState.MQTTconnected=false
    }
    
    //  Not doing anything now as the driver will reconnect itself, or if it was commanded to disconnect the user will have to intervene and re-run this app.
    /*
        if (atomicState.restartPending==true){  
            log ("Restart already in progress","WARN")
            return
        }
        else {
            atomicState.restartPending=true // If this gets set then can't restart so going to set a timed unset 
            atomicState.MQTTconnected=false
            atomicState.abort=true // This should cause any code running in initialize() to abort
            atomicState.count=0 
            log ("Awaiting MQTT reconnect", "ERROR")
            runIn(600, "reStart") // will still retry in 10 minutes
            if (!atomicState.started) {  // still running initialize()
            while (atomicState.abort) {
                log ("Waiting to abort startup..","WARN")
                pauseExecution(5000)
                }
            }
            log ("Initialize was aborted", "ERROR")
        }
    */
    
}

def clearRestart() {
    log ("Force clearing the reset pending flag","ERROR")
    atomicState.restartPending=false
}

def synchDevices() {
    mqtt = getChildDevice("MQTT: Child device driver")
    log ("Resynch MQTT device states and HA discovery topics","INFO")
    publishList=[:]
    
    
    MQTTRGB = (settings?.colour)  //separate as extra values
        count=0
        if (MQTTRGB != null){
        MQTTRGB.each {
            if (settings?.HADiscovery && (!publishList.containsKey(myName))) {
                publishList.put(it.id,[myName,"light","colour"])
            }
			mydName = it.name
			myName = it.displayName
		    //for (String item : MQTTRGB) {
			    //switchedDim(null, myName,"onoff", it.currentSwitch,it.id)  //?? handle in colourDevices() ??
		   	    //dimmed(null, myName, "dim", it.currentLevel,it.id)  //??
		    	hsv=[it.currentHue, it.currentSaturationz, it.currentLevel]
	    		colourDevices(null, myName, "hsv", hsv,it)
//#NEW           
                rgb=it.currentRGB
                log ("New RGB attribute value for $it is $rgb","LOG")
                //if (rgb!=null) colourDevices (null,myName,"RGB",rgb,it)
            
                color=it.currentColor
                log ("New color attribute value for $it is $color","LOG")
                //if (color!=null) colourDevices (null,myName,"color",color,it)

            
                normName=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',it.typeName,1,true)
            
                try {
                    colorName=it.currentColorName
                    colourDevices(null,myName,"colorName",colorName,it) 
                }
                catch (e) {
			    }            
                count++
		   // }
	    }
     }
    MQTTRGBT = (settings?.colourT) 
	if (MQTTRGBT != null){
                
        count=0
        MQTTRGBT.each {
            if (settings?.HADiscovery && (!publishList.containsKey(myName))){
                publishList.put(it.id,[myName,"light","colour"])
            }
            
			mydName = it.name
			myName = it.displayName
			//switchedDim(null, myName,"onoff", it.currentSwitch,it.id)
			//dimmed(null, myName, "dim", it.currentLevel,it.id)
            colorTemp=it.currentColorTemperature
            colourDevices(null,myName,"colorTemperature",colorTemp,it)
                normMame=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',it.typeName,1,true)
            try {
                colorName=it.currentColorName
                colourDevices(null,myName,"colorName",colorName,it)
            }
            catch (e) {
            }
                colourDevices(null,myName,"cMode","CT",it)

            count++
		}
	}
    
    everyThing = (settings?.everything)
    if (everyThing != null){
        count=0 
        everyThing.each {
            myName=it.displayName
            //log ("Everything type name is $it.typeName","LOG")
            if (it.typeName.contains("Sensor")||it.typeName.contains("Presence")) sensor=true else sensor=false 
                if (sensor) {
                    devLoopAll (it,"all","sensorDevices")  // passing all devices here not just sensors BUG
                    return false
                }
            else if (it.typeName.contains("Thermostat")){
                devLoopAll (it,"all","thermostatDevices")  // passing all devices here not just sensors BUG
                return false
            }
            else if (it.typeName.contains("OpenWeatherMap")){
                devLoopAll (it,"all","sensorDevices")  // passing all devices here not just sensors BUG
                return false
            }
  
            else {  // Not a sensor or thermostat
                if (settings?.HADiscovery && (!publishList.containsKey(myName))){
                //publishList.put(it.id,[myName,"light","colour"])   
                }
                
            sTopic="homie/${atomicState.normHubName}/${normalize(it.name)}"
            mqtt.publishMsg (sTopic+'/$name',it.name,1,true)
            // $properties
            // $type
            // do an attribute to 
            mqtt.publishMsg (sTopic+'/-device-driver',it.typeName,1,true) 
            it.capabilities.each { cap ->
                //log (":::$it::: Cap: $cap", "INFO")
                cap.attributes.each { attrib ->
                    attName=attrib.name
                    log ("Everything: [$myName] Cap: [$cap]  Att: [$attName] [${it.currentValue(attName)}]", "LOG") 
                    if ("$cap"=="Switch" || "$cap"=='Light')  {  // Is this right to call both ?
                        switched(null, myName, attName, it.currentValue(attName),it) //,multiple)
                        switchedDim(null, myName, attName, it.currentValue(attName),it) //,multiple)
                    }
                    else if ("$cap"=="SwitchLevel")  dimmed(null, myName, attName, it.currentValue(attName),it) //,multiple)
                    else if ("$cap"=="ColorTemperature")  colourDevices(null, myName, attName, it.currentValue(attName).toString(),it) //,multiple)
                    else if ("$cap"=="ColorControl") colourDevices(null, myName, attName, it.currentValue(attName).toString(),it) //,multiple)
                    else if ("$cap"=="ColorMode")  colourDevices(null, myName, attName, it.currentValue(attName).toString(),it) //,multiple)
                    else if ("$cap"=="buttons") buttons(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="LockCodes") locked(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="Lock") locked(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="keypadDevices") keypadDevices(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                    else if ("$cap"=="audioDevices") audioDevices(null, myName, attName, it.currentValue(attName),it) //,multiple,dev.id)   //CHECK
                   // else if ("$cap"=="RealtiveHumidityMeasurement")  sensors(null, myName, attName, it.currentValue(attName),it) //,multiple)
                   // else if ("$cap"=="TemperatureMeasurement")  sensors(null, myName, attName, it.currentValue(attName),it) //,multiple)
                    else {
                            log ("Unhandled so using otherDevices [$cap $attrib]","LOG")
                            otherDevices(null, myName, "$attrib", it.currentValue("$attrib"),it) //,multiple,dev)   //CHECK
                    }
                }
            }
            
            
/*
				it.capabilities.each { cap ->
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}","-")
					cap.attributes.each { attrib ->
						try {
							def currentState = it.currentState(attrib.name)
							aValue= currentState.value.toString()
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",aValue)
						}
						catch (e) {
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",'-')
						}
					}
				}
            
            
*/            
            def attrs = it.supportedAttributes
			//if (attrs.size()>1) multiple=true else multiple=false
			attrs.each { attr ->
				def currentState = it.currentState(attr.name)   // what not use currentValue instead TODO ?
				try {
					aValue= currentState.value.toString()
				}
				catch (e) {
				 	aValue='-'
				}
                if (aValue!="-") {
                    //mqtt.publishMsg (sTopic+"/${attr}",aValue,1)
                    //mqtt.publishMsg (sTopic+"/${attr}",aValue,1)
                    //mqtt.publishMsg (sTopic+"/${attr}/settable",'false',1)
                    devLoop (settings?.contactsensors,"contact","sensorDevices")
                }
                count++    
            }
        }
    }
}
    
    
    
    
    loopDev = (settings?.listAll)    // These are the devices to list to Hubitat capabailities/attributes topic 
	if (loopDev != null){
			loopDev.each{
			mydName = it.name
			myName = it.displayName
			def attrs = it.supportedAttributes
			if (attrs.size()>1) multiple=true else multiple=false
				attrs.each { attr ->
					def currentState = it.currentState(attr.name)   // what not use currentValue instead TODO ?
					try {
						aValue= currentState.value.toString()
					}
					catch (e) {
				 		aValue=' '
					}
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/attributes/${attr}",aValue)	
				}
				it.capabilities.each { cap ->
					mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}"," ")
					cap.attributes.each { attrib ->
						try {
							def currentState = it.currentState(attrib.name)
							aValue= currentState.value.toString()
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",aValue)
						}
						catch (e) {
							mqtt.publishMsg ("Hubitat/${settings?.hubName}/${myName}/capabilities/${cap}/${attrib}",' ')
						}
					}
				}	
        	}
		}

    devLoop (settings?.switches,"switch","switched","onoff")    
    devLoop (settings?.dimmers,"level","dimmed","dim") 
    //devLoop (settings?.dimmers,"switch","switchedDim","onoff")
    devLoop (settings?.locks,"lock","locked")
    // others
    devLoop (settings?.alarms,"alarm","otherDevices")
    devLoop (settings?.bulbs,"switch","switched","onoff")
    devLoop (settings?.chimes,"chime","otherDevices")
    devLoop (settings?.garagedoors,"contact","otherDevices")
    devLoop (settings?.garagedoors,"door","otherDevices")
    devLoop (settings?.windowshades,"contact","otherDevices")
    devLoop (settings?.windowshades,"door","otherDevices")    
    devLoop (settings?.keypads,"lastCodeName","keypadDevices")
    devLoop (settings?.keypads,"securityKeypad","keypadDevices")
    devLoop (settings?.outlets,"outlet","otherDevices")
    devLoop (settings?.relayswitches,"relaySwitch","otherDevices")
    devLoop (settings?.speechsynthesis,"speech","audioDevices")
    devLoop (settings?.musicplayers,"music","audioDevices")
    devLoop (settings?.valves,"valve","otherDevices")
    devLoop (settings?.watersensors,"water","sensorDevices")
    devLoop (settings?.globVars,"variable","otherDevices")
    devLoop (settings?.gVars,"variable","otherDevices")
    //buttons
    devLoop (settings?.buttonspush,"numberOfButtons","buttons")
    devLoop (settings?.buttonspush,"pushed","buttons")
    devLoop (settings?.buttonshold,"held","buttons")
    devLoop (settings?.buttonsdtap,"doubleTapped","buttons")
    devLoop (settings?.buttonsrelease,"released","buttons")
    devLoop (settings?.buttons,"button","buttons")  
     //sensors 
    devLoop (settings?.contactsensors,"contact","sensorDevices")
    devLoop (settings?.tempsensors,"temperature","sensorDevices")
    devLoop (settings?.batterysensors,"battery","sensorDevices")
    devLoop (settings?.motionsensors,"motion","sensorDevices")
    devLoop (settings?.humiditysensors,"humidity","sensorDevices")
    devLoop (settings?.illuminancesensors,"illuminance","sensorDevices")
    devLoop (settings?.smokesensors,"smoke","sensorDevices")
    devLoop (settings?.presencesensors,"presence","sensorDevices")
    devLoop (settings?.powersensors,"power","sensorDevices")
    devLoop (settings?.voltagesensors,"voltage","sensorDevices")
    // thermostats
    devLoop (settings?.thermostats,"temperature","thermostatDevices")
    devLoop (settings?.thermostats,"heatingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"coolingSetpoint","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatMode","thermostatDevices")
    devLoop (settings?.thermostats,"thermostatFanMode","thermostatDevices")
    devLoop (settings?.thermostats,"supportedThermostatModes","thermostatDevices","thermostatModes")
    devLoop (settings?.thermostats,"supportedNestThermostatModes","thermostatDevices","thermostatModes") 
    devLoop (settings?.thermostats,"supportedThermostatFanModes","thermostatDevices","thermostatFanModes")
    devLoop (settings?.thermostats,"supportedNestThermostatFanModes","thermostatDevices","thermostaFantModes")
    devLoop (settings?.thermostats,"thermostatOperatingState","thermostatDevices")
    devLoop (settings?.mqtttext,"text","otherDevices")
    devLoop (settings?.mqtttext,"prefix","otherDevices")
    devLoop (settings?.mqtttext,"suffix","otherDevices")

	if (publishList.size() != 0) {
    log(">>>>>>>>>>>>>>>>>>>>>   Publish List is $publishList","LOG") 
    //publishList.each {k, v -> HADiscoveryAdvertise(v[0],v[1],v[2], k) }
    }
}


def devLoop(deviceList, attribute, handler, type='none'){  // This registers a single 'named' attribute for a device  
        mqtt = getChildDevice("MQTT: Child device driver")
		deviceList.each{ dev->
			mydName = dev.name
			myName = dev.displayName
                normName=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',dev.typeName,1,true)
            
            
                def attrs = dev.supportedAttributes  //this gets all attributes in variable, custom etc
            if (type == 'none') type=attribute
			if(dev.currentValue(attribute)!=null){
				log ("## " + dev.name + " $attribute  ${dev.currentValue(attribute)}","TRACE") // + ${attrs}
				if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here
                log ("#### $attribute sensor #### ${myName} has attributes ${attrs}","TRACE")  // not all are sensors

                if(handler=="sensorDevices") sensorDevices(null, myName, type, dev.currentValue(attribute),dev,multiple)
                else if (handler=="thermostatDevices") thermostatDevices(null, myName, type, dev.currentValue(attribute),dev,multiple)
                else if (handler=="switched") switched(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="dimmed") dimmed(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="switchedDim") switchedDim(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="buttons") buttons(null, myName, type, dev.currentValue(attribute),dev) //,multiple,dev.id)
                else if (handler=="otherDevices") otherDevices(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="locked") locked(null, myName, type, dev.currentValue(attribute),dev) //,multiple,dev.id)
                else if (handler=="keypadDevices") keypadDevices(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
                else if (handler=="audioDevices") audioDevices(null, myName, type, dev.currentValue(attribute),dev) //,multiple)
			}
            
            else log("No [" + attribute + "] attribute value available for [${myName}]", "INFO")
		}
}


def devLoopAll(dev, attribute, handler, type='none'){  // This registers all attributes for a device
    if (dev != null){
        mqtt = getChildDevice("MQTT: Child device driver")
//		deviceList.each{ dev->
			mydName = dev.name
			myName = dev.displayName
                normName=normalize(myName)
            	sTopic="homie/${atomicState.normHubName}/${normName}"
                mqtt.publishMsg (sTopic+'/-device-driver',dev.typeName,1,true)
                // iattrs = dev.supportedAttributesf (attribute=='all' && handler=="sensorDevices") { //Only use this for sensors - adds all attributes to device    
                def attrs = dev.supportedAttributes
                if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here        //jeff      
                if (attribute=='all' && handler=="sensorDevices") { //Only use this for sensors - adds all attributes to device
                    attrs.each { attr ->
                        sensorDevices(null, myName, "$attr", dev.currentValue("$attr"),dev,multiple)
                    }
                    return
                }
                else if (attribute=='all' && handler=="thermostatDevices") { //Only use this for sensors - adds all attributes to device
                    attrs.each { attr ->
                        thermostatDevices(null, myName, "$attr", dev.currentValue("$attr"),dev,multiple)
                    }
                    return
                }
                else log ("Attribute $attribute passed to devLoop2" , "LOG")
        
/*  
            if (type == 'none') type=attribute
			if(dev.currentValue(attribute)!=null){
				log ("## " + dev.name + " $attribute  ${dev.currentValue(attribute)}","TRACE") // + ${attrs}
				if (attrs.size()>1) multiple=true else multiple=false // TODO BUG Need to handle multiple attributes here
                log ("#### $attribute sensor #### ${myName} has attributes ${attrs}","TRACE")  // not all are sensors

                if(handler=="sensorDevices") sensorDevices(null, myName, type, dev.currentValue(attribute),dev,multiple)
                else if (handler=="thermostatDevices") thermostatDevices(null, myName, type, dev.currentValue(attribute),dev.id,multiple)
                else if (handler=="switched") switched(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="dimmed") dimmed(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="switchedDim") switchedDim(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="buttons") buttons(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple,dev.id)
                else if (handler=="otherDevices") otherDevices(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="locked") locked(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple,dev.id)
                else if (handler=="keypadDevices") keypadDevices(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
                else if (handler=="audioDevices") audioDevices(null, myName, type, dev.currentValue(attribute),dev.id) //,multiple)
			}
            
            else log("No [" + attribute + "] attribute value available for [${myName}]", "WARN")
//		}
        
        */

	}
    else log ("Null Device passed to devLoop2","TRACE")
}


def stateTopics(evt) {  // Returns names of all registered state topics for adhoc devices
	log ("Got topic ${evt.value}","DEBUG")
	subscribeOneOffTopics(evt.value)
}
    
def mqttOnline(evt) {
       if (evt.value=="present") atomicState.MQTTconnected=true
       else atomicState.MQTTconnected=false      
}

def maptopics2() {    
}

/*
def getDeviceObj(id) {
    def found
    settings.allDevices.each { device -> 
        if (device.getId() == id) {
            log ("Found ID [$id] in allDevices as $device with id: ${device.id}","INFO")
            found = device
        }
    }
    return found
}
*/

def mapTopics(evt) {  	
	def tempMap=atomicState.topicMap
	def content=[:]
	def data = parseJson(evt.data)
	log ("Topic mapped key " + data.level + " to " + data.state + " with " + data.valueMax, "DEBUG")
	if (data.valueMax!=null) valueMax=data.valueMax else valueMax='?'
	if (data.stateON!=null) valueON=data.stateON else valueON='?'
	if (data.stateOFF!=null) valueOFF=data.stateOFF else valueON='?'		
	content=[topic: data.state,maxValue : valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "dim"]
	tempMap[data.level]=content
	content=[topic: data.state, maxLevel: valueMax, stateON: data.stateON, stateOFF: data.stateOFF, type: "onoff"]
	tempMap[data.state]=content   // this creates an entry for the switch part of a dimmer so states are available
	atomicState.topicMap = tempMap
		for (e in tempMap) {
    		//log ( "[topic]: key = ${e.key}, value = ${e.value}","ERROR")
		}
}
/*
def stateChange(evt) {  // for a manual adhoc device  // TODO optimise these next three are identical !
	def data = parseJson(evt.data)
    mqtt = getChildDevice("MQTT: Child device driver")
			index=0
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index, "TRACE")
				mqtt.publishMsg (data.topic,evt.value,1,true)
            }
			index++
	}
}

def levelChange(evt) {  // for a manual adhoc device
	def data = parseJson(evt.data)
    mqtt = getChildDevice("MQTT: Child device driver")
			index=0  
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index,"TRACE")
				mqtt.publishMsg (data.dimTopic,evt.value,1,true)  
				}
			index++
	}
}
def textChange(evt) {  // for a manual adhoc device
    def data = parseJson(evt.data)
    mqtt = getChildDevice("MQTT: Child device driver")
			index=0
			for (String item : settings?.adhoc) {  
			if (item == evt.displayName){
				log ("Matched item [" + index + "] "  + index, "TRACE")
				mqtt.publishMsg (data.topic,evt.value,1,true)  
				}
			index++
	}
}
*/

def varChange(evt) {  // for an enabled Omni Device with variable attribute (globalVars)
			index=0
        mqtt = getChildDevice("MQTT: Child device driver")
			for (String item : settings?.globVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
    	    index=0
			for (String item : settings?.gVars) { 
			if (item == evt.displayName){
                log ("Matched item [" + index + "] "  + index, "TRACE")
                sTopic=sTopic="homie/${atomicState.normHubName}/${normalize(evt.displayName)}/variable"
				mqtt.publishMsg (sTopic,evt.value,1,true)  
				}
			index++
	}
}

private logDebug(msg) {
	if (settings?.debugOutput || settings?.debugOutput == null) {
		log ("$msg", "DEBUG")
	}
}

private determineLogLevel(data) {

    switch (data?.toUpperCase()) {
        case "TRACE":
            return 0
            break
        case "DEBUG":
            return 1
            break
        case "INFO":
            return 2
            break
        case "WARN":
            return 3
            break
        case "ERROR":
        	return 4
            break
		case "DISABLED":
		    return 5
			break
        case "RED":
        case "BLUE":
        case "GREEN":
        case "YELLOW":
        case "ORANGE":
        case "LOG":
        case "KH":
            return 6
            break
        default:
            return 1
    }
}

def topicPayload(value,status,topic) {
    mqtt = getChildDevice("MQTT: Child device driver")
	if (value!='#NoNe#'){
		log ('Acknowledge $property exists',"TRACE")
	}
	if (atomicState.Category=='') {
		log ("Blank category","DEBUG")
		return
	}
	//def data = parseJson(evt.data)	
	if (status.contains(atomicState.Category)){
		log ("${atomicState.Category}  already exists in ${status}","DEBUG")
		return
	}
	log  ("RX:  $value  /  ${status[]}  /  $topic  +  ${atomicState.Category}","DEBUG") 
	if (value=="#NoNe#") first='' else first=","
	mqtt.publishMsg (topic, status.join(",") + first + atomicState.Category,1,true,atomicState.suppress)
	log ("Publishing to $topic payload is ${status.join(",") + first + atomicState.Category}","DEBUG")
	atomicState.Category=''	
}

def HADiscoveryAdvertise (name, type="none", category="none", id='0', payON="true",payOFF="false",nameSuffix='',UOM='') {  // payON and payOFF vary a lot for sensors so need extra params) {
    if (!settings?.HADiscovery) return   // && HAtype!='?')
    if (HAtype=='unknown'){
        if (!atomicState.myHub)log ("$name not supported for HA Discovery","DEBUG")
        else log ("$name not supported for HA Discovery","LOG")
        return
    }
    if (category=='block'){
        log ("Blocking advertising dimmer $name as a switch to HA ","TRACE")
        return
    }
	normName = normalize(name+nameSuffix) 
	log ("Advertising ${name} device ${type} ${category} to HA with ID $id","DEBUG")
    if (id==0) log ("The ID for device $name $type was 0","WARN")
	if (atomicState.nameMap.containsValue(name)) log ("Found in nameMap" + name, "DEBUG") else log ("NOT Found in nameMap" + name, "DEBUG")
		sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'   //TODO tidy
        pAvail=',"availability_topic":"homie/' + "${atomicState.normHubName}" + '/$state"'
        pAvailPay=',"payload_available":"ready"'
        pNotAvailPay=',"payload_not_available":"init"'
		pName = '"name":"'+name+nameSuffix+'"'
		pUID = ',"unique_id":"Hubitat-MQTT:_' + normName + '"'
		pDevClass=''
		payload=''
        pID=''
    String ID = "${id}"
    if (ID != '0') {
        pID= ',"device": {"identifiers": "HE_'+ ID + '","name": "'+name+ '","sw_version":"pre beta 3c","model":"'+"${atomicState.normHubName}"+'","manufacturer":"Hubitat"}'  // TODO Investigate if this can work
    }
    else log ("ID is 0 for device $name  $type","WARN")
		pON = ',"payload_on":"true"'  //default for booleans in homie
		pOFF = ',"payload_off":"false"'
    
    
    if (type=="climate") {
        pFanMode=''
        pFanCmd=''
        pFanModes=''
        pMode=''
        pModeCmd=''
        pModes=''
        pSetpointCmd=''
        pHSetpointCmd=''
        pCSetpointCmd=''
        
        pDevClass = ',"device_class": "climate"'
        pCurrTemp = ',"current_temperature_topic": "homie/development/v2thermostat/measure-temperature"'
        
        pSetpoint = ',"temperature_state_topic": "homie/development/v2thermostat/cooling-setpoint"'
        pSetpointCmd = ',"temperature_command_topic": "homie/development/v2thermostat/cooling-setpoint/set"'
        
        pHSetpoint = ',"temperature_high_state_topic": "homie/development/v2thermostat/heating-setpoint"'
        pHSetpointCmd = ',"temperature_high_command_topic": "homie/development/v2thermostat/heating-setpoint/set"'

        pCSetpoint = ',"temperature_low_state_topic": "homie/development/v2thermostat/cooling-setpoint"'
        pCSetpointCmd = ',"temperature_low_command_topic": "homie/development/v2thermostat/cooling-setpoint/set"'



        pFanMode = ',"fan_mode_state_topic": "homie/development/v2thermostat/fanmode"'
        pFanCmd = ',"fan_mode_command_topic": "homie/development/v2thermostat/fanmode/set"'
        //pFanModes = ',"fan_modes": "homie/development/v2thermostat/fanmodes/$format"'
      
        pMode = ',"mode_state_topic": "homie/development/v2thermostat/mode"'
        pModeCmd = ',"mode_command_topic": "homie/development/v2thermostat/mode/set"'
        //pModes = ',"modes": "homie/development/v2thermostat/modes/$format"'
        //pModes=',"modes": "[“auto”, “off”, “cool”, “heat”]"'
        


       // [“auto”, “off”, “cool”, “heat”, “dry”, “fan_only”]
        
        pState = ',"state_topic":"'+ sTopic + '"'
        pState = ''
        pON=''
        pOFF=''
        pUOM=''
        //pON
        //pOFF
        //pIcon
        //pDev
        //pValTemp
        //pID 
        pValTemp = ',"value_template":"{{ value | round(0) }}"'  // acts as convert to int
        pValTemp=''
		if (category == "measure-temperature")  { 
            return
		    pDevClass = ',"device_class": "temperature"'
		    if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
		else if (category == "measure-humidity")  { 
            return
		    pDevClass = ',"device_class": "humidity"'
		    //if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            //else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
        else if (category == "heating-setpoint")  { 
		    //pDevClass = ',"device_class": "hsetpoint"'
            //pDevClass = ',"device_class": "hvac"'
            pDevClass=''
		    if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
        else if (category == "cooling-setpoint")  {
            return
		    pDevClass = ',"device_class": "csetpoint"'
		    if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
        else if (category == "mode")  {
            return
		    pDevClass = ',"device_class": "mode"'
		    //if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            //else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
        else if (category == "modes")  { 
            return
		    pDevClass = ',"device_class": "modes"'
		    //if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            //else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
        else if (category == "state")  { 
            return
		    pDevClass = ',"device_class": "state"'
		    //if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            //else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
        else if (category == "fanmode")  { 
            return
		    pDevClass = ',"device_class": "fanmode"'
		    //if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            //else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}        
        else if (category == "fanmodes")  { 
            return
		    pDevClass = ',"device_class": "fanmodes"'
		    //if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
            //else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
		}
        else {
            log("Category Was " + category , "KH")
            return
        }
        payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pDevClass+pState+pUOM+pON+pOFF+pIcon+pValTemp+pID+pCurrTemp+pSetpoint+pSetpointCmd+pHSetpoint+pHSetpointCmd+pCSetpoint+pCSetpointCmd+pFanMode+pFanCmd+pFanModes+pMode+pModeCmd+pModes+pDev+'}'        
    } 
	else if (type=="switch"|type=="light") {
            sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		    sColorTopic="homie/${atomicState.normHubName}/${normName}"+'/color'
			pState = ',"state_topic":"'+ sTopic + '"'
			pCmd = ',"command_topic":"'+ sTopic + '/set"'
			pUOM = ''
			//pON = ',"payload_on":"'+payON+'"'   // Is this ever needed ?
			//pOFF = ',"payload_off":"'+payOFF+'"'
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="switch") payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pID+'}'
			if (type=="light") {
				pOnType = ',"on_command_type":"first"'
				pBriState = ',"brightness_state_topic":"' + sDimTopic + '"'
				pBriCmd = ',"brightness_command_topic":"' + sDimTopic + '/set"'
				pBriTemp= ',"brightness_value_template":"{{ value }}"'
				pBriScale = ',"brightness_scale":100'
				if (category=="colour") {
					pColState = ',"color_temp_state_topic": "' + sColorTopic + '-temperature/temp"'
					pColTempCmd = ',"color_temp_command_topic": "' + sColorTopic + '-temperature/set"'
					//pColTempVal = ',"color_temp_value_template": "{{ ((value | float / 100) * (500 - 153)) + 153  }}"'  
					pColTempVal = ',"color_temp_value_template": "{{ value | round(0)  }}"'  //@jwilliams
                    //pHSState = ',"hs_state_topic": "' + sColorTopic + '/hsv"'
                    pHSState = ',"hs_state_topic": "' + sColorTopic +'"'
					pHSCmd = ',"hs_command_topic": "' + sColorTopic + '/set"'
					//pHSValTemp = ',"hs_value_template": "{{ value_json.h }},{{ value_json.s }}"'
                    pHSValTemp = ',"hs_value_template":"' + "{{value.split(',')[0]}},{{value.split(',')[1]}}" + '"'
					HAtype="light"  // for discovery
					payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pColState+pColTempCmd+pColTempVal+pHSState+pHSCmd+pHSValTemp+pID+'}'
				}
				else payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pOnType+pBriState+pBriCmd+pBriTemp+pBriScale+pID+'}'
			}
		}	
		else if (type=="binary_sensor" | type=="sensor") {
			 // TODO Look at why this is different to above and combine if poss
            sSensTopic="homie/${atomicState.normHubName}/${normalize(name)}"  // the suffix is not used here
			sTopic=sSensTopic+'/'+category
			//pName = '"name":"'+name+'"'
			//pON = ',"payload_on":"'+payON+'"'  // Is this ever needed
			//pOFF = ',"payload_off":"'+payOFF+'"'
			//pDevClass=''
			pState = ',"state_topic":"'+ sTopic + '"'
		
			//if (UOM!='') pUOM = ',"unit_of_measurement":"'+UOM+'"' else pUOM=''
			pIcon = '' // ',"icon":"mdi:power"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			if (type=="binary_sensor") {
				// HA categories for various binary sensors https://www.home-assistant.io/components/binary_sensor/
				// TODO must map binary_sensor payload values to ON OFF
				if (category == "motion") pDevClass = ',"device_class": "motion"'
				else if (category == "contact") {
					pDevClass = ',"device_class": "opening"'  
					//pState = ',"state_topic":"'+ sTopic + '/status"'  // Here we are electing between onoff boolean and the status name e.g active/inactive. Using true:false as HA templates value anyway
				}
				else if (category == "smoke-alarm") pDevClass = ',"device_class": "smoke"'
				else if (category == "carbonMonoxide-alarm") pDevClass = ',"device_class": "gas"'
                else if (category == "presence-sensor") pDevClass = ',"device_class": "presence"'
				else if (category == "water") pDevClass = ',"device_class": "moisture"'
                else if (category == "door") pDevClass = ',"device_class": "door"'                  
                else pDevClass = ',"device_class": "notHandled"'
				//else if (category == "battery") pDevClass = ',"device_class": "battery"'  // LOW/OK indicator, perhaps set if < 10%
				//pON = ',"payload_on":"'+payON+'"'  //TODO check if this is ever needed for boolean sensors - will be for enum
				//pOFF = ',"payload_off":"'+payOFF+'"'   //TODO need a selector here
				pUOM=''
			}
			if (type=="sensor") {
				pUOM=',"unit_of_measurement": "'+UOM+'"'
				pON=''  // remove on:off states from sensor adverts ? Do I need to be more selective say with some (analogue?) 'sensors' that might also have an on:off state ? TODO check
				pOFF=''
                pValTemp = ',"value_template":"{{ value | round(0) }}"'  // acts as convert to int
				if (category == "measure-temperature")  { 
				    pDevClass = ',"device_class": "temperature"'
				    if (tempUnits=="Celsius x.x°C")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
                    else if (tempUnits=="Fahrenheit x.x°F")	pValTemp = ',"value_template":"{{ value | round(1) }}"'
				}
                else if (category == "measure-battery") pDevClass = ',"device_class": "battery"'
                else if (category == "illuminance") pDevClass = ',"device_class": "illuminance"'
                else if (category == "signal_strength") pDevClass = ',"device_class": "signal_strength"'
                else if (category == "humidity") pDevClass = ',"device_class": "humidity"'
                else if (category == "power") pDevClass = ',"device_class": "power"'
                else if (category == "timestamp") pDevClass = ',"device_class": "timestamp"'
                else if (category == "pressure") pDevClass = ',"device_class": "pressure"'
			}				
			payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pDevClass+pState+pUOM+pON+pOFF+pIcon+pDev+pValTemp+pID+'}' 			
		}
    //Casey <
        else if (type=="lock") {
            sLockTopic="homie/${atomicState.normHubName}/${normName}"+'/lock'  //Casey
			pState = ',"state_topic":"'+ sLockTopic + '"'
			pCmd = ',"command_topic":"'+ sLockTopic + '/set"'
    		pLock = ',"payload_lock":"true"'  //default for booleans in homie
	    	pUnlock = ',"payload_unlock":"false"'
            pLocked=',"state_locked":"true"'  //default for booleans in homie
            pUnlocked=',"state_unlocked":"false"'  //default for booleans in homie
			pUOM = ''
			pIcon = '' // ',"icon":"mdi:lock"'
			pDev = ''
			pValTemp = ',"value_template":"{{ value }}"'
			payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pLock+pUnlock+pLocked+pUnlocked+pIcon+pDev+pValTemp+pID+'}'
        }
    else if (type=="cover") {
        sCoverTopic="homie/${atomicState.normHubName}/${normName}"+'/contact'
        sCover2Topic="homie/${atomicState.normHubName}/${normName}"+'/door'
        pState = ',"state_topic":"'+ sCover2Topic + '"'
        pCmd = ',"command_topic":"'+ sCoverTopic + '/set"'
        pCLOSE = ',"payload_close":"close"' //default for booleans in homie
        pOPEN = ',"payload_open":"open"'
        pSTOP = ', "payload_stop": null '
        pUOM = ''
        pIcon = '' // ',"icon":"mdi:garage"'
        pDev = ''
        pValTemp = ',"value_template":"{{ value }}"'
        payload='{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pUOM+pOPEN+pSTOP+pCLOSE+pIcon+pDev+pValTemp+pID+'}'
    }   
    else if (type=="alarm_control_panel") {
            sAlarmTopic="homie/${atomicState.normHubName}/${normalize(name)}/securitymode"  // the suffix is not used here
			pState= ',"state_topic":"' + sAlarmTopic+'"'
			pCmd = ',"command_topic":"' + sAlarmTopic+'/set"'
			pDisarm = ',"payload_disarm":"disarm"'
			pArmHome = ',"payload_arm_home":"armed home"'
			pArmAway = ',"payload_arm_away":"armed away"'
			pArmNight = ',"payload_arm_night":"armed night"'
			pCodeArm = ""
			pCodeDisarm = ""
			pCodeArmTemplate = ""
            pKeyCode=""
			if (mqttKeypadMode == "No control of keypad" || mqttKeypadMode == "No Keycode needed") {
			    pCodeArm = ',"code_arm_required": "false"'                
			}
			else {
			    if (mqttKeypadMode == "Keycode to Arm only") {
					pCodeArm = ',"code_arm_required": "true"'
					pCodeDisarm = ',"code_disarm_required": "false"'
				} else {
                    pCodeArm = ',"code_arm_required": "true"'
					pCodeDisarm = ',"code_disarm_required": "true"'
				}		
				pCodeArmTemplate = ',"command_template":"{{action}},{{code}}"'
			}
			if (mqttKeypadCode != null) {
			    pKeyCode = ',"code":"' + mqttKeypadCode.trim() + '"'
			}			        
			payload = '{'+pName+pAvail+pAvailPay+pNotAvailPay+pUID+pState+pCmd+pCodeArm+pCodeDisarm+pCodeArmTemplate+pKeyCode+pDisarm+pArmHome+pArmAway+pArmNight+pDev+pID+'}'
		}    
        else
        { 
            if (type=="button") log( "Buttons are not supported in HA Discovery","TRACE")
            else if (type=="unknown") log ("Unknown Device type $type presented for HA MQTT Discovery advertise from device $name","INFO")
            else log ("Unknown Device type $type presented for HA MQTT Discovery advertise from device $name","WARN")
        }
        //Casey >
        if (pDevClass=='opening' && category=="contact" && type=="binary_sensor") log ("Blocked HA Discovery for device $normName","WARN")
        else {
		   // if (payload.size()>1 ){  // shouldnt need this anymore although I see sensors keep sensing when activated 
	        if (payload.size()>1 ) {
                mqtt = getChildDevice("MQTT: Child device driver")
			    log ("Sending Discovery: message "+ name + " "  + payload, "TRACE") 
			    if (settings?.HARemember=="Remember") mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/$id/${normName}/config", payload.toString(),1,true)
			    else mqtt.publishMsg ("${settings?.HADiscoveryTopic}/${type}/$id/${normName}/config", payload)
		}
        }
   		atomicState.lastDevice=name  // kludge atm to pair up separate events arriving here for hue and sat - there's another way too (see above)	    
}	

def log(data, type) {
	data = "MQTT: ${data ?: ''}"
    if (determineLogLevel(type) >= determineLogLevel(settings?.logging ?: "INFO")) {
        switch (type?.toUpperCase()) {
            case "TRACE":
                log.trace "${data}"
                break
            case "DEBUG":
                log.debug "${data}"
                break
            case "INFO":
                log.info "${data}"
                break
            case "WARN":
                log.warn "${data}"
                break
            case "ERROR":
                log.error "${data}"
                break
			case "DISABLED":
			    break
            case "BLUE":
                log.info "<font color='blue'>${data}</font>"
                break
            case "RED":
                log.info "<font color='red'>${data}</font>"
                break
            case "ORANGE":
                log.info "<font color='orange'>${data}</font>"
                break
            case "GREEN":
                log.info "<font color='green'>${data}</font>"
                break
            case "YELLOW":
                log.info "<font color='yellow'>${data}</font>"
                break
            case "KGREEN":
                 if (atomicState.myHub) log.trace "<font color='green'>${data}</font>"
                 break
            case "KYELLOW":
                 if (atomicState.myHub) log.trace "<font color='green'>${data}</font>"
                 break
            case "KORANGE":
                 if (atomicState.myHub) log.trace "<font color='orange'>${data}</font>"
                 break
            case "KH":
                 if (atomicState.myHub) log.trace "<font color='red'>${data}</font>"
                 break
            case "LOG":
                 if (atomicState.myHub) log.trace "<font color='blue'>${data}</font>"
                 break
            default:
                log.error "MQTT: -- ${data.label} -- Invalid Log Setting"
        }
    }
}

private removeAllChildDevices() {  
	getChildDevices().each { deleteChildDevice(it.deviceNetworkId) }
	log ("Deleted all child devices", "WARN")
}

private removeAllDiscoveredChildDevices() {  
	getChildDevices().each  {
       // mqttval= it.getDataValue("mqtt")
        try{
        origin=it.getDataValue("origin")
            if (origin!="user") {
                if (it.getTypeName()=="MQTT Client") { 
                   log ("Keeping MQTT client driver","INFO")
                }
                else deleteChildDevice(it.deviceNetworkId)
            }
            else log ("Saved this user created device $it.displayName","TRACE")           
        }
        catch (e) {
            log (" Delete all discovered child devices failed + $e","ERROR")
            return
            }      
    }
     log (" Deleted all discovered child devices ","WARN")
}

//#######################################################################################################################################
//#######################################   This section handles subscriptions to MQTT topics   #########################################
//#######################################################################################################################################


def subscribeShellyTopic() {
	//log ("Adding Shelly status topics","INFO") //
	//mqtt.subscribeTopic('shellies/#')
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.subscribeTopic('shellies/+/onlineRet') // /online  is no use here as is not a retained or updated topic used in LWT (bug in Shelly)
}
def subscribeSonoffTopic() {
	log ("Adding Sonoff property and node subscription topics [Not Yet implemented]","INFO")
	//mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
}

def subscribeHomieTopic() {
    mqtt = getChildDevice("MQTT: Child device driver")
    atomicState.timeStamp=now()
    log ("Starting homie Discovery", "BLUE")
    atomicState.progress = now()
	log ("Adding homie property and node subscription topics for " + atomicState.homie, "INFO")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/$nodes')
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$properties')  //Started using this 
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$type')      //TODO from here could get a device > type list as this returns all devices with a type
}

def subscribeVirtuals() {
            subscribes=[]
            temp = atomicState.topicLink
            getChildDevices().each { dev ->                 
                origin=dev.getDataValue("origin")
                if ((origin == "user")||(origin == "Home Assistant")||(origin == "homie")) {
                    myData=dev.getData()
                    if (myData != null) myData.each { dat ->
                        if (dat.key.endsWith("_Topic")) {
                            jas=dat.value.indexOf("{")
                            topic=dat.value
                            subTopic=topic
                            json=''
                            if ((jas>0) && (dat.value.endsWith(':}'))){
                                subTopic=dat.value.substring(0, jas ) 
                               
                                json=dat.value.substring(jas)
                                     log ("Subtopic is JSON " + subTopic + " " + json,"DEBUG")
                            }
                            if (topic.length()>1) {
                                subscribes.add(subTopic)
                            }
                            if(temp.containsKey(topic)){ 
                             list=temp[topic]       //.add(topic)
                                if (list.contains("$dev.deviceNetworkId")) {
                                }
                                else {
                                    list.add ("$dev.deviceNetworkId")
                                    temp["$topic"]=list 
                                }
                            }
                            else {
                                list=["$dev.deviceNetworkId"]
                                temp["$topic"] = list
                            }                            
                        }
                   }
                } 
            }
    atomicState.topicLink = temp
    log ("Subscribing to $subscribes.size individual device topics","INFO")
    devSubscribes (subscribes)
}

def devSubscribes(subs) {
    mqtt = getChildDevice("MQTT: Child device driver")
    subs.each { topic ->
        mqtt.subscribeTopic(topic)
    }
}

def subscribeHomieStateTopics() {  //TODO Getting returns from these before devices and topicLink are created - delay ??
    mqtt = getChildDevice("MQTT: Child device driver")
	log ("Adding homie onoff & dim events subscription topics ", "INFO")
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/onoff')
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim')
    mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/dim/$format')  // to recover max_Level																							 
    mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')   
}

def subscribeHomieNameTopics() {
    mqtt = getChildDevice("MQTT: Child device driver")
	log ("Adding homie name subscription topics ", "INFO")  
	mqtt.subscribeTopic('homie/'+atomicState.homie+'/+/$name')
    mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/name')  //using this as it returns after all other messages have arrived so know done
}

def start_HADiscovery(evt){
    mqtt = getChildDevice("MQTT: Child device driver")
    if ((evt==null)||(evt.value=="HAstart")){
    if (settings?.homieDiscovery) { // can unsubscribe from these now as no longer used
    time=(int) ((now()-atomicState.timeStamp)/1000)    
    log ("======= homie Discovery has completed in $time secs =======","BLUE")
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$name')
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/+/$unit')
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/$nodes')
	mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$properties')   
	mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/$type')     
	mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/dim/$format')
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/dim')  // as we subscribe individually to nodes now
    mqtt.unsubscribeTopic('homie/'+atomicState.homie+'/+/onoff')  // as we subscribe individually to nodes now
    }
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/name')
        atomicState.timeStamp=now()
    log ("Starting HA Discovery","BLUE")
    	if(settings?.HAStatestream){
		log ("HA stateStream enabled", "INFO")
        delay=0
		runIn (delay, "subscribeHADevices")
 	}
    else {
        log ("Skipping HA stateStream MQTT discovery", "INFO")
         mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done
    }
    }
    else if(evt.value=="complete") { 
        time=(int) ((now()-atomicState.timeStamp)/1000)
        if(settings?.HAStatestream)  log ("=======   HA Discovery has completed in $time secs  ========</b>","BLUE")
        devSummary()
    }
    
	if (atomicState.abort) { 
            abort(6)  // check
            return
    }
}
    
    
    

def subscribeHADevices(evt=null) {  // ToDo - these might benefit from pacing
	log ("Adding HA switches, lights and sensors friendly names topics ", "INFO")
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/device_class') // // this creates device
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// this creates device

    // Now add these individually as discovery is based on device_class
    // doesn't work as a lot of HA devices are missing device_class and so need friendly_name for discovery too
    mqtt.subscribeTopic(atomicState.HA+'/switch/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this creates device
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.subscribeTopic(atomicState.HA+'/lock/+/friendly_name')

    mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/client') // this will run when all the friendly names have arrived       
    // Currently not discovering these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/friendly_name')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/friendly_name')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/friendly_name')
}

def unsubscribeHADevices(evt=null) {
    subscribeHADeviceEvents()
    mqtt = getChildDevice("MQTT: Child device driver")
    // Can't wildcard these as the subs were setup individually
	log ("Unsubscribing from HA switches, lights and sensors friendly names topics ", "INFO")
    mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done    

    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/friendly_name') 
   // mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class') 
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/friendly_name')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/device_tracker/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/climate/+/friendly_name')
    mqtt.unsubscribeTopic(atomicState.HA+'/lock/+/friendly_name')

    mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')
    
    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class') 
    // mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/device_class')
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/device_class')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/device_tracker/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/climate/+/device_class')
    mqtt.unsubscribeTopic(atomicState.HA+'/lock/+/device_class')
     // Currently not discovering these devices :   
    //mqtt.unsubscribeTopic(atomicState.HA+'/automation/+/friendly_name')
    //mqtt.unsubscribeTopic(atomicState.HA+'media_player/+/friendly_name')
	//mqtt.unsubscribeTopic(atomicState.HA+'/persistent_notification/+/friendly_name')
    //mqtt.unsubscribeTopic(atomicState.HA+'/sun/+/friendly_name')
	//mqtt.unsubscribeTopic(atomicState.HA+'/updater/+/friendly_name')
}

def subscribeHADeviceEvents() {// This runs 10 secs after above currently
    
    //Trying to replace these with individual subscribes
    mqtt = getChildDevice("MQTT: Child device driver")
	log ("No longer adding wildcarded HA switch, sensor, and light events topics", "INFO")
/*
    mqtt.subscribeTopic(atomicState.HA+'/switch/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/light/+/brightness')
*/
    mqtt.subscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this also creates device if device_class was missing
//	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/state')// TODO spread /delay a bit
//	mqtt.subscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')// TODO spread /delay a bit
	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
//	mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/state') // TODO spread /delay a bit
	//mqtt.subscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// TODO spread /delay a bit  // moved above as this creates device
/*
    mqtt.subscribeTopic(atomicState.HA+'/group/+/state')
	mqtt.subscribeTopic(atomicState.HA+'/input_boolean/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/person/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/state')
    mqtt.subscribeTopic(atomicState.HA+'/cover/+/current_position')
*/
    //mqtt.subscribeTopic ('homie/'+atomicState.normHubName+'/$fw/version')  //using this to as it returns after all other messages have arrived so know done
    // Currently not handling state updates for these :   
    //mqtt.subscribeTopic(atomicState.HA+'/automation/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/climate/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/device_tracker/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/lock/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'media_player/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/persistent_notification/+/state')
    //mqtt.subscribeTopic(atomicState.HA+'/sun/+/state')
	//mqtt.subscribeTopic(atomicState.HA+'/updater/+/state')

}

def unsubscribeHADeviceEvents() {
    log ("Unsubscribing HA events","INFO")
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.unsubscribeTopic(atomicState.HA+'/switch/+/state')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/state')
	mqtt.unsubscribeTopic(atomicState.HA+'/light/+/brightness')
    //mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/friendly_name') // // this also creates device if device_class was missing
	mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/state')// TODO spread /delay a bit
	//mqtt.unsubscribeTopic(atomicState.HA+'/sensor/+/unit_of_measurement')// TODO spread /delay a bit
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/friendly_name')  // TODO spread /delay a bit
	mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/state') // TODO spread /delay a bit
	//mqtt.unsubscribeTopic(atomicState.HA+'/binary_sensor/+/device_class')// TODO spread /delay a bit  // moved above as this creates device
	mqtt.unsubscribeTopic(atomicState.HA+'/group/+/state')
	mqtt.unsubscribeTopic(atomicState.HA+'/input_boolean/+/state')
    mqtt.unsubscribeTopic(atomicState.HA+'/person/+/state')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/state')
    mqtt.unsubscribeTopic(atomicState.HA+'/cover/+/current_position')   
}

def subscribeOneOffTopics(topic) {
    mqtt = getChildDevice("MQTT: Child device driver")
	mqtt.subscribeTopic(topic)
}

def stringToList(maps) {
    //maps=device.getDataValue("switch_MAP")
    if (maps != null) {
    //log ("Child $child $val [$attr] has mapping of $maps" ,"KH")
    maps=maps.substring(1, maps.length() - 1)
    mapList = maps.split(',')
    return (mapList)
    }
}


def jsonSplit (source,value=null){  // source is the json string and value is any value you want including in returned values
               if(source!=null) {                        
                    jas=source.indexOf("{")  //JSON
                    if ((jas>0) && (source.endsWith(':}'))){  //strip json
                       if (value!=null) embed='{"' + source.substring(jas+1,source.length()-2) + '":"' + value +'"}'
                       else embed=''
                       base=source.substring(0, jas)
                       json=source.substring(jas+1,source.length()-2 ) // ...NB this will be json not {json}
                       return [base,json,embed]
                     }
                   else return [source,'',value]
               }
    else return ['','','']
}

//#######################################################################################################################################
//##############################   This section takes internal events/state changes and updates the devices  ############################
//##############################   It also publishes discovery topics using the  HA MQTT discovery protocol  ############################
//#######################################################################################################################################
//def switched(evt, name=null, type=null, state=null,id=0) {
def switched(evt, name=null, type=null, state=null, device=null) {
    mqtt = getChildDevice("MQTT: Child device driver")
	if (evt!=null)
	{
		device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
        // need to determine if MQTT caused this or HE
        
		//log ("From MQTT ? [$device] $atomicState.lastDev  $name [$state]", "LOG")																  
        if (atomicState.lastDev== "$name [$state]") {
            atomicState.lastDev=''
            //log("Wiping atomicState.lastdev","LOG")
        }
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("switch_Cmd")  
                    if(cTopic!=null) { 
                        maps=device.getDataValue("switch_MAP")
                        mapList = stringToList(maps)
                    }
                        //  log ("States are " + mapList[0] + " and " + mapList[1],"LOG")
                        if (state=='on') {
                            if (mapList[0] != null) state = mapList[0]
                        }
                        if (state=='off') {
                            if (mapList[1] != null) state = mapList[1]
                        } 
                        (cTopic,b,state)=jsonSplit(cTopic,state)
                        log ("(aaa) Sending $state command to MQTT $cTopic  $name [$state] != $atomicState.lastDev","LOG")

                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                }
            }
	    } 
	else 
	{
		xName=name
	}
	if (settings?.homiePublish) {
			normName = normalize(name) 
			if (state=="on") nState = "true" else nState = "false"    //TODO make flexible
            sTopic="homie/${atomicState.normHubName}/${normName}"+'/onoff'
			mqtt.publishMsg (sTopic,nState,1,settings?.homieStatesPersist)
            if (!atomicState.suppress) {
			    sTopic=	"homie/${atomicState.normHubName}/${normName}"		
			    //================  Limited homie spec implemenation ================
                //addProperty(sTopic,"onoff",device)
			    //mqtt.publishMsg (sTopic+'/$properties',"onoff",1,true)  // limited homie implementation
			    mqtt.publishMsg (sTopic+'/$name',name,1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"socket",1,true,atomicState.suppress) 
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,atomicState.suppress) 
			    mqtt.publishMsg (sTopic+'/onoff/$name',name,1,true,atomicState.suppress) 
			    mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
            }
 
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
        checkNodes(1,name)
		if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devicesF"2"
            
			HADiscoveryAdvertise(name,"switch","none",device.id)	
		}
		else if (settings?.HADiscovery) log ("HADiscovery switched discarded for ${name}","DEBUG")
}

def switchedDim(evt, name=null, type=null, state=null, device=null) {  // why do we pass devType in here ??
	mqtt = getChildDevice("MQTT: Child device driver")
    if (evt!=null)
	{
		device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
		log("Device is SwitchedDim ${state}  ${name} ${xName}", "LOG")
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                   cTopic=device.getDataValue("switch_Cmd") 
                   if(cTopic!=null) { 
                        maps=device.getDataValue("switch_MAP")
                        mapList = stringToList(maps)
                    }
                      //  log ("States are " + mapList[0] + " and " + mapList[1],"LOG")                                               
                        if (state=='on') {
                            if (mapList[0] != null) state = mapList[0]
                        }
                        if (state=='off') {
                            if (mapList[1] != null) state = mapList[1]
                        }                        
                        (cTopic,b,state)=jsonSplit(cTopic,evt.value)
                        log ("(bbb) Sending $state command to MQTT $cTopic","LOG")
                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                }
            }
	    

	} 
	else 
	{
        xName=name
		log("Device (synch) switchedDim ${state}  ${name} ${xName}", "DEBUG")
	}


		if (settings?.homiePublish) {
			normName = normalize(name)
            sTopic=	"homie/${atomicState.normHubName}/${normName}"
			if (state=="on") nState = "true" else nState = "false"  // TODO customisable
            mqtt.publishMsg (sTopic+'/onoff',nState.toString(),1,settings?.homieStatesPersist)
            if (!atomicState.suppress){
			    //addProperty(sTopic,"onoff",device)
                    //addProperty(sTopic,"dim",device)		
			    //================ homie spec implementation ================           
			    //mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)   // limited homie implementation
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"light",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$settable',"true",1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/onoff/$name',name.toString(),1,true,atomicState.suppress)  
			    mqtt.publishMsg (sTopic+'/onoff/$datatype',"boolean",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/onoff/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
            }
			//log ("Updated homie/${atomicState.normHubName}/${normName}/onoff to ${nState.toString()}", "ERROR")   // only for log visibility
			//===========================================================
		}
    if (name==null) log ("Bad device name call in [10] $xName $xType","DEBUG")
    checkNodes(2, name) 
	if (settings?.HADiscovery){
		if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"switch","block",device.id)
		}
		else if (settings?.HADiscovery) log ("HADiscovery switchedDim discarded for ${name}","DEBUG")
	}
}

def dimmed(evt, name=null, type=null, state=null,device=null) {
    openHAB=false  // setting true forces reported dim value to 0-1.0
    mqtt = getChildDevice("MQTT: Child device driver")
	if (evt!=null)
	{
	    device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
		log ("Device dimmed ${state}  ${name}", "DEBUG")
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("level_Cmd")
                    (cTopic,b,state)=jsonSplit(cTopic,evt.value)
                    if(cTopic!=null) {
                        log ("(ccc) Sending command to MQTT $cTopic","INFO")
                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                }
            }
	    }

	} 
	else {
		xName=name
		log ("Device (synch) dimmed ${state}  ${name}", "DEBUG")
	}
	
	if (settings?.homiePublish) {
    	normName = normalize(name) 
		//================  Limited homie spec implemenation ================
		sDimTopic="homie/${atomicState.normHubName}/${normName}"+'/dim'
		mqtt = getChildDevice("MQTT: Child device driver")
        
// Kludge for OH
        if (openHAB) {
                float smallDim = state.toInteger()/100
                mqtt.publishMsg (sTopic+'/dim',smallDim.toString())
        }
        else mqtt.publishMsg (sDimTopic,"${state}",1,true)
//END Kludge OH
       
        if (!atomicState.suppress) {
            sTopic="homie/${atomicState.normHubName}/${normName}"
                    //addProperty(sTopic,'onoff',device)
            //addProperty(sTopic,'dim',device)
            //sTopic=sTopic+'/onoff'
		    //mqtt.publishMsg (sTopic+'/$properties',"onoff,dim",1,true)  // limited homie implementation
		    mqtt.publishMsg (sTopic+'/$name',"${name}",1,true)  
		    mqtt.publishMsg (sTopic+'/$type',"light",1,true,atomicState.suppress)
            if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/dim/$settable',"true",1,true,atomicState.suppress)  
		    mqtt.publishMsg (sTopic+'/dim/$name',"${name}",1,true,atomicState.suppress) 
		    mqtt.publishMsg (sTopic+'/dim/$datatype',"integer",1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/dim/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
		    if (openHAB) mqtt.publishMsg (sTopic+'/dim/$format',"0:1",1,true,atomicState.suppress)
            else mqtt.publishMsg (sTopic+'/dim/$format',"0:100",1,true,atomicState.suppress)
		    //===================================================================
        }
	}
    checkNodes(3,name) 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"light","none",device.id)
	}
	else if (settings?.HADiscovery) log ("HADiscovery dimmed discarded for ${name}","DEBUG")
}


//Casey <
def locked(evt, name=null, type=null, state=null, device=null) {
	if (evt!=null)
	{
		name=evt.displayName
		state=evt.value
		xName=evt.name
        device=evt.getDevice()
        origin=device.getDataValue("origin")
        //if (origin!=null & origin=="user") log ("This is a virtual MQTT device  $atomicState.lastDev","KH")
		//log(" Device is a lock - now ${state}  ${name} ${xName}", "LOG")
        //log ("Digital: ${evt.isDigital()}  Physical: ${evt.isPhysical()} Change: ${evt.isStateChange} Source: ${evt.source}", "LOG")
        thisDev= name + " ["+ state +"]"
        if (atomicState.lastDev == thisDev)  {
            log ("Ignore: This is from MQTT","KH")
            }
        else {
            log ("Action: Need to send $state cmd to MQTT","KH")
            attrList=device.getSupportedAttributes()
            index=-1
            for (i=0; i<attrList.size(); i++) {
                //log ("Attribute List ${attrList[i].name}", "KH")
                if (attrList[i].name=='lock') index = i
            }
            //log ("Index found at $index","KH")
            atts = "${attrList[index].getPossibleValues()}" 
            //log ("Possible Values are $atts","KH")
            valList=stringToList(atts)
            index2=-1
            for (i=0; i < valList.size(); i++) {
                if (valList[i]== "${state}") index2 = i
                else if (valList[i]== " ${state}") index2 = i
            }            
            cTopic=device.getDataValue(xName+"_MAP")
            if (cTopic!=null) {
                log ("Map values are $cTopic","KH")
                mapped=stringToList(cTopic)
                log ("IndexMap is " + mapped[index2],"KH")
            }
        }  
	}
	else
	{
		xName=name
		log(" Device (synch) is locked ${state}  ${name} ${xName}", "LOG")
	}

// need to check specific lock is MQTT publish enabled    
	if (settings?.homiePublish) {
		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        if (state=="locked") nState = "true" else nState = "false"    //TODO make flexible
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.publishMsg (sTopic+'/lock',nState,1,settings?.homieStatesPersist)
        if (!atomicState.suppress) {
            //addProperty(sTopic,'lock')			
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',"lock",1,true)  // limited homie implementation
			mqtt.publishMsg (sTopic+'/$name',name,1,true)
			mqtt.publishMsg (sTopic+'/$type',"lock",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$settable',"true",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$name',name,1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$datatype',"boolean",1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/lock/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
        }
			
		    //log ("Updated ${sTopic} to ${nState}", "ERROR")   // only for log visibility
			//===================================================================
	}
    checkNodes(4, name) 
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"lock","none",device.id)
    } else {
        log ("Locked event is NOT null for ${name}","TRACE")
    }
}
//Casey >


def buttons(evt, name=null, type=null, state=null, device=null) {
    
	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
        btnNum = (int) evt.value.toInteger()
		xName=evt.name.toLowerCase()
	}
	else
	{
		xName=name
        log(" Device (synch) is ${state}  ${name} ${xName} ${type}", "DEBUG") 

	}

	if (settings?.homiePublish) {

		normName = normalize(name)
        sTopic="homie/${atomicState.normHubName}/${normName}"
        //addProperty(sTopic,'button')
        mqtt = getChildDevice("MQTT: Child device driver")
        // mqtt.publishMsg (sTopic+'/button/'+"${xName}","${state}",1,true)
        if (type!=null) mqtt.publishMsg (sTopic+'/button/'+"${normalize(type)}","${state}",1,true)
        else {  // this only happens when button has a physical event
            type=evt.name
            mqtt.publishMsg (sTopic+'/button/'+"${normalize(type)}","${state}",1,true) 
            if ((btnNum>=0) && (btnNum < 999)) {
                if (type=='held')mqtt.publishMsg (sTopic+"/button/button-$btnNum","held",1,true)										  
                else {
                    if (type=='pushed' ) mqtt.publishMsg (sTopic+"/button/button-$btnNum","pushed",1,true)
                    else if (type=='doubleTapped') mqtt.publishMsg (sTopic+"/button/button-$btnNum","doubletapped",1,true)
								
                    else if (type=='released') mqtt.publishMsg (sTopic+"/button/button-$btnNum","released",1,true)
                    pauseExecution(1000)
                    mqtt.publishMsg (sTopic+"/button/button-$btnNum","idle",1,true)
                }
            }		 
            else log ("Bad button state $state $btnNum","WARN")
        }           
		mqtt.publishMsg (sTopic+'/button',"${state}",1,settings?.homieStatesPersist)
        if (!atomicState.suppress){
            mqtt.publishMsg (sTopic+'/$name',name,1,true)												
		    mqtt.publishMsg (sTopic+'/$type',"button",1,true,atomicState.suppress)
		    if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)  //  is device always in scope ?						  	
		    mqtt.publishMsg (sTopic+'/button/$settable',"false",1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/button/$name',name,1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/button/$datatype',"integer",1,true,atomicState.suppress)
            mqtt.publishMsg (sTopic+'/button/$format',"0:100",1,true,atomicState.suppress)
		    mqtt.publishMsg (sTopic+'/button/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
        }

																					
    }																																						
    checkNodes(5,name)	 
    if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
			HADiscoveryAdvertise(name,"button","none",device.id)
    } else {
        log ("Button event is NOT null for ${name}","TRACE")
    }
}

def buttonRel () {
    normName = normalize(name)
    sTopic="homie/${atomicState.normHubName}/${normName}"
    mqtt = getChildDevice("MQTT: Child device driver")
    mqtt.publishMsg (sTopic+"/button/button-$btnNum","idle",1,true)
}
/*
def thermostat() {  // TODO Remove from sensors below and place here
    
}
*/
def thermostatDevices(evt, name=null, type=null, state=null, device=null, multiple=false) { 
	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // this is the attribute name
		log ("[t] This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("thermostatDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("thermostatDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
		HAtype='unknown'
		UOM=''
        mqtt = getChildDevice("MQTT: Child device driver")
    	if (settings?.homiePublish) {  //TODO use case rather than if else if
		   sTopic="homie/${atomicState.normHubName}/${normName}"
//        if (!atomicState.suppress){
            if (xType=='temperature'){
				category='measure-temperature'
                HAtype="climate"
                if (device.typeName=="Virtual Thermostat") settable = "true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            
            else if (xType=='humidity'){
				category='measure-humidity'
                HAtype="climate"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                UOM="%"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            
            else if (xType=='battery'){
				category='measure-battery'
                HAtype="climate"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                UOM="%"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            
			else if (xType=="thermostatSetpoint"){  //TODO combine above
				category='thermostat-setpoint'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$settable',"true",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
  
			else if (xType=="heatingSetpoint"){  //TODO combine above
				category='heating-setpoint'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$settable',"true",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            else if (xType=="coolingSetpoint"){  //TODO combine above
				category='cooling-setpoint'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
              }
			}
            else if (xType=="thermostatMode"){  //TODO combine above
				category='mode'
                HAtype="climate"  
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)  
			}
            else if ((xType=="thermostatModes")||(xType=="supportedThermostatModes")){  //TODO combine above
				category='mode'
                HAtype="climate"
                settable="true"
              if (!atomicState.suppress){
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)
                // regex to strip leading [ and trailing ] and ,_ change to ,  
                //choices=choices.replaceAll(", ", ',')
  //NB: State has spaces in the values after each ,
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,atomicState.suppress)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                s= state.toString()
                s=s.substring(0, s.length() - 1)+", idle]"
                mqtt.publishMsg (sTopic+'/'+"state"+'/$format',s,1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
              }
                state=null
			}
            else if (xType=="thermostatOperatingState"){  //TODO combine above
				category='state'
                HAtype="climate"
                settable="false"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/state',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)

            }        
            else if (xType=="thermostatFanMode"){  //TODO combine above
				category='fanmode'
                HAtype="climate"
                settable="true"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                //mqtt.publishMsg (sTopic+'/'+category+'/$mode',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:200',1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)

			}
            else if ((xType=="thermostatFanModes")||(xType=="supportedThermostatFanModes")){
                category='fanmode'
                HAtype="climate" 
                settable="true"
				//mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true)                
                // regex to strip leading [ and trailing ] and ,_ change to ,
                //string=string.replaceAll("^\[|, |]$", ',')
                //choices=choices.replaceAll(", ", ',')
                mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true,atomicState.suppress)
                //log ("State for modes is ${sTopic} ** ${category} ** ${state} ${state.toString()}  ", "DEBUG")
                //mqtt.publishMsg (sTopic+'/'+"state"+'/$format',"${state.toString()},idle",1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				//if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				//mqtt.publishMsg (sTopic+'/'+category+'/$format',state.toString(),1,true)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
                state=null
            } 
            
            else if (xType=="hysteresis"){  // not currently handled
                return
            }
            else if (xType=="schedule"){   // not currently handled
                return
            }
            
			
            else {
				category = 'unknown'
				log ("t Unknown category for type #${xType}# reported by device ${name}","INFO")
                category = 'unknown_'+normalize(xType)
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
              //addProperty(sTopic,category)
              if (!atomicState.suppress){
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"thermostat",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
              }
        }
                if (state!=null) {
                    if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    else if(tempUnits=="Fahreheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }	
	// payON and payOFF vary a lot for sensors so need extra params
    checkNodes(6,name)	
    payON=''
    payOFF=''
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices

		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery thermostat discarded for ${name}","DEBUG")
//        }
}

def keypadDevices(evt, name=null, type=null, state=null, device=null, multiple=false) { // subs must be used in HA discovery as device must be separated into multiple entities
 	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
		log ("keypadDevices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("keypadDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
        mqtt = getChildDevice("MQTT: Child device driver")
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
		HAtype='alarm_control_panel'
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"

            if (xType=='lastCodeName'){  
				category='lastuser'        
            }
            else if (xType=='securityKeypad'){  //TODO
				category='securitymode'
                settable="true"
            }           
		    else if (xType=='motion'){  //TODO
				category='motion'       
            }
            else if (xType=='alarm'){  //TODO
				category='alarm'
            }
            else if (xType=='temperature'){  //TODO
				category='measure-temperature'
              if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"real",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','°C',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','-273:999',1,true,atomicState.suppress)
				    UOM="degrees"
				    HAtype="sensor"
              }
			}
        }        
			else {
				category = 'unknown'
				log ("[k] Unknown Category for type ${xType} reported by device ${name}","INFO")
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
    if (!atomicState.suppress) {
        //addProperty(sTopic,category)
    
            if (xType=='securityKeypad'){
                settable='true'
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
               // mqtt.publishMsg (sTopic+'/'+category+'/$format','[<code>,disarmed,armed home,armed away,armed night]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[<code>,disarmed,armed_home,armed_away,armed_night]',1,true,atomicState.suppress)

            }
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',"keypad",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
        }
                stateValue = ''
                if (state!=null) {
//                  mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                    // HA Discovery needs 'armed_home' -vs- 'armed home'
                    if (settings?.HADiscovery) {
                        stateValue = state.toString().replaceAll("\\s","_")
                    }
                    else {
                        stateValue = state.toString()
                    }
                    mqtt.publishMsg (sTopic+'/'+category,stateValue,1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                }
    checkNodes(7,name)	 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices       
    if (multiple) {
	    HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'_alarm',UOM)  // these are created as sub topics
	}
	else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'_alarm',UOM)  // will only be called once
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")    
}

/*
def garageDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities 
    id=99998888
    otherdevices(evt, name, type, state, device, multiple)
}
*/

def audioDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {
    if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
		log ("audio Devices got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "TRACE")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("audio Devices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","TRACE")
	}
    normName = normalize(name)
    settable="false"
    sTopic="homie/${atomicState.normHubName}/${normName}"
    category=normalize(xType)
    //addProperty(sTopic,category)                          // TODO This is getting called too fast for atomicState to update
	//HAtype='music'
	//UOM=''
    dataType='text'
    settable='false'
    TTS=false
    atomicState.suppress=true
    mqtt = getChildDevice("MQTT: Child device driver")
    if (category=="trackdescription") {
        len=evt.value.length()
        if (len>20){
            checkTTS = evt.value.substring (len-8,len)
            if (checkTTS=="from TTS") {
                log ("Just announced " + evt.value.substring(0, evt.value.length() - 20),"TRACE")
                category="speech"
                settable='true'
                TTS=true
                mqtt.publishMsg (sTopic+'/'+category,evt.value.substring(0, evt.value.length() - 20),1,true)
            }
        }
        if (!TTS) {
             mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)  
        }
       TTS=false
    }
    else if (category=="trackdata") {

            dataType='json'
            mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            def data = parseJson(evt.value)
            xcat='trackdescription'
            mqtt.publishMsg (sTopic+'/'+xcat+'/track',data.name,1,true)
            mqtt.publishMsg (sTopic+'/'+xcat+'/artist',data.artist,1,true)
            mqtt.publishMsg (sTopic+'/'+xcat+'/album',data.album,1,true)
            mqtt.publishMsg (sTopic+'/'+xcat+'/tracknumber',data.trackNumber,1,true)
          
    }
    else if (category=="status") {
            //addProperty(sTopic,'status')
            dataType='enum'
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            mqtt.publishMsg (sTopic+'/'+category+'/$format','[playing,stopped,paused,transitioning]',1,true)
    }
    else if (category=="level"||category=='volume') {
            dataType='integer'
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true)
            //addProperty(sTopic,category)
    }
    else if (category=="mute") {
            dataType='enum'  // ToDO present as boolean ??
            mqtt.publishMsg (sTopic+'/'+category+'/$format','[muted,unmuted]',1,true)
            mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
            //addProperty(sTopic,category)
    }
    else {
        log ("Music: " + xType,"LOG")
        mqtt.publishMsg (sTopic+'/'+category,evt.value,1,true)
    }            
    atomicState.suppress=false
    if (!atomicState.suppress){
        //mqtt.publishMsg (sTopic+'/$properties',category,1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$datatype',dataType,1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$retained','true',1,true,atomicState.suppress)
        mqtt.publishMsg (sTopic+'/'+category+'/$name',evt.displayName,1,true,atomicState.suppress)
    }
}

def locationEvent(evt,name=null,type=null,state=null,device=null,multiple=false) {
    mqtt = getChildDevice("MQTT: Child device driver")
    log.info "Location Alert: $evt.name $evt.value"
    if(evt.name == "mode"){
	    if (settings?.homiePublish) {
			    sTopic=	"homie/${atomicState.normHubName}/hub/mode"
			    mqtt.publishMsg (sTopic,evt.value,1,true)
            return
        } 
    }
    else if (evt.name=="systemStart") {
        //log.info "Location Alert: $evt.value" + (evt.value == "systemStart" ? ",  $evt.descriptionText” : "")
        log  ("===================== Reboot =====================", "INFO")
        unschedule()
        unsubscribe()
        atomicState.appCount=0
	    initialize()
        return
    }

    else if (evt.name=="hsmStatus") {
        sTopic=	"homie/${atomicState.normHubName}/hub/hsmStatus"
	    mqtt.publishMsg (sTopic,evt.value,1,true)
        return
    }
    else if (evt.name=="hsmSetArm") {
        sTopic=	"homie/${atomicState.normHubName}/hub/hsmArm"
	    if ("armAway, armHome, armNight, disarm, armRules, disarmRules, disarmAll, armAll, cancelAlerts".contains(evt.value)) mqtt.publishMsg (sTopic,evt.value,1,true)
        else mqtt.publishMsg (sTopic,'unknown',1,true)
        return
    }
    else if (evt.name=="hsmAlert") {
        sTopic=	"homie/${atomicState.normHubName}/hub/hsmAlert"
	    mqtt.publishMsg (sTopic,evt.value,1,true)
        return
    }
    
    log ("Got an unhandled location event message $evt.name $evt.value","KH")
    sTopic=	"homie/${atomicState.normHubName}/hub/hsm/$evt.name"
	mqtt.publishMsg (sTopic,evt.value,1,true)
}
       
def otherDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities 
	mqtt = getChildDevice("MQTT: Child device driver")
    if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
        log ("otherDevices got called by event [$xType] ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${evt.getDisplayName()}", "DEBUG")
		xName=evt.name
		log ("Device other ${state}  ${name}", "DEBUG")
        log ("lastDev is $atomicState.lastDev        $name [$state]","TRACE")
        if (state=='closed') state='close'  // treat them the same
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    if (xType=='contact') {
                        cTopic=device.getDataValue("contact_Cmd")
                        if (cTopic=='' || cTopic==' ' || cTopic==null) return
                        maps=device.getDataValue("contact_MAP")
                        mapList = stringToList(maps)
                        (cTopic,b,state)=jsonSplit(cTopic,evt.value)
                        if(cTopic!=null) {
                            if (state=='closed') state= mapList[0] else state = mapList[1]
                            log ("(ccc) Sending other [contact=$state] command to MQTT $cTopic","KH")
                            mqtt.publishMsg (cTopic,state,1,false)
                        }
                    }
                    else if (xType=='door') {
                        cTopic=device.getDataValue("door_Cmd")
                        if (cTopic=='' || cTopic==' ' || cTopic==null) return
                        //log.error "CTopic is #$cTopic#"
                        maps=device.getDataValue("door_MAP")
                        mapList = stringToList(maps)
                        (cTopic,b,state)=jsonSplit(cTopic,evt.value)
                        if(cTopic!=null) {
                            if (state=='closing') state= mapList[0] else state = mapList[1]
                            log ("(cdc) Sending other [door=$state] command to MQTT $cTopic","LOG")
                            mqtt.publishMsg (cTopic,state,1,false)
                        }

                        
                    }
                }
	        }        
	    } 
    }
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("otherDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}
	    dType="sensor"
        normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
        // log ("otherDevices called with ${name}/${xType}  ${state.toString()}", "ERROR")
		HAtype='unknown'
        category=xType
		UOM=''
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"            
			if (xType=='motion'){  //TODO
				category='motion'
                HAtype="binary_sensor"
            }
           else if (xType=='alarm'){  //TODO
				category='alarm'
                dType='alarm'
                category='alarm'        
            }
           else if (xType=='contact'){  //TODO
				category='contact'
                settable="true"
                dType='contact'
                HAtype="binary_sensor"
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,close,closed]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
            else if (xType=='cover'){  //TODO
				category='cover'
                settable="true"
                dType='cover'
                HAtype="cover"
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,close,closed]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
           else if (xType=='door'){  //TODO
				category='door'
                settable="false"
                dType='door'
                HAtype="cover"  // TODO has 4 values inc closing opening
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,closed,opening,closing]',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
            }
            else if (xType=='valve'){  
				category='valve'
                dType="valve"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"enum",1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[open,closed]',1,true,atomicState.suppress)
                settable="true"
            }
            else if (xType=='variable'){  
				category='variable'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='text'){  
				category='text'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='suffix'){  
				category='suffix'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='prefix'){  
				category='prefix'
                dType="variable"
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                //mqtt.publishMsg ("homie/${atomicState.normHubName}/variables/${normName}",state.toString(),1,settings?.homieStatesPersist)
                settable="true"
            }
            else if (xType=='voltage'){  //TODO            
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,atomicState.suppress)
				UOM="volts"
				HAtype="sensor"
			}
            else if (xType=='power'){  // TODO is it this or 'energy' above ?
				category='measure-power'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}
            else if (xType=='energy'){  // TODO is it this or 'energy' above ?
				category='measure-energy'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}
      
			else {
				category = 'unknown'
				log ("[o] Unknown Category for type ${xType} reported by device ${name}","INFO")
			}			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
            if (!atomicState.suppress){
                //addProperty(sTopic,category)          
			    mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			    mqtt.publishMsg (sTopic+'/$type',dType,1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
            }
                if (state!=null) {
                    if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    else if(tempUnits=="Fahrenheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                    mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  //                          <<<<<   This publishes the actual event value
                }
    checkNodes(8,name)	
	if (evt==null && id != 99998888) {  // this will limit HADiscovery to startup or 'upon request' for devices
		if (multiple) {
			HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		}
		else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'',UOM)  // will only be called once  // TODO kludged ID
	}
	else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
    } 
}
   
def sensorDevices(evt, name=null, type=null, state=null, device=null, multiple=false) {  // subs must be used in HA discovery as device must be separated into multiple entities
	if (evt!=null)
	{
		name=evt.displayName
        device=evt.getDevice()
		state=evt.value
		xType=evt.name  // attribute name
		log ("[s] This got called by event ${name} with ${state}   ${evt.getDevice()}  ${evt.device.typeName} ${xType} ${evt.getDisplayName()}", "DEBUG")
	} 
	else {
		xType=type
		if (multiple) nameSuffix='_'+type else nameSuffix=''
		xName=name+nameSuffix
		log ("sensorDevices (synch) called with name:${name}    xName: ${xName}    type: ${type} / ${xType}   state: ${state}    multiple: ${multiple}","DEBUG")
	}    
	    normName = normalize(name)
		normxName = normalize(xName)
        settable="false"
		HAtype='unknown'
		UOM=''
        mqtt = getChildDevice("MQTT: Child device driver")
		if (settings?.homiePublish) {  //TODO use case rather than if else if
			sTopic="homie/${atomicState.normHubName}/${normName}"            
//			if (xType=='motion' || xType=='acceleration'){
        if (xType=='switch'){  
			category='onoff'
			HAtype="switch"
			if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
			}
		}
		else if (xType=='motion' || xType=='acceleration'){
				category=xType
				if (!atomicState.suppress) mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="active"
				payOFF="inactive"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				else if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}            
           else if (xType=='push'){  // don't think this can this ever run 
               log ("Button push event running in sensors", "ERROR")
			   category='button'
               if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
               }
				HAtype="button"
			}           
			else if (xType=='contact'){
				category='contact'
				if (!atomicState.suppress) mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)  // Need to choose between boolean and enum
				HAtype="binary_sensor"
				payON="open"
				payOFF="closed"
				if (state==payON) {
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					//mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist,atomicState.suppress)
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}
			else if (xType=='temperature'){
				category='measure-temperature'
                if(tempUnits=="Celsius x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                else if(tempUnits=="Fahrenheit x.x°C" && category=="measure-temperature") state = state.toFloat().round(1)
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
				    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
				    if ((tempUnits=="Fahrenheit °F")||(tempUnits=="Fahrenheit x.x°F")) UOM="°F" else UOM="°C"
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','-460:9999',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true,atomicState.suppress)
                }
				HAtype="sensor"
			}          
 			else if (xType=='humidity'){
				category='measure-humidity'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)				
                }
                UOM="%"
				HAtype="sensor"
			}
			else if (xType=='battery'){
				category='measure-battery'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','%',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
                }
				UOM="%"
				HAtype="sensor"
			}
			else if (xType=='energy'){
				category='measure-energy'   // value and unit enum KWh
				UOM="watts"
			}
			else if (xType=='illuminance'){
				category='measure-illuminance'   // value and unit enum lux
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','Lux',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                UOM="Lux"
                HAtype='sensor'
			}
           else if (xType=='variable'){
				category='variable'   // value and unit enum lux
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"string",1,true,atomicState.suppress)
                settable='true'
                HAtype='sensor'   //needs updating
			}
			else if (xType=='smoke'){
				category='smoke-alarm'  //enum clear|detected|tested
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
            else if (xType=='presence'){
				category='presence-sensor'  //enum home|away
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="present"
				payOFF="not present"
				if (state==payON) {
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='carbonMonoxide'){
				category=xType+'-alarm'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				HAtype="binary_sensor"
				payON="detected"
				payOFF="clear"
				if (state==payON) {
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
                    mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
				// TODO this is an enum value and has a 'tested' variant
			}
           else if (xType=='carbonDioxide'){
				category='measure-carbonDioxide'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				HAtype="sensor"
				// TODO this is an enum value and has a 'tested' variant
			}
			else if (xType=='sound'){
				category='sound-level'   // detected|not detected
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','dB',1,true,atomicState.suppress)
				UOM="dB"
				HAtype="sensor"
			}
			else if (xType=='voltage'){
				category='measure-voltage'
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','volts',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','-999999:999999',1,true,atomicState.suppress)
				UOM="volts"
				HAtype="sensor"
			}
			else if (xType=='power'){  // TODO is it this or 'energy' above ?
				category='measure-power'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}
            else if (xType=='energy'){  // TODO is it this or 'energy' above ?
				category='measure-energy'
                if (!atomicState.suppress){
				    mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$unit','watts',1,true,atomicState.suppress)
				    mqtt.publishMsg (sTopic+'/'+category+'/$format','0:999999',1,true,atomicState.suppress)
                }
				UOM="watts"
				HAtype="sensor"
			}
			else if (xType=='water'){
				category='water'
				HAtype="binary_sensor"
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"boolean",1,true,atomicState.suppress)
				payON="wet"
				payOFF="dry"
				if (state==payON) {
					mqtt.publishMsg (sTopic+'/'+category+'/status',payON,1,settings?.homieStatesPersist)
					state='true'  // Need to choose between boolean and enum
				}
				if (state==payOFF){
					mqtt.publishMsg (sTopic+'/'+category+'/status',payOFF,1,settings?.homieStatesPersist)
					state='false'  // Need to choose between boolean and enum
				}
			}
            else if (xType=="securityKeypad"){
                log ("securityKeypad ${name} reported ${state} in sensors","WARN")
                 }
			else {
				category = 'unknown'
				log ("[s] Unknown Category for type ${xType} reported by device ${name}","DEBUG")  // DEBUG because Unknowns are now converted to custom
			}
			
			sTopic="homie/${atomicState.normHubName}/${normName}"     //+category
			//================  Limited homie spec implemenation ================
			//mqtt.publishMsg (sTopic+'/$properties',category,1,true)   // limited homie implementation //  TODO BUG multiple properties
	        //atomicState.Category=category  // Huge risk here that this gets overwritten before update happens BUG TODO maybe have to check against sTopic
	        //pauseExecution(2000)// TODO need to adjust based on experience getTopic takes ~1800
	        //mqtt.getTopic (sTopic+'/$properties')   // need to append categories to existing ones
        if (!atomicState.suppress) {
            //addProperty(sTopic,category)          
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true)   
			mqtt.publishMsg (sTopic+'/$type',"sensor",1,true,atomicState.suppress)
            if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
            if (category=='unknown') {
                if (device.displayName!=lastDev) {
                    counter=1
                    addProperty(sTopic,'custom',device)
                } else counter = counter +1
                lastDev=device.displayName
                mqtt.publishMsg (sTopic+'/custom',counter.toString(),1,true)
                mqtt.publishMsg (sTopic+'/custom/$datatype','integer',1,true)
                mqtt.publishMsg (sTopic+'/custom/$name',device.displayName,1,true)
                mqtt.publishMsg (sTopic+'/custom/$retained','true',1,true)
                mqtt.publishMsg (sTopic+'/custom/$settable','false',1,true)
                mqtt.publishMsg (sTopic+'/custom/'+xType,state.toString(),1,true) 
            }
            else{
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable',settable,1,true,atomicState.suppress)   
			    mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)  
			    //mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"float",1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
			    //mqtt.publishMsg (sTopic+'/'+category+'/$unit',UOM,1,true)
            }
        }
        if (category!='unknown') {
            //mqtt.publishMsg (sTopic+'/'+category+'/'+xType,state.toString(),1,true)   // DO WE NEED THIS ?
            if (state!=null) {
                mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)  // <<<<<   This publishes the actual event value
                checkNodes(9, name)
	            if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		            if (multiple) {
			            HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,nameSuffix,UOM)  // these are created as sub topics
		            }
		            else  HADiscoveryAdvertise(name,HAtype,category,device.id,payON,payOFF,'',UOM)  // will only be called once
	            }
	            else if (settings?.HADiscovery) log ("HADiscovery sensor discarded for ${name}","DEBUG")
            }
        }
    }
}

def colourDevices(evt, name=null,type=null, state=null, device=null) {
    openHAB=false // setting true forces reported dim value to 0-1.0
    mqtt = getChildDevice("MQTT: Child device driver")

	if (evt!=null)
	{
        device=evt.getDevice()
        name=evt.displayName
		state=evt.value
		xName=evt.name
		xType=evt.name  // this is the attribute name
		log ("Got a colour event " + evt.name + " " + evt.value, "INFO")
        if (atomicState.lastDev== "$name [$state]") atomicState.lastDev=''
        else {
            dType = device.getTypeName()
            if (dType.startsWith("Virtual")) // only allow commands to MQTT from virtuals
            {
                cMQTT=device.getDataValue("mqtt")
                if (cMQTT=="enabled") {
                    cTopic=device.getDataValue("color_Cmd") 
                    if(cTopic!=null) {
                        log ("(ddd) Sending command to MQTT $cTopic","INFO")
                        mqtt.publishMsg (cTopic,state,1,false)
                    }
                }
            }
	    }
    }
	else {
        
		xName=name
		xType=type
		log ("Got a colour synch " + xName + " " + type + " " + state, "DEBUG") 
        if (state==null) log ("State had a null value for $xName $xType","WARN")
	}
    //log ("Received a new colour event ${xType} [$state] from ${name}","LOG")
    
    if (xType=='switch') prop='onoff'
    if (xType=='level') prop='dim'
    if (xType=='colorTemperature') prop='color-temperature'
    if (xType=='hue') prop='color'
    if (xType=='saturation') prop='color'
    if (xType=='hsv') prop='color'
    if (xType=='colorMode') prop='color-mode'
    if (xType=='cMode') prop='color-mode'
    if (xType=='colorName') prop='color-name'
    if (xType=="RGB"||xType=="RGBT") prop='color'
        
    
	normName = normalize(name)
	normxName = normalize(xName)
	sTopic="homie/${atomicState.normHubName}/${normName}"
   // addProperty(sTopic,prop,device)
    
    if (!dAttIsEnabled(device,prop)) {
            log ("$device [$xType] > [$prop] publish topics BLOCKED","INFO")
            return
        }
    else log ("$device [$xType] > [$prop] publish topics PASSED","TRACE")

	if (settings?.homiePublish) {  //TODO case rather than if

        if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true)
		category='unknown'
        if (xType=='switch'){   // hope this doesnt conflict with switchedDim - ot is called
				category='onoff'
            	//HAtype="RGB"
                log("switch in RGB","KH")
            if (!atomicState.suppress) {
                
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
            }
		}
        else if (xType=='dim'){  // DONT think this happens
				category='DIM'
                //HAtype="RGB"
                log("dim in RGB","KH")
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true)
                if (openHAB) mqtt.publishMsg (sTopic+'/'+category+'/$format','0:1',1,true,atomicState.suppress)
				else mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
            }				
		}
		else if (xType=='colorTemperature'){
				category='color-temperature'
            	//HAtype="RGB"
            if (!atomicState.suppress) {
                mqtt.publishMsg (sTopic+'/$type',"CT light",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"integer",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','Kelvin',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','1500:8000',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
            }
                //int mireds=(int)1000000/state.toInteger()
                int mireds=state.toInteger() //@jwilliams
                if (mireds>1000) mireds=(int)1000000/mireds // was Kelvin
                mqtt.publishMsg (sTopic+'/'+category+'/mireds',"${mireds}",1,true)
                mqtt.publishMsg (sTopic+'/'+category+'/temp',"${mireds}",1,true)
				//UOM="%"

		}
		else if (xType=='hue'){
			    category='color'
            	//HAtype="RGB"
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/h',state.toString(),1,settings?.homieStatesPersist,atomicState.suppress)  //unnecessary ?
				//int temp=state.toInteger()
				//temp=(temp*36)/10  //TODO Taken out to keep 0-100 'low' but wary if I should have done so
            }
                //theDevice=evt.getDevice()
                //hueNum=state.toInteger()
                hueNum=device.currentValue("hue")
                Integer LHueNum = (hueNum*3.6).toInteger()
                //hueNum=hueNum*3.6
                satNum=device.currentValue("saturation")
                valNum=device.currentValue("level")                    
                        log ("H: ${hueNum} ${satNum} ${valNum}","DEBUG")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)     // TODO CHECKRGB  
                        mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)
		}
		else if (xType=='level'){  //hope this doesn't conflict with dimmed  (this is dim)
				category='color'
            	//HAtype="RGB"
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
            }
				mqtt.publishMsg (sTopic+'/'+category+'/v',state.toString(),1,settings?.homieStatesPersist)  // TODO Check is this right  // unnecessary ?
                //theDevice=evt.getDevice()
                hueNum=device.currentValue("hue")
                if (hueNum == null) hueNum = 0
                LHueNum = (hueNum*3.6).toInteger()
                satNum=device.currentValue("saturation")
                if (satNum == null) satNum = 0
                valNum=device.currentValue("level")
     
// Kludge for OH
            if (openHAB) {
                float smallDim = valNum/100
                mqtt.publishMsg (sTopic+'/dim',smallDim.toString())
            }
            else  mqtt.publishMsg (sTopic+'/dim',valNum.toString())
//END Kludge OH
                        //log ("V: (${LHueNum}) ${hueNum} ${satNum} ${valNum}","INFO")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true)                   
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             

		}
		else if (xType=='saturation'){   
				category='color'
            	//HAtype="RGB"
            if (!atomicState.suppress) {

				mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
            }
				mqtt.publishMsg (sTopic+'/'+category+'/s',state.toString(),1,settings?.homieStatesPersist)  // unnecessary ??
                //theDevice=evt.getDevice()
                hueNum=device.currentValue("hue")
                LHueNum = (hueNum*3.6).toInteger()                            
                satNum=device.currentValue("saturation")
                valNum=device.currentValue("level")                
                        //log ("S: ${hueNum} ${satNum} ${valNum}","INFO")
                        //oldRGB=hsvToRGB (hueNum*3.6,satNum, valNum,"high")
                        RGB=hubitat.helper.ColorUtils.hsvToRGB([hueNum,satNum, valNum])
                        mqtt.publishMsg (sTopic+'/'+category+'/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,true)
                        mqtt.publishMsg (sTopic+'/'+category,"${LHueNum},${satNum},${valNum}",1,true)             
				//UOM="%"


		}
		else if (xType=="hsv") {
		    category='color'
            //HAtype="RGB"
            if (!atomicState.suppress) {			
				mqtt.publishMsg (sTopic+'/$type',"RGBT light",1,true,atomicState.suppress)
                if (device!=null) mqtt.publishMsg (sTopic+'/-device-driver',device.typeName,1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype',"color",1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$unit','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$format','hsv',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/h',state[0].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/s',state[1].toString(),1,settings?.homieStatesPersist)
				//mqtt.publishMsg (sTopic+'/'+category+'/v',state[2].toString(),1,settings?.homieStatesPersist)  // TODO Check is this right
				//mqtt.publishMsg (sTopic+'/color',"${state[0]},${state[1]},${state[2]}",1,settings?.homieStatesPersist)
	   			mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,atomicState.suppress)
            }
    //jwilliams for Ikea Tradfri tolerance  // I may have messed this up again now                    
            if (state[0] != null) hue = state[0].intValue()
            else {
                hue = device.currentValue("hue")
                //state[0]=hue
            }
            LHueNum = (hue*3.6).toInteger()
            if (state[1] != null) sat = state[1].intValue()
            else {
                   sat=device.currentValue("saturation")
                   //state[1]=sat
            }
            if (state[2] != null) val = state[2].intValue()
            else {
                   val=device.currentValue("level")
                   //state[2]=level
            }    
     // end jwilliams
            
        
            mqtt.publishMsg (sTopic+'/color',"${LHueNum},${sat},${val}",1,settings?.homieStatesPersist)
		        //mqtt.publishMsg (sTopic+'/color','{"h":'+state[0].toString()+',"s":'+state[1].toString()+',"v":'+state[2].toString()+'}',1,settings?.homieStatesPersist)
                //if (state[2] == null) int val=99 else int val=state[2].intValue()     
                //oldRGB=hsvToRGB (hue*3.6,sat, val,"high")
                RGB=hubitat.helper.ColorUtils.hsvToRGB([hue,sat, val])          
                mqtt.publishMsg (sTopic+'/color/rgb',hubitat.helper.ColorUtils.rgbToHEX(RGB),1,settings?.homieStatesPersist)            
                // mqtt.publishMsg (sTopic+'/'+category,"[${hueNum},${satNum},${valNum}]",1,true)   // TODO check - should this be enabled             
         
		}
	    else if (xType=='onoff'){   // Dont think this happens  - this topic created by the 'switched' event
			category='ONOFF'
            //HAtype="RGB"
            log("onoff in RGB","KH")
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','boolean',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$unit','?',1,true,atomicState.suppress)
				//mqtt.publishMsg (sTopic+'/'+category+'/$format','0:100',1,true)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','true',1,true,atomicState.suppress)	
				//UOM="%"
            }
				
		}

        else if (xType=='colorName'){   // hope this doesnt conflict with switchedDim - ot is called
			category='color-name'
            //HAtype="RGB"
            if (!atomicState.suppress) {
				mqtt.publishMsg (sTopic+'/'+category+'/$datatype','text',1,true,atomicState.suppress)
				mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
            }        
		}
        else if (xType=="cMode") {
            category='color-mode' // this is a temporary kludge TODO better
			//HAtype="RGB"
            if (!atomicState.suppress) {
                //mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[CT,RGB]',1,true,atomicState.suppress)
            }
        }
         else if (xType=="colorMode") {
            category='color-mode' // this is a temporary kludge TODO better
			//HAtype="RGB"
            if (!atomicState.suppress) {
                //mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$datatype','enum',1,true,atomicState.suppress)
			    mqtt.publishMsg (sTopic+'/'+category+'/$settable','false',1,true,atomicState.suppress)
                mqtt.publishMsg (sTopic+'/'+category+'/$format','[CT,RGB]',1,true,atomicState.suppress)
            }
        }
        else if (xType=="RGB"||xType=="RGBT") {
            category='color' // this is a temporary kludge TODO better
			log ("Ignoring ${xTYPE} for  ${name.toString()} value ${state.toString()}","WARN")
			return  // This is overwriting color attribute with #FFFFFF as currentColor() returns that so dont action
		}
        else if (xType=='rgbInit'){
                //mqtt.publishMsg (sTopic+'/'+category+'/hsv','right place',1,true,atomicState.suppress)
            }
       // else HAType="nowt"
        else if (xType=='color'){
            log ("color attribute in [$dev] colourDevices [$state]","LOG")
            category="colour"
            return
            }
 
        
        if (category=="unknown") {
            log ("Need to handle ${xType}  - for ${name.toString()} in RGB colour", "WARN")
            //log ("Just published unknown [$xType] for ${name.toString()} payload ${state.toString()}","LOG")
            category="unknown_${xType.toLowerCase()}"
        }
            
        if (!atomicState.suppress){
//            addProperty(sTopic,category,device)
			mqtt.publishMsg (sTopic+'/$name',name.toString(),1,true) 
//			mqtt.publishMsg (sTopic+'/$type',"RGBT light",1,true,atomicState.suppress)
		 	mqtt.publishMsg (sTopic+'/'+category+'/$name',name.toString(),1,true,atomicState.suppress)
            //  mqtt.publishMsg (sTopic+'/'+category+'/xType',xType.toString(),1,true,atomicState.suppress)
			mqtt.publishMsg (sTopic+'/'+category+'/$retained',(settings?.homieStatesPersist).toString(),1,true,atomicState.suppress)
        }
        if (state=="on") state = "true" 
		else if (state=='off') state = "false"  // TODO customisable
        // if (category == 'unknown' ) mqtt.publishMsg (sTopic+'/'+category + '/' + xType,state.toString(),1,settings?.homieStatesPersist)
        if (!dAttIsEnabled(device,category)) {
            log ("$device $category publish state BLOCKED","WARN")
            return
        }
        if ("${category}" != 'color') {  // hue was overwriting color map - need to check why I even do next publish TODO BUG ? 
            //log ("HSV value update blocked","DEBUG")
            //log ("Published $state to $sTopic/$category","KH")
            if (state!=null) mqtt.publishMsg (sTopic+'/'+category,state.toString(),1,settings?.homieStatesPersist)
            else log ("State was null so didn't update MQTT for $sTopic","WARN")
        }
    
	//	mqtt.publishMsg (sTopic+'/color/r',255,1,settings?.homieStatesPersist)  /? TODO What is this for ? HA ? Red ? but no g or b ??	
	//  {"h":216,"s":100,"v":67}
	//  TODO BUG refine this by checking name matches (if use this)
	//	mqtt.publishMsg (sTopic+'/color',"${extractInt(atomicState.hue)},${extractInt(atomicState.sat)},${extractInt(atomicState.lev)}",1,settings?.homieStatesPersist)
    //  mqtt.publishMsg (sTopic+'/color/$format','hsv',1,true,atomicState.suppress)
	//	mqtt.publishMsg (sTopic+'/color/hsv','{"h":'+extractInt(atomicState.hue)+',"s":'+extractInt(atomicState.sat)+',"v":'+extractInt(atomicState.lev)+'}',1,settings?.homieStatesPersist)
	}
    checkNodes(10, name) 
	if (evt==null) {  // this will limit HADiscovery to startup or 'upon request' for devices
		HADiscoveryAdvertise(name,"light","colour", device.id)
	}
	else if (settings?.HADiscovery) log ("HADiscovery RGB discarded for ${name}","DEBUG")	
}
def checkNodes(p,name) {
        normName=normalize(name)
    if (name==null) {
            log ("[$p] null node name ", "WARN")
    }
        else if (atomicState.nodes.contains("$normName")){}
        else {
             atomicState.nodes+=','+normName
            if (settings?.homiePublish) {
                mqtt = getChildDevice("MQTT: Child device driver")
                mqtt.publishMsg ("homie/${atomicState.normHubName}/"+'$nodes',atomicState.nodes,1,true,atomicState.suppress)
        }
        }
}


//#######################################################################################################################################
//#########################   This section adds the names to the dropdown selectors and creates the devices   ###########################
//#######################################################################################################################################

def homieOnOffDev(name,type) {
	temp = atomicState.onoffDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list:OnOff $name", "TRACE")
	}
	else { 
		log ("Adding to dropdown list:OnOff $name", "TRACE")
		temp.add(name)
		atomicState.onoffDevices=temp
	}
	if ((settings?.Homie_onoff != null) && (settings?.Homie_onoff.contains (name))) createChildDevice (name, "onoff", "homie", name)
}

def homieDimDev(name,type) {  //TODO merge with above
	temp = atomicState.dimDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list:Dimmer $name", "TRACE")
	}
    
	else {
		log ("Adding to dropdown list:Dimmer $name", "TRACE")
		temp.add(name)
		atomicState.dimDevices = temp
	}
    if ((settings?.Homie_dim != null) && (settings?.Homie_dim.contains (name))) createChildDevice (name, "dim", "homie", name)
}

def homieButtonDev(name,type) {
	temp = atomicState.buttonDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list: $name", "TRACE")
	}
	else { 
		log ("Adding to dropdown list: $name", "TRACE")
		temp.add(name)
		atomicState.buttonDevices=temp
	}
		if ((settings?.Homie_button != null) && (settings?.Homie_button.contains (name)))  createChildDevice (name, "button", "homie", name)
}

def homieVariableDev(name,type) {
    temp = atomicState.varDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list: $name", "TRACE")
	}
	else { 
		log ("Adding to dropdown list: $name", "TRACE")
		temp.add(name)
		atomicState.varDevices=temp
	}
		if ((settings?.Homie_variable != null) && (settings?.Homie_variable.contains (name))) createChildDevice (name, "variable", "homie", name)
}

def homieSensorDev(name,type) {  //TODO merge with above
	temp = atomicState.sensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
	log ("Already in list: $name", "TRACE")
	}
	else {
		log ("Homie adding sensor to list: $name", "TRACE")
		temp.add(name)
		atomicState.sensorDevices = temp
	}
	if ((settings?.Homie_sensor != null) && (settings?.Homie_sensor.contains (name))) createChildDevice (name, "sensor", "homie", name)
}

def homieUnknownDev(name,type) { //TODO merge
    atomicState.homieUnknownDevices=[]
	temp = atomicState.homieUnknownDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
	    log ("Already in homie unknown list: $name", "TRACE")
	}
	else {
		log ("homie adding to unknown list: $name", "TRACE")
		temp.add(name)
		atomicState.homieUnknownDevices = temp
	}
    log ("homie currently unsupported device $name $type", "WARN")
	//if ((settings?.Homie_unknowns != null) && (settings?.Homie_unknowns.contains (name))) createChildDevice (name, "unknown", "Shelly", name)
}

//Casey <
def homieLockCapability(name,type) { 
	temp = atomicState.lockDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in dropdown list: $name", "TRACE")
	}
	else {
		log ("Adding to dropdown list: $name", "TRACE")
		temp.add(name)
		atomicState.lockDevices=temp
	}
	if ((settings?.Homie_lock != null) && (settings?.Homie_lock.contains (name)))createChildDevice (name, "lock", "homie", name) 
}
//Casey >
def ShellyDev(name,state) {
    log ("Found Shelly Device $name but not yet supported","INFO")
    if (payload[0] == "true") log  ("(Shelly device $name is online)", "LOG")
    else if (payload[0] == "false") log  ("(Shelly device $name is online)", "LOG")

/*
    shellyType=name.substring(0,name.indexOf('-'))
    if (shellyType=='shellyswitch25')
    {
       onoffCapabilityShelly(name + ' relay 0')
       onoffCapabilityShelly(name + ' relay 1') 
    }
    else log ("currently unsupported type #${shellyType}#","WARN")
*/
}
def dimCapabilityShelly(evt) { //TODO merge
    log  ("Shelly Dim  support not implemented yet !", "WARN")
}

def onoffCapabilityShelly(evt) { //TODO
	temp = atomicState.ShellyDevices
    def data = parseJson(evt.data)
	if (temp==null) temp=[]
	if (temp.contains(name)) {
	log ("Already in list: $name", "TRACE")
	}
	else {
		log ("Shelly adding relay to list: $name", "TRACE")
		temp.add(name)
		atomicState.ShellyDevices = temp
	}
	if ((settings?.ShellyDevices != null) && (settings?.ShellyDevices.contains (name)))createChildDevice (name, "onoff", "Shelly", name)  
}



def HASwitchFriendlyP(name,label,type) {
    temp = atomicState.HASwitchDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding switch to list: $name label ", "TRACE")
		temp.add(name)
		atomicState.HASwitchDevices = temp
	}
    if ((settings?.HA_Switches != null) && (settings?.HA_Switches.contains (name)))  createChildDevice (name, type, "HA", label)
}


def HALightFriendlyP (name,label,type){
    temp = atomicState.HALightDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log("Already in list: ${name}", "TRACE")
	}
	else {
		log ("HA Adding light to list: ${name}  label ", "TRACE")
		temp.add(name)
		atomicState.HALightDevices = temp
	}
	if ((settings?.HA_Switches != null) && (settings?.HA_Switches.contains (name))) createChildDevice (name, type, "HA", label)  
}

def HASensorTypeP (topic2,payload,topic1) {    //   (topic[2],deQuote(payload[0]),topic[1])
    HASensorType(topic2,payload,ctopic1)
}


def HASensorType(topic2,payload,topic1) { //device_type
    sType=payload
    log ("HA Sensor $topic2 device_type $sType","TRACE")
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]
    label=topic2
    //if (data.label==null) label=name
	if (temp.contains(topic2)) {
		log ("Already in list: $topic2", "TRACE")
	}
	else {
		log ("HA Adding sensor to list: $topic2  $label ", "LOG")
		temp.add(topic2)
		atomicState.HASensorDevices = temp
	}
	//createChildDevice (topic2, topic1, "HA", label, sType)
}

def HASensorFriendlyP (name,label,type) {
	temp = atomicState.HASensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log ("Already in list: ${name}", "TRACE")
	}
	else {
		log ("HA Adding sensor to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HASensorDevices = temp
	}
        if ((settings?.HA_Sensors != null) && (settings?.HA_Sensors.contains (name)))  createChildDevice (name, type, "HA", label)
} 

def HABinarySensorDevP (name,label,type) {
  	temp = atomicState.HABinarySensorDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
        //log ("Already in list: $name $type", "TRACE")
	}
	else {
		log ("HA Adding binary sensor to list: $name  $type", "TRACE")
		temp.add(name)
		atomicState.HABinarySensorDevices = temp
	}
    if ((settings?.HA_BinarySensors != null) && (settings?.HA_BinarySensors.contains (name)))  createChildDevice (name, type, "HA", name, type)     
}




def HAGroupFriendlyP(name, label , type) {  // TODO merge with above
	temp = atomicState.HAGroupDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding group to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HAGroupDevices = temp
	}
	if ((settings?.HA_Groups != null) && (settings?.HA_Groups.contains (name))) createChildDevice (name, type, "HA", label)
}

def HACoverFriendlyP(name, label, type) {  // TODO merge with above
	temp = atomicState.HACoverDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding cover to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HACoverDevices = temp
	}
    if ((settings?.HA_Covers != null) && (settings?.HA_Covers.contains (name)))  createChildDevice (name, type, "HA", label)
}
    
def HALockFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HALockDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding lock to list: $name  $type ", "TRACE")
		temp.add(name)
		atomicState.HALockDevices = temp
	}
	if ((settings?.HA_Locks != null) && (settings?.HA_Locks.contains (name))) createChildDevice (name, type, "HA", label)
}
    
def HAClimateFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HAClimateDevices
	if (temp==null) temp=[]
	label=payload
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding climate to list: $name  label ", "TRACE")
		temp.add(name)
		atomicState.HAClimateDevices = temp
	}
	if ((settings?.HA_Climates != null) && (settings?.HA_Climates.contains (name)))  createChildDevice (name, type, "HA", label)

}
def HAClimateEventP(name,payload,type) { 
    log ("TODO: Climate Control from HA not implemented yet $name  $payload  $type","WARN")
}
    
def HADeviceTrackerFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HADeviceTrackerDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding device tracker to list: $name  label ", "TRACE")
		temp.add(name)
		atomicState.HADeviceTrackerDevices = temp
	}
    if ((settings?.HA_DeviceTrackers != null) && (settings?.HA_DeviceTrackers.contains (name))) createChildDevice (name, type, "HA", label)
}
def HAInputBooleanFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HAInputBooleanDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding group to list: $name $type ", "TRACE")
		temp.add(name)
		atomicState.HAInputBooleanDevices = temp
	}
    if ((settings?.HA_InputBooleans != null) && (settings?.HA_InputBooleans.contains (name)))  createChildDevice (name, type, "HA", label)
}


def HAPresenceFriendlyP(name,label,type) {  // TODO merge with above
	temp = atomicState.HAPresenceDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		//log ("Already in list: $name", "TRACE")
	}
	else {
		log ("HA Adding group to list: $name $type ", "TRACE")
		temp.add(name)
		atomicState.HAPresenceDevices = temp
	}
    if ((settings?.HA_Presence != null) && (settings?.HA_Presence.contains (name)))  createChildDevice (name, type, "HA", label)
}
def HAUnknown(name,payload) { //TODO merge with above
	temp = atomicState.HAUnknownDevices
	if (temp==null) temp=[]
	if (temp.contains(name)) {
		log("Already in HA unknown list: $name", "TRACE")
	}
	else {
		log ("HA Adding unknown to list: $name  label ", "TRACE")
		temp.add(name)
		atomicState.HAUnknownDevices = temp
	}
    log ("HA unsupported device $name", "INFO")
	//createChildDevice (name, type, "HA", name)
}


def wildcardTopics(topics) {  // TODO merge with above
	temp = atomicState.devTopics
	if (temp==null) temp=[]
	if (temp.contains(topics)) {
		log ("Already in list: $topics", "WARN")
	}
	else {
		log ("Adding wildcarded topic to list: $topic", "WARN")
		temp.add(topic)
		atomicState.devTopics = temp
	}
}

//########################################################################################################################################
//###########################  This section finds the device from incoming MQTT 'set' message to allow control   #########################
//########################################################################################################################################

def checkTopicLink(devID) { 
        list2=[]
        log ("Looking for $devID","DEBUG")
        if(atomicState.topicLink.containsKey(devID)){ 
        list2=atomicState.topicLink[devID]      
        if (list2.size==1) log ("[$devID] Got $list2.size device topicLink matches [$list2]", "TRACE")
        else log ("[$devID] Got $list2.size device topicLink matches [$list2]", "TRACE")
    }
    else log ("topicLink lookup for $devID failed","TRACE")
    return list2
}

def lookupP (param,message,topic,json) {
    //log (" [lookupP] I got called $param $message $topic $json" ,"LOG")
    LookupManual(param,message,topic,json)
    return
}


def LookupManual (param,message,topic,json) {
    def found=false
	def dimDevice=false
	def onoffDevice=false
	def textDevice=false
    def varDevice=false
    def contactDevice=false
    def temperatureDevice=false	
    value=param

    deviceID=topic
    //if (data.json=="true") json=true else json=false
    if (json=="true") json=true else json=false   
    found=false
    if (json){
        list=[]
        jsonVal=parseJson(message)   // There is no evt BUG ??
        for (e in jsonVal) {
            // TODO handle single level nested JSON but currently no more
            // format is topic1/topic2/topic3{json1:{json2:}}  or {json1:{json2:}} ???

            jValue="${e.value}"
            jKey="${e.key}"
            //log ("${e.key} : ${e.value}","LOG")

            //if (value.startsWith('[') && value.endsWith(']')) log ("This has a nested json payload ${value}","LOG")
            jsonTopic=deviceID+"{${e.key}:}"
            list=checkTopicLink (jsonTopic)
            if (list.size>0) {
               found=true
               
               //log ("FOUND JSON [$list.size]  $list $jsonTopic","LOG")
                // if (jsonTopic.endsWith ('}}')) log ("This is a nested JSON topic " + jsonTopic , "KH")
               list.each { DNI -> 
                   // TODO if nested need to call with nested json keys
                   if (value.startsWith('[') && value.endsWith(']')) log("TODO: Nested JSON $value","KH")
                   LookupAction(DNI,jKey,jValue,json,deviceID)
               }

            }
        }
    }

    else {  // Not json > only one value
        list = checkTopicLink (deviceID)
        //if (list.size>0) log ("FOUND list [$list.size]  $list","LOG")    
    
        if (list.size>0) {
            found=true
           list.each { DNI -> 
               //log ("Calling with $DNI","LOG")
               LookupAction(DNI,'',value,json,deviceID)
           }
        }
    }


    if (!found) log ("# OK but lookup failed for [$deviceID] in topicLink #","KH")

}

def LookupAction(LookupID,jKey,jValue,json,deviceID) {
        if (LookupID != null) {	
        device=getChildDevice(LookupID.toString())
        if (device) {
            data4=device.getData()  // device not valid ??
            //if (data4['mqtt']=="true") {  // need to include 'auto' ?
                data4.each { key, val ->
                  if ((val != null) && (val != "") && (val != " ")) {
                    if (key.endsWith ("_Topic")||(key.endsWith ("_Cmd"))) {  // Do we want to map command topics ??  //TODO I think I need a value comparison to data.topic
                      attr = key - "_Topic"
                      attr = attr - "_Cmd"  
                      if (json==true) {
                          if (attr.contains(':==')) log.error "We have a test $attr"
                          if (attr.toLowerCase().contains(jKey)){ 
                          //log ("Matched $attr [$value] value $jKey [$jValue]","LOG")
                          updateDeviceAttribute(device,attr,jValue) 
                          }
                      }
                      else dev2match=deviceID
                          if (val == dev2match) {   
                              if (key.endsWith ("_Topic")) {
                              updateDeviceAttribute(device,attr,jValue)
                              }
                      }
                   }
               }
           }
       }
   }
}

 

def updateDeviceAttribute(device,attr,value) {
                devType=device.getTypeName()
                //log("Virtual device $device [$devType] found in topicLink $attr update [$value]","LOG") 
                found=true 
                //atomicState.lastDev="$device [$value]"   // This updates to the last value on MQTT ie the _MAP value
                if (devType.contains("Sensor")||devType=="Virtual Presence"){  // Why do I want to know if it's a sensor ??
                    atomicState.lastDev="$device [$value]"   // This updates to the last value on MQTT ie the MAP value or in this case a sensor value
                    sensorAction (device, devType,value,attr)
                    return
                }
                else deviceAction (device, devType,value,attr)  
}

    
def deviceAction (child,devType,value,attr=null)  {
    //isEnum=false   / can reinstate if choices get larger and has a speed advantage
    maps=child.getDataValue("$attr" + "_MAP")
    if ((maps != null)&&(maps!=' ')&&(maps!='')) {
        //isEnum=true
        //log ("Child $child $value [$attr] has mapping of $maps" ,"KH")
        maps=maps.substring(1, maps.length() - 1)
        mapList = maps.split(',')
        if (mapList==null) {
            log ("MapList was null for $child  $attr","INFO")
            return
        }
    }    

    if (attr!=null && mapList!=null && attr=='switch') { // && child.hasCommand('off')) {  //assume it will have 'on' too

        if (mapList[0] == value) {
            atomicState.lastDev="$child [on]"   // This normally updates to the last value on MQTT ie the MAP value
            child.on() 
        }
        else if (mapList[1] == value){
            atomicState.lastDev="$child [off]"   // This normally updates to the last value on MQTT ie the MAP value
            child.off()
        }
        }

   else if (attr=='level'&& child.hasCommand('setLevel')) {
            log ("Actioning a level device $child $value","LOG")
            try {  // see if its numeric  // LookupLevel should be valid
					float convertedNumber = Float.parseFloat(value)  // TODO messy and repeatedly used
                     LookupLevel=child.getDataValue("max_Level")
					 log ("MaxLevel is $LookupLevel and name is $child","TRACE")
                     if (LookupLevel == "null" || LookupLevel==null)
					 {
						 if (devType=="system")child.setLevel (value.toInteger(),0)
                         //child.setLevel (value.toInteger(),0)
                         val=value.toInteger()
                         child.setLevel (val,0)
                         atomicState.lastDev="$child [$val]"   // This updates to the last value on MQTT ie the MAP vlaue
						 log ("There's no corresponding MaxValue for " + data.topic, "WARN")
					 }
					else {
                        val = convertLevel (value.toInteger(), LookupLevel.toInteger())
						log ( " The numeric payload for " + child.name + " was converted from " + value + " to " + val, "DEBUG")
						//if (vDev) child.setLevel(intLevel,1)
                        child.setLevel(val,1)
                        atomicState.lastDev="$child [$val]"   // This normally updates to the last value on MQTT ie the MAP vlaue
                        //else child.toLevel(adjLevel,1) 
					}
			}
			catch (Exception e1) {
                   log ("This payload wasnt numeric  " + value + "  " + evt.data + "  " + e1, "WARN")
				}
        }
        else if (attr=='variable' && child.hasCommand('setVariable')) child.setVariable(value)
        else if (attr=="text"){
            if (child.hasCommand('updateText')) child.updateText (value)  // my MQTT Text driver
            else if (child.hasCommand('setText')) child.setText (value)
        }
        else if (attr=="lock"){
           log ("Lock is " + value + "===" + mapList[0]+"===" +mapList[2], "INFO")
           if (mapList[0] == value) {
            atomicState.lastDev="$child [locked]"   // This normally updates to the last value on MQTT ie the MAP value
            child.lock()            
            }
          else if (mapList[1] == value){
            //atomicState.lastDev="$child [test]"   // This normally updates to the last value on MQTT ie the MAP value
            //child.test()
          }
          else if (mapList[2] == value){
            atomicState.lastDev="$child [unlocked]"   // This normally updates to the last value on MQTT ie the MAP value
            child.unlock()
          } 
        }
        else if (attr=="smoke"||attr=="carbonMonoxide"){  // not a sensor as has 'test' command
           if (mapList[0] == value) {
            atomicState.lastDev="$child [detected]"   // This normally updates to the last value on MQTT ie the MAP value
            child.clear()            
            }
          else if (mapList[1] == value){
            atomicState.lastDev="$child [test]"   // This normally updates to the last value on MQTT ie the MAP value
            child.test()
          }
          else if (mapList[2] == value){
            atomicState.lastDev="$child [clear]"   // This normally updates to the last value on MQTT ie the MAP value
            child.detected()
          }   
        }
    else if (attr=="door"){
    }
    else if (attr=="contact"){
        child.sendEvent(name:"door", value:value)
        if ((mapList[0] == value )||(mapList[0]=='close' && value=='closed')) {
            atomicState.lastDev="$child [close]"   // This normally updates to the last value on MQTT ie the MAP value
            //child.close() // This only ever reports status
            child.sendEvent(name:"contact", value:"closed")
            //child.sendEvent(name:"door", value:value)           
        }
        else if (mapList[1] == value){
            atomicState.lastDev="$child [open]"   // This normally updates to the last value on MQTT ie the MAP value
            child.open()
            child.sendEvent(name:"contact", value:"open")
            //child.sendEvent(name:"door", value:value)
        }
    }
    else log ("No attribute [$attr] for $child - maybe _MAP value missing ?", "WARN")
  //  }   
}    

//#######################################################################################################################################
//############################   This section handles MQTT 'set' events/state changes and updates the devices   #########################
//#######################################################################################################################################

int convertLevel (int level,int scale){
    convertedNumber = level * ((float)(100)/(float)(scale))  //think this will work for 1.0 too
	intLevel = convertedNumber.round()					
    return (intLevel)
}


def onoffEventP (name,status,type) {
    
    //def data = parseJson(evt.data)
    //log ("event data: ${data}", "INFO")
	log ("Received an OnOff event from $name turned $status", "TRACE")
	child=getChildDevice("MQTT:homie_"+name)  // for homie devices   
    if (child==null) child=getChildDevice("MQTT:HA_[" + type +"]_" + name)  //TODO check this method is only for HA devices ..  
	if (child != null) log  ("Got " + child + " [" + + child.getSupportedAttributes().size() + "] " + child.getSupportedAttributes(), "DEBUG")
    else {
        log ("Couldn't find child $name","KH")
        return
    }
    
    myON = child.getDataValue("switch_ON")
    myOFF = child.getDataValue("switch_OFF")
    myMap = child.getDataValue("switch_MAP")
    try{
        if (myMap != null) {
            mapList=stringToList(myMap) // [on,off]
            if (mapList[0] == status) child.on()
            else if (mapList[1] == status) child.off()
        }
        else if (status==myOFF) child.off()
        else if (status==myON)  child.on()
    }
    catch (e) {
        log ("Failed to control onoff device $name" + e,"WARN")
    }
    
}


def formatP (name,format) { 
    //def data = parseJson(evt.data)
    child=getChildDevice("MQTT:homie_"+name)
    if (child != null){
     // index=data.format.lastIndexOf(":") + 1  
        index=format.lastIndexOf(":") + 1
        if (index >0) child.updateDataValue("max_Level",format.substring(index))
    }
     
} 								  
def dimEventP (name,level,type,max) {
    log ("Received a dim event from $name level $level is $type", "DEBUG")
	child=getChildDevice("MQTT:homie_"+name)
    if (child==null) child=getChildDevice("MQTT:HA_[" + type+"]_"+name)
    if (child==null) {
        log ("Couldn't find dim child called $name" , "WARN")
        return
    }
    //log  ("Got " + child + " [" + + child.getSupportedAttributes().size() + "] " + child.getSupportedAttributes(), "KH")
    myMax = child.getDataValue("max_Level")   //TODO need to scale here
	log ("Setting Child dim level to $level", "KH")
    child.setLevel(level.toInteger(),1) 
}

def HASensorEventP(name,payload,type,bool) {
    log ( "Passing on sensor Event values:  $name $payload $type $bool", "INFO")
    sensorEvent(name,payload,type,bool)
    // TODO CHECK BUG ??
}

def sensorEvent(name,b,type,bool) {   
    //log ("Received a sensor event from ${evt.value} level ${data.status}", "DEBUG")
    log ("Received a sensor event from $a level $b}", "DEBUG")
    child=getChildDevice("MQTT:homie_"+name)
	if (child==null) {
        child=getChildDevice("MQTT:HA_[" +type+"]_"+name)
		if (child==null) {
            log ("getChild failed for " + name, "WARN")
			return
		}	
	}   
    //sensorAction(child, evt.value,data.status)
    sensorAction(child,type,payload,type)   //TODO Attribute pass ??
}
    
def sensorAction(child,devType,val,attr=null) {
    //log ("SensorAction check attribute received was intended $attr [$val]", "LOG")
    maps=child.getDataValue("$attr" + "_MAP")
    if (maps != null) {
        log ("Child $child $val [$attr] has mapping of $maps" ,"KH")
        maps=maps.substring(1, maps.length() - 1)
        mapList = maps.split(',')
        //assert mapList instanceof List
    }
    if (attr=="humidity"){        
    //TODO Overly cautious sending the wrong command doesn't throw an error
        if (child.hasCommand ("setHumidity")) child.setHumidity(val)
        else if (child.hasCommand ("setRelativeHumidity")) child.setRelativeHumidity(val)
    }
    else if (attr=="temperature") child.setTemperature(val)        
    else if (attr=="carbonDioxide") child.setCarbonDioxide(val)
    else if (attr=="carbonMonoxide"){
        if (mapList[0] == val) child.CODetected()  //child.setCarbonMonoxide(val)
        else if (mapList[1] == val) child.COTested()   // doesnt exist ?? 
        else if (mapList[2] == val) child.COClear()  
    }
    else if (attr=="illuminance"){
        if (child.hasCommand ("setLux"))child.setLux(val)
        else child.setIlluminance(val)

    }
    else if (attr=="water"){
        if (mapList[0] == val) child.wet()
        else if (mapList[1] == val) child.dry()
    }        
    else if (attr=="presence"){
        if (mapList[0] == val) child.arrived()
        else if (mapList[1] == val)  child.departed() 
    }
    else if (attr=="smoke"){
        if (mapList[0] == val) child.smokeDetected()
        else if (mapList[1] == val) child.smokeClear() 
    }
    else if (attr=="motion"){
        if (mapList[0] == val){
            if (child.hasCommand ("inactive")) child.inactive()
            else if (child.hasCommand ("motionInactive")) child.motionInactive()
        }
        else if (mapList[1] == val) {
            if (child.hasCommand ("active")) child.active()
            else if (child.hasCommand ("motionActive")) child.motionActive()
        }
    }
    else if (attr=="contact"){
        if (mapList[0] == val) child.close()
        //log.error mapList[0]
        //log.error val
        //if (mapList[0] == 'close' || val =='closed') child.close()
        else if (mapList[1] == val) child.open()
    }
    else if (attr=="battery") { 
        log ("$child appears to be a battery device - using a global variable to store the battery level [$val]","LOG")
        if (child.typeName=="MQTT Text") child.setBattery(val)  // only my MQTT Text device supports this
        else if (child.typeName=="RM Connector Variable") child.setVariable (val)
    }
   else if (attr=="pressure") { 
        log ("$child appears to be a pressure device - using a global variable to store the pressure [$val]","LOG")
        if (child.typeName=="MQTT Text") child.updateText(val)  // only my MQTT Text device supports this
        else if (child.typeName=="RM Connector Variable") child.setVariable (val)
    }
   else if (attr=="acceleration"){
        if (mapList[0] == val){
            if (child.hasCommand ("inactive")) child.inactive()
            else if (child.hasCommand ("accelerationInactive")) child.accelerationInactive()
        }
        else if (mapList[1] == val) {
            if (child.hasCommand ("active")) child.active()
            else if (child.hasCommand ("accelerationActive")) child.accelerationActive()
        }
    }
    else if (attr=="omni") { 
        log ("$child appears to be an Omni catchall device [$val]  $child.typeName - using variable","LOG")
        child.setVariable(val)
    }
    // COClear CODetected        
    // pressure will go into variable
    else log ("Sensor not handled specifically yet with name $child and value $devType attribute $attr","WARN")

}

/*   Now unused ?
def groupEvent(name,status,type) {
//TODO revisit .. BUGGY ?
	//def data = parseJson(evt.data)
    //log ("group: event data: ${data}", "TRACE")
	log ("Received an OnOff event from $name turned ${data.status}", "DEBUG")
	child=getChildDevice("MQTT:homie_"+evt.value)  //TODO check this method is only for homie devices
	//if (child==null) child=getChildDevice("MQTT:HA_"+evt.value)
    child=getChildDevice("MQTT:HA_[" + type+"]_"+ name)
    if (child==null) child=getChildDevice("MQTT:virtual_"+name)

    if (child==null) {
        //log ("Device not enabled: "+ evt.value,"TRACE")
		return
	}
    if (status=="off") child.off()  else if (status=="on") child.on()  //TODO update
}
*/


def PresenceEventP(name,status,type) {
	log ("Received a person presence event from $name turned $status", "DEBUG")
	child=getChildDevice("MQTT:homie_"+name)  //TODO check this method is only for homie devices
	if (child==null) {
        child=getChildDevice("MQTT:HA_[" + type+"]_"+name)
    }
    if (child==null) {
				log ("Presence device not found: "+ name,"TRACE")
				return
	}
		
    onVal=child.getDataValue("presence_ON")
    offVal=child.getDataValue("presence_OFF")
    if (offVal!=null) {
        if ((offVal==status)||(status=='not_home')||(status=='not present')) child.departed()
    }
    if (onVal!=null){
        if ((onVal==status)||(status=='home')||(status=='present')) child.arrived()
    }
    //if (data.status=="home") child.arrived()  else child.departed()  // away status might be a zone name
}

def inputBooleanEventP(name,payload,type,topic) {
    log  ("Received an input boolean type event of $type from $name","TRACE")
    //log ("inputBoolean: event data: ${data}", "INFO")
	child=getChildDevice("MQTT:homie_"+name)  //TODO check this method is only for homie devices
    if (child==null) child=getChildDevice("MQTT:HA_["+type+"]_"+name)
    if (child==null) child=getChildDevice("MQTT:virtual_"+name)  // can this ever match ?
    if (child==null) child=getChildDevice("MQTT:virtual_"+topic)
    attList=child.getSupportedAttributes()
    attName = attList[0]
    log  ("Got " + child + " [" + + attList.size() + "] " + child.getSupportedAttributes(), "DEBUG")
    typeName=child.typeName
    // need to filter here on which attributes are binary and which hold data .. handled elsewhere now too
    try{
        myOFF = child.getDataValue("$attName" + "_OFF")
        }
    catch(e) {
        log("There wasn't a value on $child for the $attName _OFF data, Trying to add a default but please check on the device", "WARN")
        if (data.status.toLowerCase()=='off') child.updateDataValue("$attName"+"_OFF",data.status)
    }
    try{
        myON = child.getDataValue("$attName"+"_ON")   
        }
    catch(e) {
        log("There wasn't a value on $child for the $attName _ON data, Trying to add a default but please check on the device", "WARN")
        //if (data.status.toLowerCase()=='on') child.updateDataValue("$attName"+"_ON",data.status)           
        }
    if (myOFF!=null) {    
	if (payload==myOFF) {
                if (typeName=="Virtual Switch") child.off()
        		else if (typeName=="Virtual Motion Sensor") child.inactive()
				else if (typeName=="Virtual Contact Sensor") child.close()
				else if (typeName=="Virtual Presence") child.departed()
				else if (typeName=="Virtual Omni Sensor") child.motionInactive()
				else if (typeName=="Virtual Multi Sensor") child.inactive()
                else {
                    log ("Need to add $typeName for $child device - using default .off","WARN")
                    child.off()
                }
    }
    }
    if (myON!=null) {
	if (payload==myON){
        	    if (typeName=="Virtual Switch") child.on()
        		else if (typeName=="Virtual Motion Sensor") child.active()
				else if (typeName=="Virtual Contact Sensor") child.open()
				else if (typeName=="Virtual Presence") child.arrived()
				else if (typeName=="Virtual Omni Sensor") child.motionActive()
				else if (typeName=="Virtual Multi Sensor") child.active()
                else {
                    log ("Need to add $typeName for $child device - using default .on","WARN")
                    child.on()
                }
	}
    }
    else log ("Couldn't match 'binary' value for $child $data.state _ON  _OFF, please edit device","WARN")
}

def HABinSensorType(evt) {
	def data = parseJson(evt.data)
	log  ("Received binary_sensor type event of ${data.type} from ${evt.value}","TRACE")
}

def HASensorUnitP (a,b) {
    log ("sensor UOM $a $b","ERROR")
}


/*
// TODO I dont think this is being called currently - instead above is
def sensorUOM(evt) { 
	def data = parseJson(evt.data)
	child=getChildDevice("MQTT:homie_"+evt.value)
	if (child==null) {
		//log ("getChild failed for " + evt.value, "WARN")
		//child=getChildDevice("MQTT:HA_"+evt.value)
        child=getChildDevice("MQTT:HA_[" + data.type+"]_"+evt.value)
		if (child==null) {
			//log ("getChild failed for " + evt.value, "WARN")
			return
		}	
	}		
	unit = "°" //+data.label[7]  // TODO hack until I work out unicode 16 convert better \u00b0 
	if (child.typeName=="MQTT Dimmer" || child.typeName=="MQTT Switch" ){  // only call for my device drivers
	child.setPrefix("")
	child.setSuffix(unit)
	}
}
*/
def dAttIsEnabled(device,attr)
{
    if (device==null) {
        log ("Null device - attribute is $attr")
        return
    }
    property=device.getDataValue("properties")
    if (property != null) {
            if (!property.contains(attr)) {
                log ("$device: BLOCKED","KH")
                return false
            }

        }
return true
}

// def cmdEvent (name,state,payload,cmd,topic) {  // 'set' command from homie for a Hubitat or manual device via Hubitat basic 



def extractInt( String input ) {
  return input.replaceAll("[^0-9]", "")
}


//#######################################################################################################################################
//############################   This section contains general utility nethods and the popular createChild() method     #########################
//#######################################################################################################################################

def normalize(name) {
	//TODO research how to include NFD
	//log ("Normalize: " + name + " >>> " + name.trim().toLowerCase().replaceAll(/[^\w-]/,"_").replaceAll(/[-]/,'_'),"TRACE")
	return name ? name.trim().toLowerCase().replaceAll(/[^\w-]/,"-").replaceAll(/[_]/,'-') : undefined
}


def LabelDeviceP(dID,label) {   // rename to reNameDevice ??
		child=getChildDevice(dID)
	    if (child == null) {
		log ("reName: Child doesn't exist (no state or unsupported type ?) "+ dID + " " + label , "TRACE")
		return  
       }
	child.label= label
	log ("reNamed  $child.displayName to $label" ,"TRACE")
}

def MD5(String s){
    if (s==null) s="123"
    MessageDigest.getInstance("MD5").digest(s.bytes).encodeHex().toString()
}

def createChildDevice(name, type, system, friendlyName, dType='default',seq=o) {
    mqtt = getChildDevice("MQTT: Child device driver")
	// friendlyname may not be available yet so name will have been passed and it will be renamed later in reNameDev()
	log("CreateDevice called for $system " + name + " " + friendlyName + "  :  " + type,"LOG")
	if (name==null) return
	//if (atomicState.started) return // TODO Stops creation of devices after timed startup has elapsed - but also stops ongoing incremental discovery.... decide which to use
	devEnabled=false
	def prefix = "MQTT:"
	String enabledDevices=(settings?.HA_Lights) + ',' + (settings?.HA_Switches ) + ',' + (settings?.Homie_dim) + "," + (settings?.Homie_onoff) + ','  //not used
	if (system=="HA") {
        prefix="MQTT:HA_["+type+"]_"
        if ((type=='switch')&&(settings?.HA_Switches != null)){							   
			if (settings?.HA_Switches.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='light')&&(settings?.HA_Lights != null)) {  
			if (settings?.HA_Lights.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='sensor')&&(settings?.HA_Sensors != null)) {
			if (settings?.HA_Sensors.contains (name))
			{
				devEnabled=true
                log ("Device ENABLED $name","LOG")
			}
            //else log ("Device not enabled $name","LOG")
		}
		else if ((type=='binary_sensor')&&(settings?.HA_BinarySensors != null)) {
			if (settings?.HA_BinarySensors.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='input_boolean')&&(settings?.HA_InputBooleans != null)) {
			if (settings?.HA_InputBooleans.contains (name))
			{
                devEnabled=true
			}
		}
        else if ((type=='person')&&(settings?.HA_Presence != null)) {
			if (settings?.HA_Presence.contains (name))
			{
				devEnabled=true
			}
		}
		else if ((type=='group')&&(settings?.HA_Groups != null)) {
			if (settings?.HA_Groups.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='device_tracker')&&(settings?.HA_DeviceTrackers != null)) {
			if (settings?.HA_DeviceTrackers.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='cover')&&(settings?.HA_Covers != null)) {
			if (settings?.HA_Covers.contains (name))
			{
				devEnabled=true
                //devType='Virtual Shade'
			}
		}
        else if ((type=='climate')&&(settings?.HA_Climates != null)) {
			if (settings?.HA_Climates.contains (name))
			{
				devEnabled=true
			}
		}
        else if ((type=='lock')&&(settings?.HA_Locks != null)) {
			if (settings?.HA_Locks.contains (name))
			{
				devEnabled=true
			}
		}
        else {
            log ("Not enabled HA $name type $type","TRACE")
        }
	}
	else if (system=="homie")
	{
		prefix="MQTT:homie_"
        if (settings?.Homie_onoff != null)
		{									   
			if (settings?.Homie_onoff.contains (name))
			{
				devEnabled=true				
			}
		}
         if (settings?.Homie_dim != null) {
			if (settings?.Homie_dim.contains (name))
			{
				devEnabled=true
			}
		}
		if (settings?.Homie_sensor != null) {
			if (settings?.Homie_sensor.contains (name))
			{
				devEnabled=true
			}
		}
		if (settings?.Homie_binarySensor != null) {
			if (settings?.Homie_binarySensor.contains (name))
			{
				devEnabled=true
			}
		}
        if (settings?.Homie_variable != null) {
			if (settings?.Homie_variable.contains (name))
			{
				devEnabled=true
			}
		}
        if (settings?.Homie_button != null) {
			if (settings?.Homie_button.contains (name))
			{
				devEnabled=true
			}
        }
          if (!devEnabled)  log ("Not enabled homie $name type $type","KH")
	}
    else if (system=='Sonoff') {
		devEnabled=true
		prefix="MQTT:Sonoff_"
	}

    else if (system=='Shelly') {
		devEnabled=true
		prefix="MQTT:Shelly_"
	}

	else if (system=='internal') {
		devEnabled=true
		prefix="MQTT:Internal_"
	}
	if (!devEnabled)
	{
		log ("["+system+"] Create blocked (not enabled) for " + name, "TRACE")
		return
	}
    else{
    log ("["+system+"] Device enabled: $system " + name + " : " + type + " " +dType, "INFO")
    }
	child=getChildDevice(prefix+name) 
	if (child != null) 
		{
			// dont expect this if mqttRemoveDevices was true
			// TODO decide ..this gets fired (but ignored) on every change of state update - can we eliminate that without breaking incremental discovery ?
			// no but could use ...  if(atomicState.started)
			if (!atomicState.started && (settings?.mqttRemoveDevices == true)) log ("Child already exists " + prefix+name, "WARN")
			return
		}
    def nameSpace="hubitat" // now all devices are Hubitat                                        
    attrData=null
    if ((type=='onoff')||(type=='switch')) {
        devType='Virtual Switch'
        attrData="switch"
    }
    else if ((type=='dim')||(type=='light')){
        devType='Virtual Dimmer'
        attrData="level"
    }                                          
	else if (type=='group') {
        devType='Virtual Switch'  // TODO check if a HA group can have a level ?
        attrData="switch"
        attrData="switch"
    }
    else if (type=='input_boolean') { 
        devType="Virtual Contact Sensor"    //devType='Virtual Switch'   //This should be a contact sensor or something as not controllabe
        attrData="contact"
    }
    else if (type=='binary_sensor') { 
        devType="Virtual Contact Sensor"    //devType='Virtual Switch'   //This should be a contact sensor or something as not controllabe
        attrData="contact"
    }    
    else if ((type=='presence')||(type=='person')) devType='Virtual Presence'
    else if (type=='button') devType='Virtual Button'
    else if (type=='lock') devType='Virtual Lock'
    else if (type=='cover') devType='Virtual Shade'
    else if (type=='device_tracker') devType= "Virtual Presence"
    else if (type=='climate') {
            log ("HA climate device not implemented yet, no device created", "WARN")
            return
    }
    else if (type=='sensor' || type=='binary_sensor') {
        log ("Got a sensor of type ${dType}", "WARN")
        // devType= "Virtual Omni Sensor" // changing this default to a variable as Omni is problematic
        devType= "RM Connector Variable" 
        if (dType=="default") devType= "RM Connector Variable"  // changing this default to a variable as Omni is problematic
        else if (dType=="None") devType= "Virtual Contact Sensor"
        else if (dType=="acceleration") devType= "Virtual Acceleration Sensor"
        else if (dType=="audioVol") devType= "Virtual audioVolume"
        else if (dType=="battery") devType= "RM Connector Variable"  // there is no battery variable device
        else if (dType=="battery") {
                devType="MQTT Text"
                nameSpace="ukusa" // only UKUSA device now
            }
        else if (dType=="button") devType= "Virtual Button"    
        else if (dType=="cold") devType= "Virtual Contact Sensor"
		else if (dType=="connectivity") devType= "virtual Contact Sensor"
        else if (dType=="device_tracker") devType= "Virtual Presence"
        else if (dType=="door") devType= "Virtual Contact Sensor"
        else if (dType=="garage_door") devType= "Virtual Garage Door Controller"
        else if (dType=="gas") devType= "Virtual CO Detector"
		else if (dType=="heat") devType= "Virtual Contact Sensor"
        else if (dType=="humidity") devType= "Virtual Humidity Sensor"
        else if (dType=="illuminance") devType= "Virtual Illuminance Sensor"   
		else if (dType=="light") devType= "Virtual Switch"		
        else if (dType=="lock") devType= "Virtual Lock"
        else if (dType=="moisture") devType= "Virtual Moisture Sensor"  // check as overly complex
        //else if (dType=="moisture") devType= "Generic Component Water Sensor"  
        else if (dType=="motion") devType= "Virtual Motion Sensor"
		else if (dType=="moving") devType= "Virtual Acceleration Sensor"
        else if (dType=="occupancy") devType= "Virtual Presence"
        else if (dType=="opening") devType= "Virtual Contact Sensor"
        else if (dType=="plug") devType= "Virtual Switch"
        else if (dType=="power") devType= "Virtual Omni Sensor"   //check TODO ... Generic Component Metering Switch ?
        else if ((dType=="presence")||(dtype=='person')) devType= "Virtual Presence" 
        else if (dType=="pressure") devType= "Virtual Omni Sensor"    
		else if (dType=="problem") devType= "Virtual Omni Sensor"  //TODO
		else if (dType=="safety") devType= "Virtual Contact Sensor"
        else if (dType=="smoke") devType= "Virtual Smoke Detector"
		else if (dType=="sound") devType= "Virtual audioVolume"  // check think this is not boolean
        else if (dType=="temperature") devType= "Virtual Temperature Sensor"  // check think this is not boolean
        else if (dType=="variable") devType= "RM Connector Variable"
        //else if (dType=="vibration") devType= "Virtual Motion Sensor"
        else if (dType=="vibration") devType= "Generic Glass Break Detector"
        else if (dType=="window") devType= "Virtual Contact Sensor"
		else log (name + " found no device type mapping for " + dType + '  ' +  devType,"WARN")
	}
	// ######  This is where to add additional device types and their matching driver ######			 
	else {
			log ("Skipping creating device " + name +" as no type yet for " + type, "WARN")
			return
	}			
		log ("Creating type " + type + " as  + ("+ dType +") " + devType + " named MQTT:" + name + " " + friendlyName, "WARN")
		//mqtt.createChild(name)  // This was to create device as driver child
		def pfix = ""
//		try {   
				childDevice = addChildDevice(nameSpace, devType, prefix+name, null,[completedSetup: true, label: pfix + friendlyName])
				child=getChildDevice(prefix+name)  //hmm seems childDevice is not a device object .ge
			    if (child == null) log ("Child was never created" + prefix+name , "KH")
			    else log ("Created Child device with label "+ child.label,"INFO")
			    atomicState.count++			
			    childrenCount = getChildDevices().size()		
    log ("Type for $name is $type [$attrData]", "LOG")
				if (system=='homie'){
                            child.updateDataValue("switch_Topic",'homie/'+atomicState.homie+'/'+name+'/onoff')
                            child.updateDataValue("switch_Cmd",'homie/'+atomicState.homie+'/'+name+'/onoff/set')
                            //child.updateDataValue("switch_ON","true")                                             // ##### ToDo dont do this if already has a value (shouldnt happen as new device)
                            //child.updateDataValue("switch_OFF","false")
                            child.updateDataValue("switch_MAP","[true,false]")
                            child.updateDataValue("mqtt",'enabled')
                            child.updateDataValue("origin",'homie')															   
																												
				}
            	else if (system=="HA"){
                    child.updateDataValue("mqtt","auto")
                    child.updateDataValue("origin","Home Assistant")
                    log ("Request to create $name of type $type","DEBUG")
                    control=true 
                    binary=true
                    if (type == 'sensor') {
                        control=false 
                        binary=false
                    }
                    if (type == 'switch'){
                        if (attrData!=null) {
                            //child.updateDataValue("${attrData}_Topic]",atomicState.HA+'/switch/'+name+'/state')
                            mqtt.subscribeTopic(atomicState.HA+'/switch/'+name+'/state')  // This is to support individual subscribes
							child.updateDataValue("${attrData}_Topic",atomicState.HA+'/switch/'+name+'/state')																				  
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/switch/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")                                             // ##### ToDo dont do this if already has a value (shouldnt happen as new device)
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
					}
                    else if (type == 'light') {
                        if (attrData!=null) {   // attrData will be 'level'
                            mqtt.subscribeTopic(atomicState.HA+'/light/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("switch_Topic",atomicState.HA+'/light/'+name+'/state')
                            child.updateDataValue("switch_Cmd", atomicState.HA+'/light/'+name+'/state/cmd')
                            //child.updateDataValue("level_Topic",atomicState.HA+'/light/'+name+'/brightness')
                            child.updateDataValue("${attrData}_Topic", atomicState.HA+'/light/'+name+'/brightness')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/light/'+name+'/brightness/cmd')
                            //child.updateDataValue("switch_ON","on")
                            //child.updateDataValue("switch_OFF","off")
                            child.updateDataValue("switch_MAP","[on,off]")
                            child.updateDataValue("max_Level","255")
                        }
					}
					else if (type == 'group') {
                        if (attrData!=null) {
                            mqtt.subscribeTopic(atomicState.HA+'/group/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/group/'+name+'/state')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/group/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
					}
                    else if (type == 'input_boolean') {
                        if (attrData!=null) {
                            mqtt.subscribeTopic(atomicState.HA+'/input_boolean/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/input_boolean/'+name+'/state')
                            child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/input_boolean/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
					}
                    else if (type == 'binary_sensor') {
                        if (attrData!=null) {
                            control=false
                            mqtt.subscribeTopic(tomicState.HA+'/binary_sensor/'+name+'/state')  // This is to support individual subscribes
                            child.updateDataValue("${attrData}_Topic",atomicState.HA+'/binary_sensor/'+name+'/state')
                            //child.updateDataValue("${attrData}_Cmd", atomicState.HA+'/binary_sensor/'+name+'/state/cmd')
                            //child.updateDataValue("${attrData}_ON","on")
                            //child.updateDataValue("${attrData}_OFF","off")
                            child.updateDataValue("${attrData}_MAP","[on,off]")
                        }
					}
					else {
                        log ("HA type $type  - not recognised yet so creating defaults","INFO")

                        child.capabilities.each { cap ->
                          cap.attributes.each { attr ->
                            log ( "Unrecognised HA device [$child] so adding default MQTT data for [$attr]","INFO")
                            child.updateDataValue("${attr}_Topic",atomicState.HA+'/'+type+'/'+name+'/state')
                            if (control) child.updateDataValue("${attr}_Cmd", atomicState.HA+'/'+type+'/'+name+'/state/cmd')
                            if (binary) {
                                  //child.updateDataValue("${attr}_ON","on")
                                  //child.updateDataValue("${attr}_OFF","off")
                                  child.updateDataValue("${attrData}_MAP","[on,off]")
                            }
                          }
                       }
                    }
                     attrData=null
                   }  //HA system
                       
                else if (system=="Shelly"){
                    if (name[-7..-1] == "relay 0") sTopic = '/relay/0'
                    else if (name[-7..-1] == "relay 1") sTopic = '/relay/1'
                    else sTopic="/unknown/"
                        // uses on off
                   		//child.setStateTopic('shellies/'+name+sTopic)
						//child.setStateCmdTopic('shellies/'+name+sTopic+'/command') 
                }
                else if (system=="Sonoff"){ 
                    log ("Sonoff not yet implemented","ERROR")
                }
				else if (system=="internal"){  // was setting state topics but now not child devices
				}
				if (type=='dim') {
					if (system=="homie"){
                         child.updateDataValue("level_Topic",'homie/'+atomicState.homie+'/'+name+'/dim')
                         child.updateDataValue("level_Cmd",'homie/'+atomicState.homie+'/'+name+'/dim/set')
                         child.updateDataValue("max_Level",'100')  // this will get updated later from the $format value
                         child.updateDataValue("mqtt",'enabled')
                         child.updateDataValue("origin",'homie')
					}
					else if (system=="HA"){
                        child.updateDataValue("switch_Topic",atomicState.HA+'/light/'+name+'/state')
                        child.updateDataValue("switch_Cmd",atomicState.HA+'/light/'+name+'/state/cmd')
                        child.updateDataValue("level_Topic",atomicState.HA+'/light/'+name+'/brightness')
                        child.updateDataValue("level_Cmd",atomicState.HA+'/light/'+name+'/brightness'/cmd)
                        child.updateDataValue("max_Level",'100')
					}
					if (type=='sensor') {
						log  ("############ Problem child is " + child.device.typeName, "WARN")
						if (child.typeName=="MQTT Dimmer" || child.typeName=="MQTT Switch" ){  // think must be my driver here
					}
					}
			}
			//child.setType(system)  // identify as a discovered device
/*
		} catch(Exception ex) {
            log ("addChild/topics failed for " + name + " ["+  prefix+name +" ]"  +(ex.toString()), "ERROR")
		}
*/
      //log("Succesfully created new device $name","WARN")
	  advertiseChild()
}

def advertiseChild(){
	return  // These will be 'discovered' devices so not onwardly advertising them or publishing states (may revisit again later)
	log ("### TODO ####   Update MQTT with states for ${name} and also advertise to HA","WARN")
	//HADiscoveryAdvertise()
}

def devSummary(evt=null) {
	log ("==================================================", "GREEN")
    nodes=atomicState.nodes.split(',')
	if (atomicState.MQTTRGBc>0) log ("         [${atomicState.MQTTRGBc}] Hubitat RGB control devices synched to MQTT", "GREEN")
	if (atomicState.MQTTRGBt>0) log ("         [${atomicState.MQTTRGBt}] Hubitat RGB temperature devices enabled on MQTT", "GREEN")
	if (atomicState.MQTTOnOffDevices>0) log ("         [${atomicState.MQTTOnOffDevices}] Hubitat switch devices enabled on MQTT", "GREEN")
	if (atomicState.MQTTDimDevices>0) log ("         [${atomicState.MQTTDimDevices}] Hubitat dimmer devices enabled on MQTT", "GREEN")
	if (atomicState.adhocDevices>0) log ("         [${atomicState.adhocDevices}] Hubitat virtual devices synched to MQTT", "GREEN")
    if (atomicState.MQTTLockDevices>0) log ("         [${atomicState.MQTTLockDevices}] Hubitat lock devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTKEYPADt>0) log ("         [${atomicState.MQTTKEYPADt}] Hubitat Security Keypad devices enabled on MQTT", "GREEN")    
    if (atomicState.MQTTgarageDevices>0) log ("         [${atomicState.MQTTgarageDevices}] Hubitat garage door devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTwindowDevices>0) log ("         [${atomicState.MQTTwindowDevices}] Hubitat window shade devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTChimeDevices>0) log ("         [${atomicState.MQTTChimeDevices}] Hubitat chime devices enabled on MQTT", "GREEN")   
    if (atomicState.MQTTBulbDevices>0) log ("         [${atomicState.MQTTBulbDevices}] Hubitat bulb devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTOutletDevices>0) log ("         [${atomicState.MQTTOutletDevices}] Hubitat outlet devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTThermostats>0) log ("         [${atomicState.MQTTThermostats}] Hubitat thermostat devices enabled on MQTT", "GREEN")    
    if (atomicState.MQTTValveDevices>0) log ("         [${atomicState.MQTTValveDevices}] Hubitat valve devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTGlobalVarDevices>0) log ("         [${atomicState.MQTTGlobalVarDevices}] Hubitat global variables enabled on MQTT", "GREEN")
    if (atomicState.MQTTgVarDevices>0) log ("         [${atomicState.MQTTgVarDevices}] Hubitat gVars enabled on MQTT", "GREEN")    
    if (atomicState.MQTTEverythingDevices>0) log ("         [${atomicState.MQTTEverythingDevices}] Hubitat 'everything' all capability devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTAlarmDevices>0) log ("         [${atomicState.MQTTAlarmDevices}] Hubitat alarm devices enabled on MQTT", "GREEN")
    if (atomicState.MQTTRelaySwitchDevices>0) log ("        [ ${atomicState.MQTTRelaySwitchDevices}] Hubitat relay switch devices enabled on MQTT", "GREEN")
    log ("    [${atomicState.TotalDevices}]  Total Hubitat devices are enabled on MQTT", "GREEN")
    log ("    [${nodes.size()}]  Total Hubitat endpoints enabled on MQTT", "GREEN")    
    if (settings?.ShellyDiscovery){
        if (atomicState.ShellyDevices.size()>0) log ("    Discovered [${atomicState.ShellyDevices.size()}] Shelly relay devices", "GREEN")
    }
    if (settings?.SonoffDiscovery){
         if (atomicState.SonoffDevices.size()>0) log ("    Discovered [${atomicState.SonoffDevices.size()}] Sonoff devices", "GREEN")
    }
	if (settings?.homieDiscovery){
            if (settings?.Homie_onoff != null) ho = settings?.Homie_onoff.size() else ho=0  // Elvis isnt in the house TODO
			if (settings?.Homie_dim != null) hd = settings?.Homie_dim.size() else hd=0
			if (settings?.Homie_sensor != null) hs = settings?.Homie_sensor.size() else hs=0
			if (settings?.Homie_button != null) hb = settings?.Homie_button.size() else hb=0
			if (settings?.Homie_variable != null) hv = settings?.Homie_variable.size() else hv=0
            if (settings?.Homie_lock != null) hl = settings?.Homie_lock.size() else hl=0
            if (settings?.Homie_unknowns != null) hu = settings?.Homie_unknowns.size() else hu=0
		 if (atomicState.onoffDevices.size()>0) log ("    Imported [$ho] homie onoff devices of [${atomicState.onoffDevices.size()}] discovered", "GREEN")
         if (atomicState.dimDevices.size()>0) log ("    Imported [$hd] homie dim devices of [${atomicState.dimDevices.size()}] discovered", "GREEN")
		 if (atomicState.sensorDevices.size()>0) log ("    Imported [$hs] homie sensor devices of [${atomicState.sensorDevices.size()}] discovered", "GREEN")
         if (atomicState.buttonDevices.size()>0) log ("    Imported [$hb] homie button devices of [${atomicState.buttonDevices.size()}] discovered", "GREEN")
         if (atomicState.lockDevices.size()>0) log ("    Imported [$hl] homie lock devices of [${atomicState.lockDevices.size()}] discovered", "GREEN")
	     if (atomicState.varDevices.size()>0) log ("    Imported [$hv] homie variable devices of [${atomicState.varDevices.size()}] discovered", "GREEN")
         if (atomicState.homieUnknownDevices.size()>0) log ("    Imported [$hu] homie unknown devices of [${atomicState.homieUnknownDevices.size()}] discovered", "GREEN")
    }
	if (settings?.HAStatestream) {
            if (settings?.HA_Switches != null) HAsw = settings?.HA_Switches.size() else HAsw=0  // Elvis isnt in the house TODO
			if (settings?.HA_Lights != null) HAli = settings?.HA_Lights.size() else HAli=0
			if (settings?.HA_Sensors != null) HAse = settings?.HA_Sensors.size() else HAse=0
			if (settings?.HA_BinarySensors != null) HAbs = settings?.HA_BinarySensors.size() else HAbs=0
			if (settings?.HA_Groups != null) HAg = settings?.HA_Groups.size() else HAg=0
            if (settings?.HA_Presence != null) HAp = settings?.HA_Presence.size() else HAp=0
			if (settings?.HA_InputBooleans != null) HAib = settings?.HA_InputBooleans.size() else HAib=0
            if (settings?.HA_Covers != null) HAco = settings?.HA_Covers.size() else HAco=0
            if (settings?.HA_Locks != null) HAlo = settings?.HA_Locks.size() else HAlo=0
            if (settings?.HA_DeviceTrackers != null) HAd = settings?.HA_DeviceTrackers.size() else HAd=0
            if (settings?.HA_Climates != null) HAcl = settings?.HA_Climates.size() else HAcl=0
        if (atomicState.HASwitchDevices.size()>0) log ("    Imported [$HAsw] HA switch devices of [${atomicState.HASwitchDevices.size()}] discovered", "GREEN")
		if (atomicState.HALightDevices.size()>0) log ("    Imported [$HAli] HA light devices of [${atomicState.HALightDevices.size()}] discovered", "GREEN")
		if (atomicState.HASensorDevices.size()>0) log ("    Imported [$HAse] HA sensor devices of [${atomicState.HASensorDevices.size()}] discovered", "GREEN")
		if (atomicState.HABinarySensorDevices.size()>0) log ("    Imported [$HAbs] HA binary sensor devices of [${atomicState.HABinarySensorDevices.size()}] discovered", "GREEN")
		if (atomicState.HAInputBooleanDevices.size()>0) log ("    Imported [$HAib] HA input boolean devices of [${atomicState.HAInputBooleanDevices.size()}] discovered", "GREEN")
		if (atomicState.HAGroupDevices.size()>0) log ("    Imported [$HAg] HA groups of [${atomicState.HAGroupDevices.size()}] discovered", "GREEN")
        if (atomicState.HAPresenceDevices.size()>0) log ("    Imported [$HAp] HA persons of [${atomicState.HAPresenceDevices.size()}] discovered", "GREEN")
        if (atomicState.HALockDevices.size()>0) log ("    Imported [$HAl] HA locks of [${atomicState.HALockDevices.size()}] discovered", "GREEN")
        if (atomicState.HAClimateDevices.size()>0) log ("    Imported [$HAcl] HA climate devices of [${atomicState.HAClimateDevices.size()}] discovered", "GREEN")
        if (atomicState.HADeviceTrackerDevices.size()>0) log ("    Imported [$HAd] HA device trackers of [${atomicState.HADeviceTrackerDevices.size()}] discovered", "GREEN")
        if (atomicState.HACoverDevices.size()>0) log ("    Imported [$HAco] HA cover devices of [${atomicState.HACoverDevices.size()}] discovered", "GREEN")
	}
    unsubscribeHADeviceEvents()
	log ("================== Startup complete ==================", "GREEN")
	//mqtt.setStateVar ("MQTTmyStatus","present") // This is now showing MQTT Broker connected rather than startup complete.
	atomicState.started=true
    atomicState.abort=false // can't abort anymore
    if (settings?.homiePublish) {
        mqtt = getChildDevice("MQTT: Child device driver")
        mqtt.publishMsg ("homie/${atomicState.normHubName}/" +'$state','ready',1,true) 
    }
    atomicState.suppress = true  // after startup complete only payload change messages are sent to MQTT i.e. state changes  (same as min homie tree setting)
}

def clearDevices() {
	atomicState.onoffDevices=[]
	atomicState.dimDevices=[]
    atomicState.buttonDevices=[]
    atomicState.sensorDevices=[]
    atomicState.lockDevices=[]
    atomicState.ShellyDevices=[]
    atomicState.SonoffDevices=[]
}

def sendPayload(topic,payload) {
	if (payload==null) {
		log ("Null payload for topic " + topic, "WARN")
		return
	}
	if (topic==null) {
		log ("Null topic for payload " + payload, "WARN")
		return
	}
	log ("Send MQTT " + topic + " " + payload, "TRACE")
    mqtt = getChildDevice("MQTT: Child device driver")
	mqtt.publishMsg (topic,payload,1,settings?.homieStatesPersist)
}

//=========================================================================================================================== trial methods

def findDeviceByName(name) {
    matchDevice = null
    settingsDevices = [settings?.everything, settings?.switches, settings?.dimmers, 
        settings?.colour, settings?.colourT, settings?.locks, settings?.garagedoors, settings?.mqtttext,
        settings?.windowshades, settings?.valves, settings?.thermostats, settings?.keypads, settings?.gVars,settings?.globVars]
    settingsDevices.find{
        if (matchDevice != null) {
            return true
        }
        it.find{
            if (it.displayName==name){    
                matchDevice = it
                return true
            }
        }
    }
    return matchDevice
}


def commandP(name, state, payload, cmd, topic) { // 'set' command from homie for a Hubitat or manual device via Hubitat basic 
    // TODO This has value and data transposed in the two versions for discovered and adhoc .. tidy up
    //def data = parseJson(evt.data)
    log("MQTT set command received for " + name + " " + cmd + " " + state + " " + topic + " " + payload, "DEBUG")
    if (state=='' || state==null) {
        log ("An empty or null state value was received from a ../set topic and was BLOCKED from writing to an attribute as it would set it to null","WARN")
        return
    }
    normName = name
    matchName = name
    found = false
    cTime = now()
    mqtt = getChildDevice("MQTT: Child device driver")
    //     DNI=atomicState.newMap[normName]
    log("$cmd received $state", "TRACE")
    if (atomicState.nameMap[normName] == null) {
        log("No name map for ${normName} so assume Hubitat basic topic or homie /hub", "INFO") // could check from topic.topic[0]
        matchName = normName
    } else {
        matchName = atomicState.nameMap[normName]
        found = true
    }
    log("$cmd received $state", "TRACE")
    dMatch = false
    everyThing == (settings?.everything)
    log("Everything Lookup for  " + name + " is " + matchName + " [" + atomicState.nameMap[index] + "] ", "DEBUG")

    if (matchName == "hub") {
        if (cmd == "mode") {
            if (location.mode != state) {
                if (location.modes?.find {it.name==state}) 
                {
                    location.setMode(state)
                } else {
                    log("Hub Mode Cmd: unknown mode $state", "ERROR")
                }
            }
        }
        if (cmd=='hsmArm') {
            sTopic=	"homie/${atomicState.normHubName}/hub/hsmArm"
            if (!settings?.allowHSMControl) {
                mqtt.publishMsg (sTopic,'blocked',1,true)
                return
            }

            if (settings?.allowHSMDisarm) {
                if ("armAway, armHome, armNight, disarm, armRules, disarmRules, disarmAll, armAll, cancelAlerts".contains(state)){
                    sendLocationEvent(name: "hsmSetArm", value: state)
                    return
                }
                else {
                    log ("Unhandled Command $cmd [$state] for hub","WARN")
                    mqtt.publishMsg (sTopic,'unknown',1,true)
                    return
                }
            }
            else { 
                    if ("armAway, armHome, armNight, armRules, armAll, cancelAlerts".contains(state)){
                    sendLocationEvent(name: "hsmSetArm", value: state)
                    return
                }
                else {
                    log ("Unhandled Command $cmd [$state] for hub","WARN")
                    mqtt.publishMsg (sTopic,'unknown',1,true)
                    return
                }
            }

                

/*            
            if (state=='disarm') {
                log ("Need to disarm HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "disarm")
            }
            else if (state=='armAway') {
                log ("Need to arm Away HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armAway")
            }
            else if (state=='armHome') {
                sendLocationEvent(name: "hsmSetArm", value: "armHome")
                log ("Need to arm Home HSM","WARN")
            }
            else if (state=='armNight') {
                log ("Need to arm Night HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armNight")
            }
            else if (state=='armRules') {
                log ("Need to arm Away HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armRules")
            }
            else if (state=='disarmRules') {
                log ("Need to disarm Rules HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "disarmRules")
            }
            else if (state=='armAll') {
                log ("Need to arm All HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "armAll")
            }
            else if (state=='disarmAll') {
                log ("Need to disarm All HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "disarmAll")
            }
            else if (state=='cancelAlerts') {
                log ("Need to cancel Alerts HSM","WARN")
                sendLocationEvent(name: "hsmSetArm", value: "cancelAlerts")
            }
            else log ("Unknown ../set command to hsmArm","WARN")

            return
        }
*/
       
    }
    }

    matchDevice = findDeviceByName(matchName)
    log("Device Matched - " + matchDevice?.displayName + " - for command $cmd", "DEBUG")
    if (cmd == "onoff" || cmd == "switch") { // TODO convert to select / case   'switch' comes from RGB devices
        log("Was here in commandP", "WARN")
		if (matchDevice != null) {
			//log("Here in commandP $cmd", "WARN")
            //proceed = dAttIsEnabled(it, cmd)
			proceed = dAttIsEnabled(matchDevice, cmd)
			if (!proceed) {
				log("$device: ../onoff/set BLOCKED", "WARN")
				return
			}
			OnValues = "on,true,yes,1"
			OffValues = "off,false,no,0"
			if (OnValues.contains(state.toLowerCase())) {
				matchDevice.on()
			} else if (OffValues.contains(state.toLowerCase())) {
				matchDevice.off()
			} else log("Unknown state value " + state + " - need to add to lookup", "WARN")
		}
    } else if (cmd == "dim") {
        openHAB = false
        log("Incoming dim /set $state", "WARN")
        val = "${state}"
        if (openHAB) intLevel = (Float.parseFloat(val) * 100).toInteger()
        else intLevel = state.toInteger()
        if ((0 <= intLevel)) //  && (intLevel <= 100)) //TODO Check removing this upper bound check doesn't break anything
        {
			if (matchDevice != null) {
                    matchDevice.setLevel(intLevel, 1)
                    dMatch = true
            }
		}
    } else if (cmd == "color") {
		if (matchDevice != null) {
			if (state[0] == '#') {
				try {
					RGB = hubitat.helper.ColorUtils.hexToRGB(state)
					HSV = hubitat.helper.ColorUtils.rgbToHSV(RGB)
					HSL = [: ]
					HSL.put('hue', HSV[0].toInteger())
					HSL.put('saturation', HSV[1].toInteger())
					HSL.put('level', HSV[2].toInteger())
					matchDevice.setColor(HSL)
				} catch (e) {
					log("#RRGGBB color /set error:  " + e, "ERROR")
				}
				dmatch = true
			} else {
				colour = payload
				try {
					hue = -1
					if (payload[0] != null) {
						float h = Float.parseFloat(payload[0])
						h = (h / 3.6) + 0.5
						hue = (int)(h)
						if (hue > 100) hue = 100
						else if (hue < 0) hue = 0
					}
					sat = -1
					if (payload[1] != null) {
						float s = Float.parseFloat(payload[1]) + 0.5
						sat = (int)(s)
						if (sat > 100) sat = 100
						else if (sat < 0) sat = 0
					}
					/*
					if (payload[2] != null) {
						float v = Float.parseFloat(payload[1]) + 0.5
						val = (int) (v)
						if (val>100) val=100
						else if (val<0) val=0
					}
		*/
					// (Untested change request)
					if (payload[2] != null) {
						val = payload[2].toInteger()
						if (val > 100) val = 100
						else if (val < 0) val = 0
					} else val = -1
					log("Color data is $payload   hue:$hue    sat:$sat    value:$val", "TRACE")
					if (val == -1) { // from HA - has no 'level'
						if (hue >= 0) matchDevice.setHue(hue)
						if (sat >= 0) matchDevice.setSaturation(sat)
					} else if ((hue >= 0) && (sat >= 0) && (val >= 0)) //all present
					{
						HSL = [: ]
						HSL.put('hue', hue)
						HSL.put('saturation', sat)
						HSL.put('level', val)
						log("HSL set value is $HSL", "INFO")
						matchDevice.setColor(HSL)
						dMatch = true
					}
				} catch (e) {
					log("HSV colour set error format is h,s,v :  " + e, "ERROR")
				}
			}
		}
        
    } else if (cmd == "hsv") {
		if (matchDevice != null) {
			matchDevice.setSaturation(payload[1].toInteger())
			matchDevice.setHue(payload[0].toInteger())
			matchDevice.setLevel(payload[2].toInteger())
			dMatch = true
		}

    } else if (cmd == "hue") {
		if (matchDevice != null) {
			matchDevice.setHue(payload[0].toInteger())
        }
    } else if (cmd == "level") { // currently only searching colour bulbs for this as it's a RGB event
		if (matchDevice != null) {
			matchDevice.setLevel(payload[0].toInteger())
        }
    } else if (cmd == "saturation") {
		if (matchDevice != null) {
                matchDevice.setSaturation(payload[0].toInteger())
        }
    } else if (cmd == "color-temperature") { // This is from the homie topic       //TOD these on homie are normalised names - need to match as such i.e. as in thermostats below TODO BUG ??
            if (matchDevice != null) {
            int cKelvin = state.toInteger()
            int cMired = 0
            if (cKelvin > 1000) cMired = (int) 1000000 / cKelvin // was Kelvin
            else { // wasalready  mireds
                cMired = cKelvin
                cKelvin = (int) 1000000 / cMired
            }
            matchDevice.setColorTemperature(cKelvin)
        }

    }
    //Casey <
    else if (cmd == "lock") {
		if (matchDevice != null) {
                // DUPLICATED TODO combine this as one method for all
                log("Surmising required state [" + state + "] for " + name, "DEBUG")
                LockValues = "true"
                UnlockValues = "false"
                if (LockValues.contains(state.toLowerCase())) {
                    //if (devType == "system")
                    matchDevice.lock() // think can only be a system type here
                    //else device.toON()
                } else if (UnlockValues.contains(state.toLowerCase())) {
                    if (settings?.allowMqttUnlock) {
                        matchDevice.unlock() // think can only be a system type here                    
                    } else {
                        log("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'", "WARN")
                    }
                } else log("Unknown state value " + state + " - need to add to lookup", "WARN")
        }
    }
    //Casey >        
    else if (cmd == "contact") {
		if (matchDevice != null) {
                // DUPLICATED TODO combine this as one method for all
                log("Surmising required state [" + state + "] for " + name, "DEBUG")
                CloseValues = "close"
                OpenValues = "open"
                if (CloseValues.contains(state.toLowerCase())) {
                    //if (devType == "system")
                    log.error "here"
                    matchDevice.close() // think can only be a system type here
                    //else device.toON()
                } else if (OpenValues.contains(state.toLowerCase())) {
                    //if (settings?.allowMqttUnlock) {
                    matchDevice.open() // think can only be a system type here                    
                    // } else {
                    //     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
                    // }
                } else log("Unknown state value " + state + " - need to add to lookup", "WARN")
        }
    } else if (cmd == "battery" || cmd == "motion" || cmd == "temperature") {
        log("Trying to 'set' a sensor value ${cmd} for $name", "WARN")
        log("   ... only 'onoff' 'dim' 'color' 'color-temperature' 'window shades' 'valve' 'garage doors'and 'locks' are settable currently", "WARN")
    } else if (cmd == "valve") {
		if (matchDevice != null) {
			// DUPLICATED TODO combine this as one method for all
			log("Surmising required state [" + state + "] for " + name, "DEBUG")
			CloseValues = "closed"
			OpenValues = "open"
			if (CloseValues.contains(state.toLowerCase())) {
				// if (devType == "system")
				matchDevice.close() // think can only be a system type here
				//else device.toON()
			} else if (OpenValues.contains(state.toLowerCase())) {
				//if (settings?.allowMqttUnlock) {
				matchDevice.open() // think can only be a system type here                    
				// } else {
				//     log ("To enable MQTT unlock, you must enable in MQTT app settings 'configuration'","WARN")
				// }
			} else log("Unknown state value " + state + " - need to add to lookup", "WARN")
		}
    } else if (cmd == "heating-setpoint" || cmd == "cooling-setpoint" || cmd == "mode" || cmd == "fanmode") { // Thermostat temporary handler shouldnt be in sensors
		if (matchDevice != null) {
			//log ("Changing $cmd of ${matchDevice.name} to $state","ERROR")                        
			if (cmd == "heating-setpoint") {
				Float setTemp = state.toFloat() // string seemed to error -- just rechecking
				matchDevice.setHeatingSetpoint(setTemp)
				//matchDevice.setHeatingSetpoint(state)
			} else if (cmd == "cooling-setpoint") {
				setTemp = state.toFloat()
				//thermDev.setCoolingSetpoint(state)
				matchDevice.setCoolingSetpoint(setTemp)
			} else if (cmd == "mode") matchDevice.setThermostatMode(state)
			else if (cmd == "fanmode") matchDevice.setThermostatFanMode(state)
        }
    } else if (cmd == "securitymode") {
        if (state == '----') return
        // >> @jwilliams
		if (matchDevice != null) {
			setStatus = ""
			ArmValues = "armed night, armed home, armed away"
			if (ArmValues.contains(state.toLowerCase())) {
				if (mqttKeypadMode == "No Keycode Needed") {
					setStatus = state
				} else if ((mqttKeypadMode == "Keycode to Arm only" || mqttKeypadMode == "Keycode to Arm/Disarm") && mqttKeypadCode == payload[1]) {
					setStatus = state
				}
			} else if (state == "disarm") {
				if (mqttKeypadMode == "Keycode to Arm/Disarm") {
					if (mqttKeypadCode == payload[1]) setStatus = 'disarm'
				} else if (mqttKeypadMode != "No control of keypad") {
					setStatus = 'disarm'
				}

			}
			log("Setting Status to ${setStatus}", "DEBUG")
			if (setStatus == 'armed night') matchDevice.armNight()
			else if (setStatus == 'armed home') matchDevice.armHome()
			else if (setStatus == 'armed away') matchDevice.armAway()
			else if (setStatus == 'disarm') matchDevice.disarm()
			// << @jwilliams             
			else {
				String code = matchDevice.currentLockCodes.toString()
				mqtt.publishMsg("homie/${atomicState.normHubName}/${matchName}/securitymode/set", '----', 1, false)
				//if (code.contains(':"' + state + '"}')) matchDevice.disarm()
				if (code.contains('{"name":"MQTT","code":"' + state + '"}')) matchDevice.disarm()
			}
        }
        if (dMatch) return
    } else if (cmd == "variable") {
        if (state=='' || state==null) return
        if (matchDevice!=null){
            matchDevice.setVariable(state)
        }
        
/*       
        gVariables = (settings?.gVars)
        gVariables.each {
            //if (normalize(matchDevice.displayName)==matchName){
            if (matchDevice.displayName == matchName) {
                matchDevice.setVariable(state)
                dMatch = true
            }
            return dMatch
        }
        if (dMatch) return
        gVariables = (settings?.globVars)
        gVariables.each {
            //if (normalize(matchDevice.displayName)==matchName){
            if (matchDevice.displayName == matchName) {
                matchDevice.setVariable(state)
                dMatch = true
            }
            return dMatch
        }
        if (dMatch) return
 */
       } else if (cmd == "speech") {
		if (matchDevice != null) {
			matchDevice.speak(state, 30)
        }
    } else if (cmd == "music") {
		if (matchDevice != null) {
			log("Music Command not yet implemented " + matchDevice + " [" + state + "]", "WARN")
        }
    } else if (cmd == "measure-temperature") {
        if (matchDevice != null) {
            log.error matchDevice.typeName
            if (matchDevice.typeName == "Virtual Thermostat")  matchDevice.setTemperature (state)
    
        }
    } else if (cmd == "text") {
        if (matchDevice != null) {
            matchDevice.setText(state)
        }
    
    } else if (cmd == "prefix") {
        if (matchDevice != null) {
            matchDevice.setPrefix(state)
        }
    
    } else if (cmd == "suffix") {
        if (matchDevice != null) {
            matchDevice.setSuffix(state)
        }
    
    }  else log("No matching devices with this command available for ${cmd} for $name $state", "WARN")
}


